// src/api.js (append or ensure these exist)
import api from './axiosInstance'; // your axios instance (assumed)

// Download URL for a product PDF (for anchors)
export const downloadPdfUrl = (productId) => {
  // If you host backend on same origin, just return direct endpoint
  return `/product/${encodeURIComponent(productId)}/pdf`;
};

// fetch product meta (if not already present)
export const fetchProductMeta = async (productId) => {
  const res = await api.get(`/product/${encodeURIComponent(productId)}/meta`);
  return res.data;
};

// query with citations (existing)
export const queryWithCitations = (productIds = [], question = "") => {
  return api.post('/query', { product_ids: productIds, question });
};
###############################
// src/components/CitationCard.jsx
import React from 'react';
import { motion } from 'framer-motion';
import { FaDownload, FaFilePdf } from 'react-icons/fa';

/**
 * Props:
 *  - source: { product_id, product_name }
 *  - onOpen: optional callback (product_id) when clicked
 *  - downloadHref: optional url string for direct download (fallbacks to /product/{id}/pdf)
 */
export default function CitationCard({ source, onOpen = () => {}, downloadHref = null }) {
  const id = source.product_id;
  const name = source.product_name;

  const pdfUrl = downloadHref || `/product/${encodeURIComponent(id)}/pdf`;

  return (
    <motion.a
      href={pdfUrl}
      target="_blank"
      rel="noreferrer"
      whileHover={{ scale: 1.02, y: -4 }}
      whileTap={{ scale: 0.98 }}
      className="group block"
      onClick={(e) => { /* anchor will handle download/open */ }}
      title={`Open ${name}`}
    >
      <div className="relative flex items-center gap-3 bg-white rounded-xl shadow-md p-3 hover:shadow-xl transition">
        <div className="w-12 h-12 rounded-lg bg-gradient-to-br from-purple-200 to-purple-400 flex items-center justify-center text-white">
          <FaFilePdf />
        </div>
        <div className="flex-1 min-w-0">
          <div className="text-sm font-semibold text-primary truncate">{name}</div>
          <div className="text-xs text-gray-400 mt-1 truncate">ID: {id}</div>
        </div>
        <div className="flex-shrink-0">
          <a href={pdfUrl} target="_blank" rel="noreferrer" onClick={(e) => { /* anchor opens */ }} className="inline-flex items-center gap-2 px-3 py-1 rounded-md bg-purple-50 text-purple-700 text-xs font-medium shadow-sm hover:bg-purple-100">
            <FaDownload /> Download
          </a>
        </div>
      </div>
    </motion.a>
  );
}
#########################
// src/components/ChatWindow.jsx
import React, { useRef, useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { FiSend } from 'react-icons/fi';
import MicrophoneButton from './MicrophoneButton';
import CitationCard from './CitationCard';

/**
 * ChatWindow props:
 *  - messages: [{role, content, tables?:[], sources?:[] }]
 *  - onSend(text)
 *  - centeredWidth
 *  - loading: boolean -> show loader overlay
 *  - selectedCitedDocs / removeCitation kept for compatibility
 */
export default function ChatWindow({
  messages,
  onSend,
  centeredWidth = "max-w-3xl",
  loading = false,
  selectedCitedDocs = [],
  removeCitation = () => {}
}) {
  const [text, setText] = useState('');
  const textareaRef = useRef();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [text, messages]);

  const submit = (e) => {
    e && e.preventDefault();
    const t = text.trim();
    if (!t) return;
    onSend(t);
    setText('');
  };

  // parse a markdown table into {headers, rows}
  function parseMdTable(md) {
    // md is a string for one table, lines separated by \n
    const lines = md.trim().split('\n').map(l => l.trim()).filter(l => l);
    if (lines.length < 2) return null;
    // header line is first, separator is second
    const headerLine = lines[0].replace(/^\||\|$/g, '');
    const headers = headerLine.split('|').map(h => h.trim());
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const rowLine = lines[i].replace(/^\||\|$/g, '');
      const cols = rowLine.split('|').map(c => c.trim());
      rows.push(cols);
    }
    return { headers, rows };
  }

  // Convert any markdown tables inside content into an array
  function extractMarkdownTables(content) {
    // find markdown tables pattern
    const tablePatterns = content.match(/(\|[^\n]*\|\s*\n\|[-:\s|]*\|\s*\n(?:\|[^\n]*\|\s*\n?)*)/g);
    if (!tablePatterns) return [];
    return tablePatterns.map(tp => parseMdTable(tp)).filter(Boolean);
  }

  // Render message content: detect parsed tables and sources if message has them
  function renderMessageContent(m) {
    // If message contains structured tables in m.tables (from backend parsed output), render them
    if (m.tables && Array.isArray(m.tables) && m.tables.length > 0) {
      return m.tables.map((t, idx) => (
        <div key={idx} className="mt-3">
          {t.headers && t.headers.length > 0 ? (
            <div className="overflow-auto rounded-lg border">
              <table className="min-w-full divide-y">
                <thead className="bg-gray-50">
                  <tr>
                    {t.headers.map((h, i) => <th key={i} className="px-4 py-2 text-left text-xs font-medium text-gray-600">{h}</th>)}
                  </tr>
                </thead>
                <tbody className="bg-white divide-y">
                  {t.rows.map((r, ri) => (
                    <tr key={ri}>
                      {r.map((c, ci) => <td key={ci} className="px-4 py-2 text-sm">{c}</td>)}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <pre className="bg-gray-50 p-3 rounded whitespace-pre-wrap">{t.raw_md || ''}</pre>
          )}
        </div>
      ));
    }

    // Next: check raw content for markdown table(s)
    const mdTables = extractMarkdownTables(m.content || "");
    if (mdTables && mdTables.length > 0) {
      return mdTables.map((t, i) => (
        <div key={i} className="mt-3">
          <div className="overflow-auto rounded-lg border">
            <table className="min-w-full divide-y">
              <thead className="bg-gray-50">
                <tr>
                  {t.headers.map((h, hi) => <th key={hi} className="px-4 py-2 text-left text-xs font-medium text-gray-600">{h}</th>)}
                </tr>
              </thead>
              <tbody className="bg-white divide-y">
                {t.rows.map((r, ri) => (
                  <tr key={ri}>
                    {r.map((c, ci) => <td key={ci} className="px-4 py-2 text-sm">{c}</td>)}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      ));
    }

    // Else, just return the plain content (with newlines preserved)
    return <div className="whitespace-pre-wrap">{m.content}</div>;
  }

  return (
    <div className={`mx-auto ${centeredWidth}`}>
      <div className="relative bg-white rounded-3xl shadow-2xl p-6">
        {/* loader overlay */}
        {loading && (
          <div className="absolute inset-0 z-50 flex items-center justify-center rounded-3xl bg-white/80 backdrop-blur-sm">
            <div className="flex flex-col items-center gap-3">
              <svg className="w-16 h-16 animate-spin" viewBox="0 0 50 50">
                <circle cx="25" cy="25" r="20" strokeWidth="4" stroke="url(#g1)" fill="none" strokeLinecap="round"></circle>
                <defs>
                  <linearGradient id="g1" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" stopColor="#7c3aed" />
                    <stop offset="100%" stopColor="#a78bfa" />
                  </linearGradient>
                </defs>
              </svg>
              <div className="text-sm text-gray-700">Looking up the document — fetching answer...</div>
            </div>
          </div>
        )}

        {/* Messages */}
        <div className="min-h-[220px] max-h-[54vh] overflow-auto pr-2">
          {messages.map((m, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.28, delay: idx * 0.02 }}
              className={`mb-3 ${m.role === 'user' ? 'flex justify-end' : 'flex justify-start'}`}
            >
              <div className={`${m.role === 'user' ? 'bg-gradient-to-br from-secondary to-primary text-white' : 'bg-gray-50 text-gray-800'} px-4 py-3 rounded-2xl max-w-[80%] whitespace-pre-wrap break-words`}>
                {renderMessageContent(m)}

                {/* If the assistant message has sources, render them as citation cards */}
                {m.sources && m.sources.length > 0 && (
                  <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
                    {m.sources.map((s, i) => (
                      <CitationCard key={i} source={s} />
                    ))}
                  </div>
                )}
              </div>
            </motion.div>
          ))}
        </div>

        {/* Input area */}
        <div className="mt-4 flex items-end gap-3">
          <MicrophoneButton onText={(t) => setText(t)} />
          <textarea
            ref={textareaRef}
            value={text}
            onChange={(e) => setText(e.target.value)}
            rows={1}
            placeholder="Ask about reaction chemistry or type a product name..."
            className="flex-1 resize-none px-4 py-3 rounded-3xl border focus:outline-none focus:ring-2 focus:ring-secondary scrollbar-hide"
            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); } }}
          />
          <button onClick={submit} className="p-3 rounded-full bg-primary text-white shadow hover:scale-95">
            <FiSend />
          </button>
        </div>
      </div>
    </div>
  );
}
#################################################
// src/App.jsx
import React, { useEffect, useState } from 'react';
import ChatWindow from "./ChatWindow";
import ProductTabs from "./ProductTabs";
import ProductDetailModal from "./ProductDetailModal";
import SidebarHistory from "./SidebarHistory";
import {
  fetchReactions,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  queryWithCitations,
  downloadPdfUrl,
} from './api';
import Navbar from "../Navbar/Navbar";
import Footer from "../Footer/Footer";
import chem_logo from "../../assets/Chemhub_Logo_Colored.png";

// Helper: detect markdown tables in a string and convert to structured arrays (headers/rows)
function extractMarkdownTablesFromText(text) {
  if (!text) return [];
  const tablePatterns = text.match(/(\|[^\n]*\|\s*\n\|[-:\s|]*\|\s*\n(?:\|[^\n]*\|\s*\n?)*)/g);
  if (!tablePatterns) return [];
  return tablePatterns.map((tbl) => {
    const lines = tbl.split('\n').map(l => l.trim()).filter(Boolean);
    if (lines.length < 2) return null;
    const headers = lines[0].replace(/^\||\|$/g, '').split('|').map(h => h.trim());
    const rows = [];
    for (let i = 2; i < lines.length; i++) {
      const cols = lines[i].replace(/^\||\|$/g, '').split('|').map(c => c.trim());
      rows.push(cols);
    }
    return { headers, rows, raw_md: tbl };
  }).filter(Boolean);
}

export default function App() {
  const [reactions, setReactions] = useState([]);
  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);
  const [detailModalOpen, setDetailModalOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [history, setHistory] = useState([]);
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);
  // UI-level loading flag for query
  const [queryLoading, setQueryLoading] = useState(false);

  useEffect(() => {
    fetchReactions().then(setReactions).catch(e => console.error("fetchReactions:", e));
    // initial greeting minimal
    setMessages([{ role: 'assistant', content: "Type a reaction or product name to begin — I'll fetch relevant documents." }]);
  }, []);

  const pushMessage = (m) => setMessages(prev => [...prev, m]);

  // Toggle citation selection (right-click)
  const handleToggleCite = (product) => {
    const exists = selectedCitedDocs.find(p => p.id === product.id);
    if (exists) {
      setSelectedCitedDocs(prev => prev.filter(p => p.id !== product.id));
      pushMessage({ role: 'assistant', content: `Removed citation: ${product.name}` });
    } else {
      setSelectedCitedDocs(prev => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: 'assistant', content: `Added citation: ${product.name}` });
    }
  };

  const removeCitation = (id) => {
    const found = selectedCitedDocs.find(d => d.id === id);
    setSelectedCitedDocs(prev => prev.filter(d => d.id !== id));
    if (found) pushMessage({ role: 'assistant', content: `Removed citation: ${found.name}` });
  };

  // Helper to convert backend "sources" (product ids) to the shape expected by ChatWindow
  // We also may fetch meta if we want richer info; for now sources come as {product_id, product_name}
  const normalizeSources = (sources) => {
    if (!sources) return [];
    return sources.map(s => ({ product_id: s.product_id, product_name: s.product_name }));
  };

  // Handle user queries
  const handleUserSend = async (text) => {
    pushMessage({ role: 'user', content: text });

    // Reaction detection (unchanged)
    const norm = text.toString().toLowerCase().replace(/[^a-z0-9]/g, '');
    const match = reactions.find(r => r.toString().toLowerCase().replace(/[^a-z0-9]/g, '') === norm || r.toString().toLowerCase().replace(/[^a-z0-9]/g, '') === text.toString().toLowerCase().replace(/\s+/g,'_').replace(/[^a-z0-9]/g, '') );
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        pushMessage({ role: 'assistant', content: `Found ${prods.length} product${(prods.length === 1 ? '' : 's')} — pick one below.`});
      } catch (e) {
        console.error(e);
        pushMessage({ role: 'assistant', content: 'Error loading products for that reaction.' });
      }
      return;
    }

    // If there are cited docs selected, query across them using /query
    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      setQueryLoading(true);
      try {
        const ids = selectedCitedDocs.map(d => d.id);
        // show intermediate assistant loading message (displayed with loader in ChatWindow)
        pushMessage({ role: 'assistant', content: 'Searching selected documents...', loading: true });
        const res = await queryWithCitations(ids, text);
        const payload = res && res.data ? res.data : res;

        // Remove the previous 'loading' assistant message (we appended it)
        setMessages(prev => {
          // remove last assistant message with loading true
          const idx = prev.map(m => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = prev.slice(0, idx).concat(prev.slice(idx+1));
            return copy;
          }
          return prev;
        });

        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        // push the answer with sources (converted)
        pushMessage({ role: 'assistant', content: answer, sources: normalizeSources(payload.sources) });

      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: 'assistant', content: 'Error querying selected documents.' });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    // If no selected citations and no selected product, call fetchProductDetails without product_id (backend will detect product name)
    if (!selectedProduct) {
      setQueryLoading(true);
      // show loading assistant message
      pushMessage({ role: 'assistant', content: 'Searching documents...', loading: true });
      try {
        const res = await fetchProductDetails(undefined, text);
        const payload = (res && res.data) ? res.data : res;

        // Remove the previous 'loading' assistant message
        setMessages(prev => {
          const idx = prev.map(m => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = prev.slice(0, idx).concat(prev.slice(idx+1));
            return copy;
          }
          return prev;
        });

        // If payload contains parsed structured data: (api_name/procedure/tables)
        if (payload && payload.api_name) {
          // build content summarizing parsed data
          let summary = '';
          if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
          if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
          if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
          if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure||'').slice(0,400)}\n\n`;
          // push assistant message containing structured tables (payload.tables)
          pushMessage({ role: 'assistant', content: summary, tables: (payload.tables || []) });
        } else if (payload && (payload.answer || payload.response)) {
          // it's a QA-style response with answer + possibly sources
          const answer = payload.answer || payload.response || "No answer.";
          pushMessage({ role: 'assistant', content: answer, sources: normalizeSources(payload.sources) });

        } else {
          // fallback
          pushMessage({ role: 'assistant', content: 'No structured data found. Try asking specifically for "Extract API Name..." or select a product.' });
        }
      } catch (err) {
        console.error("fetchProductDetails (no product) error:", err);
        pushMessage({ role: 'assistant', content: 'Error querying documents.' });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    // If a product is selected, call fetchProductDetails(productId, text)
    setQueryLoading(true);
    // show loading assistant message
    pushMessage({ role: 'assistant', content: 'Fetching answer from selected document...', loading: true });
    try {
      const res = await fetchProductDetails(selectedProduct.id, text);
      const payload = (res && res.data) ? res.data : res;

      // Remove the previous 'loading' assistant message
      setMessages(prev => {
        const idx = prev.map(m => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = prev.slice(0, idx).concat(prev.slice(idx+1));
          return copy;
        }
        return prev;
      });

      if (payload && payload.api_name) {
        // structured parsed response
        let summary = '';
        if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
        if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
        if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
        if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure||'').slice(0,400)}\n\n`;
        pushMessage({ role: 'assistant', content: summary, tables: (payload.tables || []) });
        setProductDetails(payload);
        setDetailModalOpen(true);
        setHistory(h => [{ title: selectedProduct.name, content: payload.procedure ? payload.procedure.slice(0,120) : '', productId: selectedProduct.id }, ...h]);
      } else if (payload && (payload.answer || payload.response)) {
        const answer = payload.answer || payload.response || "No answer.";
        pushMessage({ role: 'assistant', content: answer, sources: normalizeSources(payload.sources) });
      } else {
        pushMessage({ role: 'assistant', content: 'No answer found from document.' });
      }
    } catch (err) {
      console.error("fetchProductDetails (selectedProduct) error:", err);
      pushMessage({ role: 'assistant', content: 'Error querying backend.' });
    } finally {
      setQueryLoading(false);
    }
  };

  // open product modal
  const handleSelectProduct = async (productId) => {
    const meta = await fetchProductMeta(productId);
    setSelectedProduct(meta);
    setProductDetails(null);
    setSelectedSchemeUrl(null);
    setLoadingDetails(true);
    setDetailModalOpen(true);
    try {
      const scheme = await fetchSchemeImageUrl(productId);
      setSelectedSchemeUrl(scheme);
    } catch (e) {}
    try {
      const res = await fetchProductDetails(productId); // default extraction
      const d = (res && res.data) ? res.data : res;
      setProductDetails(d);
      setHistory(h => [{ title: meta.name, content: d.procedure ? d.procedure.slice(0,120) : '', productId: meta.id }, ...h]);
    } catch (e) {
      console.error(e);
      pushMessage({ role: 'assistant', content: 'Failed to load product details.'});
    } finally {
      setLoadingDetails(false);
    }
  };

  return (
    <>
      <Navbar/>
      <div className="min-h-screen bg-gradient-to-b from-bg to-white flex">
        <div className="mx-auto my-8 w-full max-w-6xl px-4">
          <div className="flex flex-col items-center justify-center mb-6">
            <img className="h-50 w-30" src={chem_logo} alt="chemhub-logo" />
          </div>

          <div className="relative">
            <ChatWindow
              messages={messages}
              onSend={handleUserSend}
              centeredWidth="max-w-4xl"
              loading={queryLoading || loadingDetails}
              selectedCitedDocs={selectedCitedDocs}
              removeCitation={removeCitation}
            />

            {productListVisible && products && products.length > 0 && (
              <div className="mt-6">
                <ProductTabs
                  products={products}
                  onSelect={handleSelectProduct}
                  onContext={handleToggleCite}
                  citedIds={new Set(selectedCitedDocs.map(d => d.id))}
                />
              </div>
            )}
          </div>
        </div>

        <SidebarHistory history={history} onSelect={(h) => {
          if (h && h.productId) handleSelectProduct(h.productId);
        }} />

        <ProductDetailModal
          open={detailModalOpen}
          onClose={() => setDetailModalOpen(false)}
          meta={selectedProduct}
          details={productDetails}
          loading={loadingDetails}
        />
      </div>
      <Footer/>
    </>
  );
}
