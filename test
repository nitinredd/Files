def predictive_optimal_combinations_advanced(ref_df, test_df, regulation, 
                                             window_min, window_max, diff_threshold=None,
                                             interp_method='gpr', points_per_stratum=None):
    """
    Deterministic selection of candidate time points based on the following rules:
    
      - Use only times from the grid of 3- and 5-minute increments.
      - Define three dissolution strata (using predicted reference values):
            0-30%: select exactly 2 candidate times (excluding the starting time)
            30-60%: select exactly 2 candidate times
            60-90%: select exactly 2 candidate times, with at least one having both ref & test >=80%.
          If a stratum has insufficient eligible times, choose the two times (from the full grid)
          whose predicted reference values are closest to the lower and upper boundaries.
      - Always include the starting time (window_min).
      - For FDA mode, append one extra candidate—the first time (after the last candidate) where
        both predicted values are >=85% (resulting in 7 points total).
      - Compute f2:
            f2 = 50 * log10(100 / (1 + sqrt(mean((test - ref)^2))))
        (with the starting point forced to 0%).
    """
    import numpy as np
    import math
    from sklearn.gaussian_process import GaussianProcessRegressor
    from sklearn.gaussian_process.kernels import ConstantKernel, RBF, WhiteKernel

    # 1. Build valid time grid (3- and 5-minute increments)
    valid_times = np.sort(np.unique(np.concatenate([
        np.arange(window_min, window_max+1, 3),
        np.arange(window_min, window_max+1, 5)
    ])))
    
    # 2. Build GP models.
    kernel = ConstantKernel(1.0) * RBF(length_scale=10.0) + WhiteKernel()
    ref_model = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=5)
    test_model = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=5)
    
    ref_clean = ref_df.dropna()
    test_clean = test_df.dropna()
    ref_model.fit(ref_clean.iloc[:, 0].values.reshape(-1, 1), ref_clean.iloc[:, 1].values.astype(float))
    test_model.fit(test_clean.iloc[:, 0].values.reshape(-1, 1), test_clean.iloc[:, 1].values.astype(float))
    
    # 3. Prediction function.
    def predict_diss(model, times):
        return model.predict(np.array(times).reshape(-1, 1)).flatten()
    
    # Precompute predictions on valid_times.
    all_ref_pred = predict_diss(ref_model, valid_times)
    all_test_pred = predict_diss(test_model, valid_times)
    
    # 4. Define dissolution strata (using predicted reference values).
    strata = {
        "0-30": (0, 30),
        "30-60": (30, 60),
        "60-90": (60, 90)
    }
    required_points = 2  # exactly two points per stratum (excluding starting time)
    
    def eligible_times_for_stratum(stratum_range):
        low, high = stratum_range
        # Exclude the starting time.
        return [t for t, pred in zip(valid_times, all_ref_pred) if t != window_min and low <= pred < high]
    
    candidate = []
    
    # 5. For each stratum, select 2 points.
    for key in ["0-30", "30-60", "60-90"]:
        low_bound, high_bound = strata[key]
        eligible = eligible_times_for_stratum(strata[key])
        if len(eligible) >= required_points:
            # Deterministically choose the earliest and latest among eligible times.
            candidate_stratum = [min(eligible), max(eligible)]
        else:
            # Fallback: from the entire grid (excluding window_min), choose times whose predicted
            # ref values are closest to the lower and upper boundaries.
            others = [t for t in valid_times if t != window_min]
            if not others:
                raise ValueError(f"No candidate times available outside the starting time for stratum {key}.")
            candidate_low = min(others, key=lambda t: abs(all_ref_pred[np.where(valid_times==t)[0][0]] - low_bound))
            candidate_high = min(others, key=lambda t: abs(all_ref_pred[np.where(valid_times==t)[0][0]] - high_bound))
            candidate_stratum = sorted(list(set([candidate_low, candidate_high])))
        candidate.extend(candidate_stratum)
    
    candidate = sorted(list(set(candidate)))
    
    # 6. Ensure starting time is included.
    if window_min not in candidate:
        candidate.insert(0, window_min)
    
    # 7. For the 60-90 stratum, enforce that at least one candidate has both ref and test >=80%.
    eligible_60_90 = eligible_times_for_stratum(strata["60-90"])
    cand_60_90 = [t for t in candidate if t in eligible_60_90]
    meets_80 = False
    for t in cand_60_90:
        idx = int(np.where(valid_times == t)[0][0])
        if all_ref_pred[idx] >= 80 and all_test_pred[idx] >= 80:
            meets_80 = True
            break
    if not meets_80:
        # Replace the later candidate from the 60-90 group with the earliest time in eligible_60_90 meeting the 80% threshold.
        meeting = [t for t in eligible_60_90 if (all_ref_pred[int(np.where(valid_times==t)[0][0])] >= 80 and 
                                                all_test_pred[int(np.where(valid_times==t)[0][0])] >= 80)]
        if meeting:
            current_60_90 = sorted([t for t in candidate if t in eligible_60_90])
            # Remove the maximum candidate in the current 60-90 selection.
            candidate = [t for t in candidate if t not in current_60_90]
            candidate.extend([min(current_60_90), min(meeting)])
            candidate = sorted(list(set(candidate)))
        else:
            raise ValueError("No candidate in 60-90 stratum meets the >=80% threshold for both curves.")
    
    # At this point, for non-FDA mode we expect exactly 6 points.
    expected_count = 6
    # 8. For FDA: Append an extra candidate—the first time after the last candidate with both >=85%.
    if regulation == "FDA":
        expected_count = 7
        last_candidate = candidate[-1]
        post_times = [t for t in valid_times if t > last_candidate]
        extra_point = None
        for t in post_times:
            idx = int(np.where(valid_times == t)[0][0])
            if all_ref_pred[idx] >= 85 and all_test_pred[idx] >= 85:
                extra_point = t
                break
        if extra_point is None:
            raise ValueError("No valid extra candidate found for FDA mode.")
        candidate.append(extra_point)
        candidate = sorted(list(set(candidate)))
    
    if len(candidate) != expected_count:
        raise ValueError(f"Final candidate count ({len(candidate)}) does not equal expected count ({expected_count}).")
    
    # 9. Compute f2.
    ref_vals = predict_diss(ref_model, candidate)
    test_vals = predict_diss(test_model, candidate)
    # Force starting point to 0%.
    if candidate[0] == window_min:
        ref_vals[0] = 0.0
        test_vals[0] = 0.0
    diff = test_vals - ref_vals
    f2 = 50 * math.log10(100 / (1 + math.sqrt(np.mean(diff**2))))
    
    result = {
        'sequence': candidate,
        'f2': round(f2, 2),
        'compliant': True,  # Assume compliance passes (you may call your compliance function here)
        'reasons': [],
        'ref_vals': ref_vals.tolist(),
        'test_vals': test_vals.tolist()
    }
    return [result], [result]
############################
if run_predictive.lower() == 'yes':
    # Determine candidate window (using the helper function)
    window_min, window_max = determine_candidate_window(
        reference_mean_df,
        test_mean_df,
        step=5,
        initial_threshold=10
    )
    
    # Map regulation input.
    regulation_map = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
    selected_regulation = regulation_map.get(input1, "FDA")
    
    print(f"\nCandidate window for combination search: {window_min} to {window_max}")
    
    # Run deterministic predictive analysis.
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='gpr',
        points_per_stratum=None
    )
    
    # Convert candidate time points to ints.
    for cand in results:
        cand['sequence'] = [int(t) for t in cand['sequence']]
    
    overall_best = results[0] if results else None
    
    if overall_best:
        print("\n=== Optimal Predictive Combination ===")
        print(f"Time Points (best candidate): {overall_best['sequence']}")
        print(f"Length: {len(overall_best['sequence'])}")
        print(f"Predicted f2 Score: {overall_best['f2']}")
        if overall_best['reasons']:
            print(f"Compliance Issues: {', '.join(overall_best['reasons'])}")
        else:
            print("Regulatory Compliance: Passed")
        
        # Plot the predicted dissolution curves.
        import matplotlib.pyplot as plt
        plt.figure(figsize=(12, 6))
        time_points = overall_best['sequence']
        ref_diss = interpolate_dissolution_curve(reference_mean_df, np.array(time_points), method='gpr')
        test_diss = interpolate_dissolution_curve(test_mean_df, np.array(time_points), method='gpr')
        if time_points[0] == window_min:
            ref_diss[0] = 0.0
            test_diss[0] = 0.0
        plt.plot(time_points, ref_diss, 'bo-', label='Reference')
        plt.plot(time_points, test_diss, 'r*--', label='Test')
        plt.title(f"Optimal Profile: Predicted Dissolution (f2 = {overall_best['f2']})")
        plt.xlabel('Time (min)')
        plt.ylabel('Dissolution (%)')
        plt.legend()
        plt.grid(True)
        plt.show()
        
        print("\nPredicted Reference Dissolution Percentages:")
        for t, d in zip(time_points, ref_diss):
            print(f"Time {t} min: {d:.2f}%")
        print("\nPredicted Test Dissolution Percentages:")
        for t, d in zip(time_points, test_diss):
            print(f"Time {t} min: {d:.2f}%")
    else:
        print("❌ No candidate sequence was generated.")
    
    print("\n=== All Candidate Combination (Diverse) ===")
    for idx, cand in enumerate(results):
        seq_print = [int(t) for t in cand['sequence']]
        print(f"{idx+1:3d}. | Points: {seq_print} | Length: {len(seq_print)} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
