import streamlit as st
import cv2
import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import json
from google.auth import default
from langchain_google_vertexai import VertexAI
import os
from dotenv import load_dotenv
import tempfile
import io

# Load environment variables
load_dotenv()

# Configuration for VertexAI (Gemini API)
class Config:
    """
    Contains the configuration of the LLM.
    """
    # Set up the Google Application Credentials environment variable to point to your service account JSON
    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "path/to/api.json"
    credentials, project_id = default()
    
    # Configure the LLM with Gemini API
    llm = VertexAI(model_name="gemini-pro", temperature=0.2, max_output_tokens=1024)

config = Config()

def preprocess_image(image):
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                   cv2.THRESH_BINARY, 11, 2)
    return thresh

def detect_tablets(image):
    edges = cv2.Canny(image, 50, 150)
    edge_profile = np.sum(edges, axis=0)
    peaks, _ = find_peaks(edge_profile, distance=50)
    return peaks

def analyze_tablet_porosity(image, n_clusters=3):
    processed_img = preprocess_image(image)
    tablet_boundaries = detect_tablets(processed_img)
    
    results = []
    
    for i in range(len(tablet_boundaries) - 1):
        start, end = tablet_boundaries[i], tablet_boundaries[i+1]
        tablet = processed_img[:, start:end]
        
        tablet_normalized = tablet.astype(float) / 255.0
        pixel_values = tablet_normalized.reshape((-1, 1))
        
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        kmeans.fit(pixel_values)
        
        centers = kmeans.cluster_centers_.flatten()
        sorted_centers = np.sort(centers)
        
        labels = ['Porous', 'Intermediate', 'Dense']
        cluster_map = {i: label for i, label in enumerate(labels)}
        
        unique, counts = np.unique(kmeans.labels_, return_counts=True)
        percentages = dict(zip([cluster_map[i] for i in unique], counts / len(kmeans.labels_) * 100))
        
        segmented_tablet = kmeans.labels_.reshape(tablet.shape)
        
        results.append({
            'tablet_index': i,
            'percentages': percentages,
            'segmented_image': segmented_tablet.tolist()
        })
    
    return results

def analyze_tablet_data_with_gemini(json_data, zone_name):
    prompt = f"""
    Analyze the following quantitative data for tablet cross-sections in the {zone_name}. 
    The data represents the porosity analysis results from computer vision techniques.

    Data:
    {json.dumps(json_data, indent=2)}

    Focus on the following aspects:
    1. Porosity: Interpret the percentages of Porous, Intermediate, and Dense areas. What does this tell us about overall porosity?
    2. Density: Based on the Dense percentage, comment on the overall density of the tablets.
    3. Variation: Are there significant differences between tablets in this zone? What might this imply?
    4. Structure: Can you infer anything about the internal structure based on these percentages?
    5. Implications: What might these characteristics imply about the tablet's properties or manufacturing process?
    6. Recommendations: Based on this data, what further analyses or actions would you recommend?

    Provide a detailed, scientific analysis. If you're uncertain about any aspect, please state so.
    """

    # Use the configured VertexAI LLM from the Config class
    response = config.llm.predict(prompt)
    return response

def main():
    st.title("Tablet Porosity Analysis App")

    uploaded_file = st.file_uploader("Choose an image file", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        # Read the image
        file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
        image = cv2.imdecode(file_bytes, cv2.IMREAD_GRAYSCALE)

        st.image(image, caption="Uploaded Image", use_column_width=True)

        if st.button("Analyze Image"):
            # Perform CV analysis
            with st.spinner("Performing computer vision analysis..."):
                cv_results = analyze_tablet_porosity(image)
            
            st.success("Computer vision analysis complete!")

            # Visualize results
            fig, axes = plt.subplots(1, len(cv_results) + 1, figsize=(5 * (len(cv_results) + 1), 5))
            axes[0].imshow(image, cmap='gray')
            axes[0].set_title('Original Image')
            axes[0].axis('off')

            for i, result in enumerate(cv_results):
                segmented_image = np.array(result['segmented_image'])
                axes[i+1].imshow(segmented_image, cmap='viridis')
                axes[i+1].set_title(f'Tablet {i+1}')
                axes[i+1].axis('off')
                
                text = '\n'.join([f"{k}: {v:.2f}%" for k, v in result['percentages'].items()])
                axes[i+1].text(0.05, 0.95, text, transform=axes[i+1].transAxes, fontsize=8, 
                               verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

            st.pyplot(fig)

            # Perform Gemini analysis
            with st.spinner("Performing Gemini analysis..."):
                gemini_analysis = analyze_tablet_data_with_gemini(cv_results, "Analyzed Zone")

            st.subheader("Gemini Analysis")
            st.write(gemini_analysis)

            # Option to download results
            results_json = json.dumps({
                "cv_results": cv_results,
                "gemini_analysis": gemini_analysis
            })
            st.download_button(
                label="Download Analysis Results",
                data=results_json,
                file_name="tablet_analysis_results.json",
                mime="application/json"
            )

if __name__ == "__main__":
    main()

Streamlit	
OpenCV	
Numpy	
Scikit-learn	
Matplotlib	
Scipy	
Google Auth	
Langchain Google Vertex AI	
Google Generative AI	
Python Dotenv	
