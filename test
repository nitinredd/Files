# app.py
import os
import streamlit as st
import pandas as pd
from difflib import SequenceMatcher
import google.auth
from vertexai.preview.generative_models import GenerativeModel, SafetySetting, HarmCategory, HarmBlockThreshold

# â”€â”€â”€ Gemini Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()
gemini = GenerativeModel("gemini-2.0-flash-thinking-exp-01-21")
safety_config = [
    SafetySetting(category=HarmCategory.HARM_CATEGORY_UNSPECIFIED, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_HARASSMENT, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold=HarmBlockThreshold.BLOCK_NONE),
]

def safe_gemini_summarize(question: str, df: pd.DataFrame) -> str:
    """Send only the found rows + question to Gemini for polished NLP."""
    table_text = df.to_csv(index=False)
    prompt = (
        "User asked: â€œ%sâ€\n\n"
        "Below are the exact matching rows from the Excel data (CSV format):\n\n"
        "%s\n\n"
        "Please concisely answer the userâ€™s question *using only the above data*, "
        "and do NOT add any extra information."
    ) % (question, table_text)
    resp = gemini.generate_content([prompt], safety_settings=safety_config)
    return resp.text or "Sorry, I couldnâ€™t formulate an answer."

# â”€â”€â”€ Agents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ExcelReaderAgent:
    def __init__(self, paths):
        self.paths = paths
        self.sheets = {}  # { "formula master_osd": {sheet: df}, ... }
        self._load_all()

    def _load_all(self):
        for p in self.paths:
            xl = pd.ExcelFile(p)
            self.sheets[p] = {s: xl.parse(s) for s in xl.sheet_names}

    def get_all_rows(self):
        # flatten to list of (workbook, sheet, row_series)
        rows = []
        for wb, sheet_map in self.sheets.items():
            for sheet, df in sheet_map.items():
                for _, row in df.iterrows():
                    rows.append((wb, sheet, row))
        return rows

class FuzzyMatchAgent:
    @staticmethod
    def score(query: str, text: str) -> float:
        return SequenceMatcher(None, query.lower(), text.lower()).ratio()

    def find_matches(self, query: str, rows, threshold=0.6):
        matches = []
        for wb, sheet, row in rows:
            combined = " ".join(str(v) for v in row.values)
            if self.score(query, combined) >= threshold:
                matches.append((wb, sheet, row))
        return matches

class CoordinatorAgent:
    def __init__(self, reader, matcher):
        self.reader = reader
        self.matcher = matcher

    def handle(self, query: str):
        all_rows = self.reader.get_all_rows()
        matched = self.matcher.find_matches(query, all_rows)
        if not matched:
            return None, None
        # build a DataFrame for display & for Gemini
        data = []
        for wb, sheet, row in matched:
            d = row.to_dict()
            d["_workbook"] = os.path.basename(wb)
            d["_sheet"] = sheet
            data.append(d)
        df = pd.DataFrame(data)
        return df, matched

# â”€â”€â”€ Streamlit App UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
st.set_page_config(page_title="Excel Chatbot", layout="wide")
st.title("ðŸ”Ž Excelâ€Powered Chatbot")

# file paths (assumes app.py sits with the .xlsx files)
EXCEL_FILES = ["formula master_osd.xlsx", "masterlist osd equipments.xlsx"]
if not all(os.path.exists(f) for f in EXCEL_FILES):
    st.error("Please place both Excel files alongside app.py")
    st.stop()

# Initialize agents (cached)
@st.cache_resource
def init_agents():
    reader = ExcelReaderAgent(EXCEL_FILES)
    matcher = FuzzyMatchAgent()
    return CoordinatorAgent(reader, matcher)

coord = init_agents()

# --- dynamic example prompts -----------------------------------------------
# choose three random or based on sheet contents
EXAMPLES = [
    f"Do we have {row['Equipment']} with Capacity {row.get('Capacity','?')} in {sheet}?"
    for _, sheet_map in coord.reader.sheets.items()
    for sheet, df in sheet_map.items()
    for _, row in df.sample(min(3, len(df))).iterrows()
]
# ensure exactly 3 unique
import random
EXAMPLES = random.sample(list(set(EXAMPLES)), 3)

st.markdown("**Try one of these:**")
cols = st.columns(3)
for i, prompt in enumerate(EXAMPLES):
    if cols[i].button(prompt):
        st.session_state["question"] = prompt

# --- user input ------------------------------------------------------------
question = st.text_input("Your question:", key="question")
if not question:
    st.info("Ask something about the Excel data above.")
    st.stop()

# --- process query --------------------------------------------------------
with st.spinner("Searching the Excel dataâ€¦"):
    df, matched = coord.handle(question)

if df is None or df.empty:
    st.warning("Relevant information not found.")
else:
    st.success(f"Found {len(df)} matching row(s).")
    st.dataframe(df, use_container_width=True)

    # Gemini summarization
    with st.expander("Generate humanâ€readable answer via Gemini"):
        answer = safe_gemini_summarize(question, df)
        st.markdown(f"> {answer}")
