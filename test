if input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Check criteria & CV
    both_85   = check_both_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:   ", both_85)

    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # (0) Drop timepoint zero
    reference_df = reference_df[reference_df.iloc[:, 0] != 0].reset_index(drop=True)
    test_df      = test_df[test_df.iloc[:, 0] != 0].reset_index(drop=True)

    # 2) Verify time alignment
    if not check_same_time_points(reference_df, test_df):
        print("Error: Time points between test and reference do not match.")
        print("Calculations cannot be performed.")
    else:
        try:
            # 3) Compute FDA f2s & trimmed data
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)

            # 4) Show trimmed times & means
            times      = ref_trim.iloc[:, 0].astype(float).tolist()
            ref_means  = ref_trim.iloc[:, 1:].mean(axis=1).round(2).tolist()
            test_means = test_trim.iloc[:, 1:].mean(axis=1).round(2).tolist()

            print("Trimmed times:        ", times)
            print("Reference means (%):  ", ref_means)
            print("Test means      (%):  ", test_means, "\n")

            # 5) Print f2 results
            print(f"Conventional f2: {f2_conv:.2f}")
            print(f"Expected     f2: {f2_exp:.2f}")
            if not cv_check:
                print("\nWarning: CV requirements not met; interpret with caution.")

            # Graphs omitted for brevity...
        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA-rule f2 calculation.")

    # 6) Predictive optimal combination
    run_predictive = input("\nDo you want to run predictive optimal combination analysis? (yes/no): ")
    if run_predictive.lower() == 'yes':
        window_min, window_max = determine_candidate_window(
            reference_mean_df,
            test_mean_df,
            step=5,
            initial_threshold=10
        )
        regulation_map     = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
        selected_regulation = regulation_map.get(input1, "FDA")
        print(f"\nCandidate window for combination search: {window_min} to {window_max}\n")

        # Try original integer‐grid; on failure, fall back to fractional‐grid
        try:
            results, _ = predictive_optimal_combinations_advanced(
                reference_mean_df,
                test_mean_df,
                regulation         = selected_regulation,
                window_min         = window_min,
                window_max         = window_max,
                diff_threshold     = None,
                interp_method      = 'linear',
                points_per_stratum = None
            )
            print("✅ Used original integer‐grid function\n")
        except ValueError as e:
            print(f"⚠️ Original function failed: {e}")
            print("   Falling back to fractional‐grid version (0.25 h increments)...\n")
            results, _ = predictive_optimal_combinations_fractional(
                reference_mean_df,
                test_mean_df,
                regulation    = selected_regulation,
                window_min    = window_min,
                window_max    = window_max,
                step_hours    = 0.25,
                interp_method = 'linear'
            )

        # Normalize sequence: ints as ints, floats otherwise
        for cand in results:
            cand['sequence'] = [
                int(t) if float(t).is_integer() else t
                for t in cand['sequence']
            ]

        overall_best = results[0] if results else None
        if overall_best:
            print("=== Optimal Predictive Combination ===")
            print(f"Time Points (best candidate): {overall_best['sequence']}")
            print(f"Length: {len(overall_best['sequence'])}")
            print(f"Predicted f2 Score: {overall_best['f2']}")
            print("Regulatory Compliance:", "Passed" if not overall_best['reasons'] else ", ".join(overall_best['reasons']))

            # Plot predicted dissolution curves
            import matplotlib.pyplot as plt
            time_points = overall_best['sequence']
            ref_diss = interpolate_dissolution_curve(reference_mean_df, np.array(time_points), method='linear')
            test_diss = interpolate_dissolution_curve(test_mean_df,      np.array(time_points), method='linear')
            plt.figure(figsize=(12, 6))
            plt.plot(time_points, ref_diss, 'bo-', label='Reference')
            plt.plot(time_points, test_diss, 'r*--', label='Test')
            plt.title(f"Optimal Profile: Predicted Dissolution (f2 = {overall_best['f2']})")
            plt.xlabel('Time (h)')
            plt.ylabel('Dissolution (%)')
            plt.legend()
            plt.grid(True)
            plt.show()
        else:
            print("❌ No candidate sequence was generated.")

        print("\n=== All Candidate Combination (Diverse) ===")
        for idx, cand in enumerate(results):
            print(f"{idx+1:3d}. | Points: {cand['sequence']} | Length: {len(cand['sequence'])} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
