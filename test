# ======================== MODIFIED SECTION: Time Points Generation ========================
# In predictive_optimal_combinations_advanced function
# Replace the existing time_grid and valid_times generation with:

# Generate both 3 and 5 minute intervals regardless of dissolution percentage
time_grid = np.unique(np.concatenate([
    np.arange(window_min, window_max + 1, 3),
    np.arange(window_min, window_max + 1, 5)
])).astype(int)
valid_times = time_grid[(time_grid >= window_min) & (time_grid <= window_max)]

# ======================== MODIFIED SECTION: Combination Processing ========================
# Inside the combination processing loop, add dissolution range calculation
# After interpolation:
ref_vals = interpolate_dissolution_curve(reference_mean_df, seq, method='gpr')
test_vals = interpolate_dissolution_curve(test_mean_df, seq, method='gpr')

# Calculate dissolution range
max_diss = max(np.max(ref_vals), np.max(test_vals))
if max_diss <= 30:
    diss_range = "0-30%"
elif 30 < max_diss <= 60:
    diss_range = "30-60%"
elif 60 < max_diss <= 90:
    diss_range = "60-90%"
else:
    diss_range = "90-100%"

# ======================== MODIFIED SECTION: Results Storage ========================
# Update results.append() call to include dissolution range:
results.append({
    'sequence': seq,
    'f2': round(f2_scores[i], 2),
    'compliant': compliance_status[i],
    'reasons': compliance_reasons[i],
    'length': len(seq),
    'dissolution_range': diss_range  # New field
})

# ======================== NEW SECTION: Dissolution Range Reporting ========================
# After sorting results, add range statistics:
def print_range_stats(results):
    range_stats = {
        "0-30%": {"total": 0, "compliant": 0},
        "30-60%": {"total": 0, "compliant": 0},
        "60-90%": {"total": 0, "compliant": 0},
        "90-100%": {"total": 0, "compliant": 0}
    }
    
    for res in results:
        rng = res['dissolution_range']
        range_stats[rng]['total'] += 1
        if res['compliant']:
            range_stats[rng]['compliant'] += 1
            
    print("\n=== Dissolution Range Statistics ===")
    for rng, stats in range_stats.items():
        print(f"{rng}:")
        print(f"  Total combinations: {stats['total']}")
        print(f"  Compliant combinations: {stats['compliant']}")
        if stats['total'] > 0:
            compliance_rate = stats['compliant']/stats['total']*100
            print(f"  Compliance rate: {compliance_rate:.1f}%")
        print()

# Call this function before displaying results
print_range_stats(all_candidates_sorted)

# ======================== MODIFIED OUTPUT SECTION ========================
# Update the candidate display to include dissolution range
print(f"{idx+1:3d}. Range: {cand['dissolution_range']} | Sequence: {seq} | f2 Score: {f2} | Compliance: {comp}")

# Update optimal combination display
print(f"\n=== Optimal Predictive Combination ===")
print(f"Dissolution Range: {overall_best['dissolution_range']}")
print(f"Time Points: {overall_best['sequence']}")
print(f"f2 Score: {overall_best['f2']}")
