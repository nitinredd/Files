import pandas as pd
import numpy as np
import math
import itertools

def calculate_mean_profile(df):
    times = df.iloc[:, 0].astype(float).values
    means = df.iloc[:, 1:].astype(float).mean(axis=1)
    return times, means

def create_monotonic_profile(times, means, step=0.25, window_max=12):
    t = np.asarray(times, float)
    m = np.asarray(means, float)
    grid = np.arange(0, window_max + step, step)
    prof = np.interp(grid, t, m, left=0.0, right=m[-1])
    return np.maximum.accumulate(prof), grid

def find_85_point(ref, test, regulation):
    for i,(r,t) in enumerate(zip(ref,test)):
        if regulation in ("FDA","ANVISA"):
            if r>=85 and t>=85:
                return i
        else:
            if r>=85 or t>=85:
                return i
    return None

def f2_score(ref_vals, test_vals):
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    return 50 * math.log10(100.0 / (1.0 + np.sqrt(np.mean(diffs**2)))) if len(diffs)>0 else 0.0

def optimal_timepoints(reference_df, test_df, regulation,
                       window_max=12, step_hours=0.25):
    # 1) interpolate
    rt, rm = calculate_mean_profile(reference_df)
    tt, tm = calculate_mean_profile(test_df)
    ref_prof, grid = create_monotonic_profile(rt, rm, step_hours, window_max)
    test_prof, _   = create_monotonic_profile(tt, tm, step_hours, window_max)

    # 2) find 85% index
    idx85 = find_85_point(ref_prof, test_prof, regulation)

    # 3) per-bracket candidates (ensure at least one via fallback)
    brackets = [(0,30), (30,60), (60,80)]
    bracket_cands = []
    for L,U in brackets:
        idxs = list(np.where((ref_prof>=L)&(ref_prof<U))[0])
        if not idxs:
            fb = list(np.where(ref_prof>=L)[0])
            if fb: idxs = [fb[0]]
        bracket_cands.append(idxs)

    # 4) build all valid selections (0–2 per bracket), plus t=0 always
    all_designs = []
    for picks0 in itertools.combinations(bracket_cands[0], r=min(2,len(bracket_cands[0]))):
      for picks1 in itertools.combinations(bracket_cands[1], r=min(2,len(bracket_cands[1]))):
        for picks2 in itertools.combinations(bracket_cands[2], r=min(2,len(bracket_cands[2]))):
            base = {0, *picks0, *picks1, *picks2}
            if idx85 is not None:
                base.add(idx85)
            all_designs.append(sorted(base))

    # 5) evaluate each design
    best = None
    best_f2 = -1
    for design in all_designs:
        # apply ≥7% jump filter
        times, rvals, tvals = [],[],[]
        last_r = -np.inf
        for i in design:
            if abs(ref_prof[i]-last_r) < 7: 
                continue
            times.append(grid[i]); rvals.append(ref_prof[i]); tvals.append(test_prof[i])
            last_r = ref_prof[i]
        if len(rvals)<2: 
            continue
        score = f2_score(rvals, tvals)
        if score > best_f2:
            best_f2 = score
            best = (times, rvals, tvals, score)

    # 6) format output
    if best is None:
        return [], "No valid design found"
    times, rvals, tvals, f2 = best
    sequence = [int(t) if t.is_integer() else round(t,2) for t in times]
    return [{
      'sequence': sequence,
      'f2': round(f2,2),
      'compliant': f2>=50,
      'reasons': [],
      'ref_vals':[round(v,2) for v in rvals],
      'test_vals':[round(v,2) for v in tvals]
    }], None
