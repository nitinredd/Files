import os
import json
import pandas as pd
import streamlit as st
from langchain_openai import AzureChatOpenAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.embeddings.cache import CacheBackedEmbeddings
from langchain.storage.file_system import LocalFileStore
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.docstore.document import Document
from langchain.chains import RetrievalQA
import base64
import glob

# Configuration - Replace with your Azure credentials
st.set_page_config(page_title="PharmaReaction AI", page_icon="🧪", layout="wide")
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

# Azure Configuration
base_url = "https://your-azure-openai-service.openai.azure.com/"
api_version = "2024-02-15-preview"
api_key = "your-azure-api-key"
deployment_name = "GPT4o"
model_name = "GPT4o"

# Initialize Azure services
file_store = LocalFileStore('langchain-embeddings')
base_embeddings = AzureOpenAIEmbeddings(
    model="text-embedding-ada-002",
    api_version="2023-07-01-preview",
    azure_endpoint=base_url,
    api_key=api_key,
    azure_deployment="Def_data_qa"
)
cached_embeddings = CacheBackedEmbeddings.from_bytes_store(base_embeddings, file_store, namespace=base_embeddings.model)

chat_model = AzureChatOpenAI(
    azure_deployment=deployment_name,
    model=model_name,
    api_version=api_version,
    api_key=api_key,
    azure_endpoint=base_url
)

# Product Database Configuration
PRODUCTS_DIR = r"C:\Reaction_Database\Products"
SCHEMES_DIR = r"C:\Reaction_Database\Synthetic_Schemes"

# Custom CSS for professional UI
st.markdown("""
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .stApp {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        
        .product-link {
            color: var(--secondary);
            font-weight: 600;
            font-size: 1.2rem;
            text-decoration: none;
        }
        
        .product-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }
        
        .btn {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }
        
        .btn:hover {
            background: var(--primary);
        }
        
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .tab {
            padding: 0.8rem 1.5rem;
            background: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .tab.active {
            background: var(--secondary);
            color: white;
        }
        
        .scheme-container {
            background: var(--light);
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            margin-top: 1.5rem;
        }
        
        .download-btn {
            background: var(--accent);
            margin-top: 1rem;
        }
        
        .search-bar {
            padding: 1rem;
            border-radius: 50px;
            border: 2px solid var(--secondary);
            font-size: 1.1rem;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
    </style>
""", unsafe_allow_html=True)

# Product Database
@st.cache_resource
def load_product_database():
    products = []
    # Load all PDFs from products directory
    pdf_files = glob.glob(os.path.join(PRODUCTS_DIR, "*.pdf"))
    
    for pdf_path in pdf_files:
        product_name = os.path.splitext(os.path.basename(pdf_path))[0]
        reaction_type = "Unknown"
        
        # Extract reaction type from filename (customize as needed)
        if "Hydrolysis" in product_name:
            reaction_type = "Hydrolysis"
        elif "Oxidation" in product_name:
            reaction_type = "Oxidation"
        elif "Reduction" in product_name:
            reaction_type = "Reduction"
        elif "Synthesis" in product_name:
            reaction_type = "Synthesis"
        
        # Find associated scheme files
        scheme_jpeg = os.path.join(SCHEMES_DIR, f"{product_name}.jpeg")
        scheme_xml = os.path.join(SCHEMES_DIR, f"{product_name}.xml")
        scheme_cdx = os.path.join(SCHEMES_DIR, f"{product_name}.cdx")
        
        products.append({
            "name": product_name,
            "reaction_type": reaction_type,
            "pdf_path": pdf_path,
            "scheme_jpeg": scheme_jpeg if os.path.exists(scheme_jpeg) else None,
            "scheme_xml": scheme_xml if os.path.exists(scheme_xml) else None,
            "scheme_cdx": scheme_cdx if os.path.exists(scheme_cdx) else None
        })
    
    return products

# Load all products
all_products = load_product_database()

# Extract text from PDF
def extract_pdf_text(pdf_path):
    from PyPDF2 import PdfReader
    text = ""
    try:
        pdf_reader = PdfReader(pdf_path)
        for page in pdf_reader.pages:
            text += page.extract_text() + "\n"
    except Exception as e:
        st.error(f"Error reading PDF: {e}")
    return text

# Build vector database
@st.cache_resource
def build_vector_database():
    documents = []
    
    for product in all_products:
        try:
            text = extract_pdf_text(product["pdf_path"])
            if text:
                documents.append(Document(
                    page_content=text,
                    metadata={
                        "product_name": product["name"],
                        "reaction_type": product["reaction_type"],
                        "source": product["pdf_path"]
                    }
                ))
        except Exception as e:
            st.error(f"Error processing {product['name']}: {e}")
    
    if documents:
        return FAISS.from_documents(documents, cached_embeddings)
    return None

# Initialize vector database
vector_db = build_vector_database()

# Child Agent for QA
class ChildAgent:
    def __init__(self, name, retriever):
        self.name = name
        self.retriever = retriever

    def ask(self, query):
        try:
            prompt = (
                "You are a pharmaceutical chemistry expert assistant. Answer user queries about reaction chemistry with exact details. "
                "Your response MUST include:\n"
                "1. **API**: The active pharmaceutical ingredient name\n"
                "2. **Reaction Chemistry**: Type and description\n"
                "3. **Yield**: Exact yield percentage or value\n"
                "4. **Procedure**: Complete procedure EXACTLY as written in the source. Preserve all formatting, punctuation, and structure.\n"
                "5. **Tabular Data**: Provide COMPLETE tabular data verbatim. Do NOT omit, summarize, or transform any content.\n\n"
                "Only include relevant reaction information. Exclude all unrelated content."
            )
            full_query = f"{prompt}\n\n{query}"

            result = RetrievalQA.from_chain_type(
                llm=chat_model,
                chain_type="stuff",
                retriever=self.retriever,
                return_source_documents=True
            ).invoke({"query": full_query})

            return {
                "result": result["result"],
                "source_documents": result["source_documents"],
                "images": None
            }

        except Exception as e:
            st.error(f"Error querying {self.name}: {e}")
            return None

# Agent Manager
class AgentManager:
    def __init__(self, agent):
        self.agent = agent

    def handle_query(self, query):
        response = self.agent.ask(query)
        if not response:
            return "Relevant information not found.", None, []
        
        source_products = set()
        for doc in response.get("source_documents", []):
            if "product_name" in doc.metadata:
                source_products.add(doc.metadata["product_name"])
        
        return response["result"], None, list(source_products)

# Initialize agent
if vector_db:
    retriever = vector_db.as_retriever(search_kwargs={"k": 10})
    agent = ChildAgent(name="reaction_agent", retriever=retriever)
    manager = AgentManager(agent)
else:
    st.error("Failed to initialize vector database. Check PDF files and embeddings setup.")
    st.stop()

# Session state for navigation
if "current_page" not in st.session_state:
    st.session_state.current_page = "search"
if "selected_product" not in st.session_state:
    st.session_state.selected_product = None
if "search_results" not in st.session_state:
    st.session_state.search_results = []

# Navigation functions
def navigate_to_search():
    st.session_state.current_page = "search"

def navigate_to_product(product_name):
    st.session_state.current_page = "product"
    st.session_state.selected_product = product_name

# File download helper
def get_binary_file_downloader_html(file_path, label="Download"):
    with open(file_path, "rb") as f:
        data = f.read()
    b64 = base64.b64encode(data).decode()
    return f'<a href="data:application/octet-stream;base64,{b64}" download="{os.path.basename(file_path)}" class="btn download-btn">{label}</a>'

# Main App
def main():
    # Navigation Header
    st.markdown('<div class="header"><h1>Pharmaceutical Reaction Database</h1><p>AI-powered chemistry knowledge base with 400+ APIs</p></div>', unsafe_allow_html=True)
    
    # Navigation Tabs
    st.markdown('<div class="tabs">', unsafe_allow_html=True)
    if st.button("🔍 Search Database", use_container_width=True):
        navigate_to_search()
    if st.button("🧪 About", use_container_width=True):
        st.session_state.current_page = "about"
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Page Routing
    if st.session_state.current_page == "search":
        render_search_page()
    elif st.session_state.current_page == "product":
        render_product_page()
    elif st.session_state.current_page == "about":
        render_about_page()

# Search Page
def render_search_page():
    st.subheader("Search Reaction Database")
    
    with st.form("search_form"):
        query = st.text_input("Enter chemistry query (e.g., 'Oxidation reactions with high yield'):", 
                              placeholder="Search by reaction type, API name, yield, or conditions...",
                              key="search_input")
        
        if st.form_submit_button("Search", use_container_width=True):
            if query:
                with st.spinner("Searching across 400+ pharmaceutical reactions..."):
                    response, _, products = manager.handle_query(query)
                    st.session_state.search_results = products
            else:
                st.warning("Please enter a search query")
    
    # Display search results
    if st.session_state.search_results:
        st.subheader("Matching Products")
        st.info(f"Found {len(st.session_state.search_results)} products matching your query")
        
        for product_name in st.session_state.search_results:
            product = next((p for p in all_products if p["name"] == product_name), None)
            if product:
                with st.container():
                    st.markdown(f'<div class="card">', unsafe_allow_html=True)
                    st.markdown(f'<a class="product-link" onclick="navigateToProduct(\'{product_name}\')">{product["name"]}</a>', unsafe_allow_html=True)
                    st.caption(f"Reaction Type: {product['reaction_type']}")
                    
                    # JavaScript for navigation
                    st.markdown(f"""
                        <script>
                            function navigateToProduct(productName) {{
                                let data = {{"product": productName}};
                                window.parent.postMessage(data, "*");
                            }}
                        </script>
                    """, unsafe_allow_html=True)
                    
                    st.markdown('</div>', unsafe_allow_html=True)
    
    # Reaction Type Quick Filters
    st.subheader("Browse by Reaction Type")
    reaction_types = sorted(set(p["reaction_type"] for p in all_products))
    cols = st.columns(4)
    
    for i, rtype in enumerate(reaction_types):
        with cols[i % 4]:
            if st.button(f"{rtype} ({sum(1 for p in all_products if p['reaction_type'] == rtype)})", use_container_width=True):
                st.session_state.search_input = rtype
                with st.spinner(f"Searching {rtype} reactions..."):
                    response, _, products = manager.handle_query(rtype)
                    st.session_state.search_results = products
                st.experimental_rerun()

# Product Detail Page
def render_product_page():
    if not st.session_state.selected_product:
        navigate_to_search()
        return
    
    product = next((p for p in all_products if p["name"] == st.session_state.selected_product), None)
    if not product:
        st.error("Product not found")
        navigate_to_search()
        return
    
    # Back button
    if st.button("← Back to Search", key="back_button"):
        navigate_to_search()
        return
    
    st.markdown(f'<div class="card"><h2>{product["name"]}</h2><p>Reaction Type: {product["reaction_type"]}</p></div>', unsafe_allow_html=True)
    
    # Product Information
    with st.spinner(f"Retrieving details for {product['name']}..."):
        query = f"Provide complete details for {product['name']} including API, reaction chemistry, yield, procedure, and tabular data"
        response, _, _ = manager.handle_query(query)
    
    # Display response in tabs
    tab1, tab2, tab3 = st.tabs(["Reaction Details", "Synthetic Scheme", "Source Document"])
    
    with tab1:
        if response:
            st.markdown(response)
        else:
            st.warning("No detailed information found for this product")
    
    with tab2:
        if product["scheme_jpeg"]:
            st.image(product["scheme_jpeg"], caption=f"{product['name']} Synthetic Scheme", use_column_width=True)
            
            # CDX download
            if product["scheme_cdx"] and os.path.exists(product["scheme_cdx"]):
                st.markdown("### Download for ChemDraw")
                st.markdown("""
                    Download the synthetic scheme in CDX format to open in ChemDraw:
                """)
                st.markdown(get_binary_file_downloader_html(
                    product["scheme_cdx"], 
                    f"Download {product['name']}.cdx"
                ), unsafe_allow_html=True)
            else:
                st.warning("CDX format not available for this product")
        else:
            st.warning("Synthetic scheme not available for this product")
    
    with tab3:
        st.info(f"Source document: {os.path.basename(product['pdf_path'])}")
        if st.button("View Full PDF Document", key="view_pdf"):
            with open(product["pdf_path"], "rb") as f:
                pdf_bytes = f.read()
            st.download_button(
                label="Download PDF",
                data=pdf_bytes,
                file_name=os.path.basename(product["pdf_path"]),
                mime="application/pdf"
            )
        
        # Display first page of PDF
        try:
            from PyPDF2 import PdfReader
            import fitz
            
            doc = fitz.open(product["pdf_path"])
            page = doc.load_page(0)
            pix = page.get_pixmap()
            img_bytes = pix.tobytes("jpg")
            st.image(img_bytes, caption="First Page Preview", use_column_width=True)
        except:
            st.warning("Could not load PDF preview")

# About Page
def render_about_page():
    st.subheader("About PharmaReaction AI")
    st.markdown("""
        <div class="card">
            <h3>Comprehensive Pharmaceutical Reaction Database</h3>
            <p>This AI-powered platform provides instant access to detailed reaction chemistry information for 400+ APIs.</p>
            
            <h4>Key Features:</h4>
            <ul>
                <li>Instant search across 400+ pharmaceutical products</li>
                <li>Detailed reaction chemistry information</li>
                <li>Complete synthetic schemes with ChemDraw downloads</li>
                <li>Structured data extraction from technical documents</li>
            </ul>
            
            <h4>Technology Stack:</h4>
            <ul>
                <li>Azure OpenAI (GPT-4o for natural language processing)</li>
                <li>FAISS vector database for efficient similarity search</li>
                <li>Streamlit for web application framework</li>
                <li>CLIP for image understanding (when enabled)</li>
            </ul>
            
            <p>For support or additional information, contact: research@pharmareactions.com</p>
        </div>
    """, unsafe_allow_html=True)

    if st.button("Back to Search", use_container_width=True):
        navigate_to_search()

# Run the app
if __name__ == "__main__":
    main()
