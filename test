from difflib import SequenceMatcher
from typing import Tuple

@app.post("/product/details")
def product_details(req: QARequest):
    """
    Handles product-specific extraction and QA.

    Behavior:
      - If req.product_id is provided:
          * If question is the structured extraction prompt -> return parsed structured data (cached).
          * Else -> run retrieval QA on that product and return answer + sources.
      - If req.product_id is NOT provided:
          * Attempt to detect a product name mentioned in the question (exact normalized match, then fuzzy).
            - If a product is detected -> run retrieval QA on that single product and return answer + sources.
            - If no product detected -> fallback to model-only generative response.
    """
    q_text = (req.question or "").strip()
    if not q_text:
        raise HTTPException(status_code=400, detail="question is required")

    # Helper: normalize strings for robust matching (remove non-alphanum, lowercase)
    def _normalize_for_match(s: str) -> str:
        return re.sub(r'[^a-z0-9]', '', (s or "").lower())

    # Helper: attempt to detect a product mentioned in the free-text query
    def _detect_product_in_text(question: str) -> Optional[Dict[str, Any]]:
        """
        Returns the product dict if a product name is detected in question, else None.
        Strategy:
          1) Exact normalized substring match (prefer longest product names).
          2) Fuzzy matching using SequenceMatcher ratio; pick best above threshold.
        """
        products = list_products()
        if not products:
            return None

        q_norm_space = re.sub(r'[^a-z0-9\s]', ' ', question.lower())
        q_norm_alnum = re.sub(r'[^a-z0-9]', '', question.lower())

        # 1) Exact normalized substring match (prefer long names)
        sorted_products = sorted(products, key=lambda p: len(p["name"]), reverse=True)
        for p in sorted_products:
            name_norm = _normalize_for_match(p["name"])
            if not name_norm:
                continue
            # If normalized name appears in normalized query (alnum) OR query with spaces removal
            if name_norm in q_norm_alnum:
                return p
            # Also check loose token presence
            if name_norm in q_norm_space.replace(' ', ''):
                return p

        # 2) Fuzzy match fallback (SequenceMatcher), choose best above threshold
        best = None
        best_ratio = 0.0
        q_lower = question.lower()
        for p in products:
            pname = (p["name"] or "").lower()
            # compute similarity between product name and question
            ratio = SequenceMatcher(None, pname, q_lower).ratio()
            if ratio > best_ratio:
                best_ratio = ratio
                best = p
        # threshold: pick only if reasonably similar (tweakable)
        if best and best_ratio >= 0.60:
            return best

        return None

    # Helper: run retrieval QA on a single product and return answer + sources
    def _run_retrieval_on_product(product: Dict[str, Any], question: str, k: int = 3) -> Dict[str, Any]:
        pdf_path = product.get("pdf_path")
        if not pdf_path or not os.path.exists(pdf_path):
            raise HTTPException(status_code=404, detail="Product PDF not found")

        # Extract text (could be heavy — consider caching)
        try:
            text = extract_pdf_text(pdf_path)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to extract PDF text: {e}")

        if not text or len(text.strip()) < 20:
            raise HTTPException(status_code=500, detail="Document content is empty or unreadable")

        # Build a Document and temporary FAISS index (safe for single doc)
        doc = Document(page_content=text, metadata={
            "product_id": product["id"],
            "product_name": product["name"],
            "reaction_type": product["reaction_type"],
            "source": product["pdf_path"]
        })

        try:
            vs = FAISS.from_documents([doc], cached_embeddings)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed building vector index: {e}")

        retriever = vs.as_retriever(search_kwargs={"k": k})

        qa_chain = RetrievalQA.from_chain_type(
            llm=chat_model,
            chain_type="stuff",
            retriever=retriever,
            chain_type_kwargs={"prompt": PROMPT},
            return_source_documents=True,  # we want sources for citation
        )

        try:
            out = qa_chain({"query": question})
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"QA execution failed: {e}")

        # Out shape: contains 'result' and 'source_documents'
        answer_text = out.get("result") or out.get("output_text") or ""
        source_docs = out.get("source_documents", []) or []

        # Build unique ordered sources list
        seen = set()
        sources = []
        for sd in source_docs:
            pid = sd.metadata.get("product_id")
            pname = sd.metadata.get("product_name")
            if pid and pid not in seen:
                seen.add(pid)
                sources.append({"product_id": pid, "product_name": pname})

        return {"answer": answer_text, "sources": sources}

    # If a product_id was explicitly provided -> follow existing product-specific flow
    if req.product_id:
        products = list_products()
        product = next((p for p in products if p["id"] == req.product_id), None)
        if not product:
            raise HTTPException(status_code=404, detail="Product not found")

        # Determine whether the question is the structured extraction default or a random user question
        random_question_flag = q_text.lower() not in [
            "extract api name, reaction chemistry, yield, procedure, and tabular data",
            "reaction chemistry",
        ]

        # If it's a random user question -> run retrieval QA on the product and return answer + sources
        if random_question_flag:
            return _run_retrieval_on_product(product, q_text, k=3)

        # Otherwise, it's the structured extraction request -> reuse cached parsing if present
        if req.product_id in _product_details_cache:
            return _product_details_cache[req.product_id]

        # Build vectorstore (or reuse existing) and run the extraction prompt (we want parsed structured result)
        vs = build_product_vector_store(product)
        if not vs:
            raise HTTPException(status_code=500, detail="Failed to build vector store (empty/invalid PDF)")

        retriever = vs.as_retriever(search_kwargs={"k": 1})
        qa_chain = RetrievalQA.from_chain_type(
            llm=chat_model,
            chain_type="stuff",
            retriever=retriever,
            chain_type_kwargs={"prompt": PROMPT},
            return_source_documents=False,
        )

        try:
            raw_response = qa_chain.run(q_text)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"LLM error: {e}")

        parsed = parse_structured_response(raw_response)
        _product_details_cache[req.product_id] = parsed
        return parsed

    # No explicit product_id -> attempt to detect product mention in the question
    detected_product = _detect_product_in_text(q_text)
    if detected_product:
        # If a product is detected, run retrieval QA on that single product and return answer + sources
        return _run_retrieval_on_product(detected_product, q_text, k=3)

    # Fallback: no product id and no detected product -> generative model response
    try:
        # Using the model with the generic prompt template
        # We create a simple chain that uses the prompt template with context empty
        qa_chain = RetrievalQA.from_chain_type(
            llm=chat_model,
            chain_type="stuff",
            retriever=None,  # no retriever — pure model generation
            chain_type_kwargs={"prompt": PROMPT},
            return_source_documents=False,
        )
        raw_response = qa_chain.run(q_text)
        return {"response": raw_response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating response: {e}")
##########################
@app.get("/products/search")
def search_products(q: str = "", limit: int = 10):
    """
    Return up to `limit` products that match the query `q`.
    Matching strategy:
      1. prefix matches on normalized name (best)
      2. substring matches on normalized name (fallback)
    Normalization: lowercased, non-alphanumeric removed (so 'Prod-1' matches 'prod1', 'Prod 1', etc).
    """
    if q is None:
        q = ""
    q_norm = re.sub(r'[^a-z0-9]', '', q.lower())
    if q_norm == "":
        # return first N products as a fallback (stable order)
        prods = list_products()[:limit]
        return [{"id": p["id"], "name": p["name"], "reaction_type": p["reaction_type"]} for p in prods]

    products = list_products()
    # collect prefix matches first (longer names first)
    prefix_matches = []
    substring_matches = []
    for p in products:
        name_norm = re.sub(r'[^a-z0-9]', '', p["name"].lower())
        if name_norm.startswith(q_norm):
            prefix_matches.append(p)
        elif q_norm in name_norm:
            substring_matches.append(p)

    # sort prefix matches by name length (prefer longer exact names)
    prefix_matches = sorted(prefix_matches, key=lambda x: -len(x["name"]))
    substring_matches = sorted(substring_matches, key=lambda x: -len(x["name"]))

    combined = prefix_matches + substring_matches
    combined = combined[:limit]

    return [{"id": p["id"], "name": p["name"], "reaction_type": p["reaction_type"]} for p in combined]

##############################
// src/api.js (append)
export const searchProducts = (query, limit = 10) => {
  return api.get('/products/search', { params: { q: query, limit } });
};
########################
// src/components/ChatWindow.jsx
import React, { useRef, useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { FiSend } from 'react-icons/fi';
import MicrophoneButton from './MicrophoneButton';
import { searchProducts } from '../api'; // <- ensure this exists

/**
 * ChatWindow with product-name autocomplete dropdown.
 *
 * Props:
 *  - messages: array of chat messages
 *  - onSend(text): called when user submits
 *  - centeredWidth: tailwind max-width class
 *  - selectedCitedDocs, removeCitation (kept for compatibility)
 */
export default function ChatWindow({
  messages,
  onSend,
  centeredWidth = "max-w-3xl",
  selectedCitedDocs = [],
  removeCitation = () => {}
}) {
  const [text, setText] = useState('');
  const textareaRef = useRef();
  const [suggestions, setSuggestions] = useState([]); // {id,name,reaction_type}
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1); // for keyboard nav
  const debounceRef = useRef(null);
  const containerRef = useRef(null);

  // autosize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [text, messages]);

  // hide suggestions on outside click
  useEffect(() => {
    const onDocClick = (e) => {
      if (!containerRef.current) return;
      if (!containerRef.current.contains(e.target)) {
        setShowSuggestions(false);
        setActiveIndex(-1);
      }
    };
    document.addEventListener('mousedown', onDocClick);
    return () => document.removeEventListener('mousedown', onDocClick);
  }, []);

  // Debounced search for product suggestions
  useEffect(() => {
    const q = (text || '').trim();
    // If user typed less than 2 chars, don't show suggestions (tweakable)
    if (q.length < 2) {
      setSuggestions([]);
      setShowSuggestions(false);
      setActiveIndex(-1);
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
        debounceRef.current = null;
      }
      return;
    }

    // debounce
    if (debounceRef.current) clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(async () => {
      try {
        const res = await searchProducts(q, 8); // top 8 matches
        const payload = res && res.data ? res.data : res;
        setSuggestions(payload || []);
        setShowSuggestions(Array.isArray(payload) && payload.length > 0);
        setActiveIndex(-1);
      } catch (err) {
        console.error("searchProducts error:", err);
        setSuggestions([]);
        setShowSuggestions(false);
      }
    }, 220); // 220ms debounce
    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
        debounceRef.current = null;
      }
    };
  }, [text]);

  // keyboard handling for the textarea (arrow keys navigate suggestions)
  const onKeyDown = (e) => {
    if (showSuggestions && suggestions.length > 0) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setActiveIndex((i) => Math.min(i + 1, suggestions.length - 1));
        return;
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setActiveIndex((i) => Math.max(i - 1, 0));
        return;
      } else if (e.key === 'Enter' && activeIndex >= 0) {
        // choose active suggestion on Enter (if suggestion focused)
        e.preventDefault();
        chooseSuggestion(suggestions[activeIndex]);
        return;
      } else if (e.key === 'Escape') {
        setShowSuggestions(false);
        setActiveIndex(-1);
        return;
      }
    }

    // default Enter behavior (send) handled in submit below when not in suggestions
    if (e.key === 'Enter' && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      submit();
    }
  };

  // Insert product name into text (or you could set behavior to cite product)
  const chooseSuggestion = (s) => {
    if (!s) return;
    // Option A: Insert product name into the text cursor position — simplest: append if empty or at end
    // For more advanced insertion, you'd calculate selectionStart and splice text; here we append or replace last token
    // We'll replace the current last "word-like" token the user is typing with the product name for a natural feel.

    try {
      const el = textareaRef.current;
      if (el) {
        const cursor = el.selectionStart || text.length;
        // find token start before cursor (allow alnum and punctuation)
        let left = text.slice(0, cursor);
        let right = text.slice(cursor);
        // find last whitespace in left
        const lastWs = left.lastIndexOf(' ');
        const prefix = lastWs === -1 ? '' : left.slice(0, lastWs + 1);
        // Build new text: prefix + product name + (if right begins with whitespace keep it)
        const newText = prefix + s.name + (right && !right.startsWith(' ') ? ' ' + right : right);
        setText(newText);
      } else {
        // fallback
        setText((t) => (t ? t + ' ' + s.name : s.name));
      }
    } catch (e) {
      setText((t) => (t ? t + ' ' + s.name : s.name));
    }

    setShowSuggestions(false);
    setActiveIndex(-1);
    // focus back to textarea
    setTimeout(() => {
      try { textareaRef.current && textareaRef.current.focus(); } catch {}
    }, 0);
  };

  const submit = () => {
    const t = text.trim();
    if (!t) return;
    onSend(t);
    setText('');
    setSuggestions([]);
    setShowSuggestions(false);
    setActiveIndex(-1);
  };

  return (
    <div className={`mx-auto ${centeredWidth}`} ref={containerRef}>
      <div className="bg-white rounded-3xl shadow-2xl p-6">
        {/* Citation chips (if any) */}
        {selectedCitedDocs && selectedCitedDocs.length > 0 && (
          <div className="mb-4 flex flex-wrap gap-2">
            {selectedCitedDocs.map(d => (
              <div key={d.id} className="flex items-center gap-2 bg-purple-50 text-purple-800 px-3 py-1 rounded-full text-xs">
                <span className="max-w-[220px] truncate">{d.name}</span>
                <button onClick={() => removeCitation(d.id)} className="ml-1 px-1 rounded-full bg-white shadow text-xs" title="Remove citation">✕</button>
              </div>
            ))}
          </div>
        )}

        {/* Messages */}
        <div className="min-h-[220px] max-h-[54vh] overflow-auto pr-2">
          {messages.map((m, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.28, delay: idx * 0.02 }}
              className={`mb-3 ${m.role === 'user' ? 'flex justify-end' : 'flex justify-start'}`}
            >
              <div className={`${m.role === 'user' ? 'bg-gradient-to-br from-secondary to-primary text-white' : 'bg-gray-50 text-gray-800'} px-4 py-3 rounded-2xl max-w-[80%] whitespace-pre-wrap break-words`}>
                {m.content}
              </div>
            </motion.div>
          ))}
        </div>

        {/* Input area + suggestions */}
        <div className="mt-4 relative">
          <div className="flex items-end gap-3">
            <MicrophoneButton onText={(t) => setText(t)} />
            <textarea
              ref={textareaRef}
              value={text}
              onChange={(e) => setText(e.target.value)}
              rows={1}
              placeholder="Ask about reaction chemistry or type a product name..."
              className="flex-1 resize-none px-4 py-3 rounded-3xl border focus:outline-none focus:ring-2 focus:ring-secondary scrollbar-hide"
              onKeyDown={onKeyDown}
              onFocus={() => { if (suggestions && suggestions.length > 0) setShowSuggestions(true); }}
            />
            <button onClick={submit} className="p-3 rounded-full bg-primary text-white shadow hover:scale-95">
              <FiSend />
            </button>
          </div>

          {/* Suggestions dropdown */}
          {showSuggestions && suggestions && suggestions.length > 0 && (
            <div className="absolute left-16 right-0 z-40 mt-2 rounded-xl bg-white border shadow-lg overflow-hidden">
              <ul className="max-h-56 overflow-auto">
                {suggestions.map((s, i) => (
                  <li key={s.id}>
                    <button
                      className={`w-full text-left px-4 py-3 hover:bg-gray-50 flex justify-between items-center ${i === activeIndex ? 'bg-gray-100' : ''}`}
                      onMouseDown={(e) => {
                        // use mouseDown to prevent textarea blur before click
                        e.preventDefault();
                        chooseSuggestion(s);
                      }}
                      onMouseEnter={() => setActiveIndex(i)}
                    >
                      <div className="truncate">
                        <div className="font-medium text-sm text-primary">{s.name}</div>
                        <div className="text-xs text-gray-400 mt-1">{(s.reaction_type || "").replace(/_/g, ' ')}</div>
                      </div>
                      <div className="text-xs text-gray-400 ml-4">Select</div>
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
