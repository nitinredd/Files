def predictive_optimal_combinations_advanced(ref_df, test_df, regulation, 
                                            window_min, window_max, diff_threshold=None,
                                            interp_method='linear', num_samples=500000):
    """Fixed version with proper interpolation method handling"""
    # ===== 1. Create Interpolation Functions =====
    time_grid = np.arange(window_min, window_max + 1)
    
    # Handle different interpolation methods
    if interp_method == 'gpr':
        # Gaussian Process Regression implementation
        kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=10.0) + WhiteKernel()
        
        def create_gp_interpolator(x, y):
            gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=5)
            gp.fit(x.reshape(-1, 1), y)
            return lambda xx: gp.predict(xx.reshape(-1, 1))
            
        ref_f = create_gp_interpolator(ref_df.iloc[:,0].values, ref_df.iloc[:,1].values)
        test_f = create_gp_interpolator(test_df.iloc[:,0].values, test_df.iloc[:,1].values)
    else:
        # Standard scipy interpolation
        valid_methods = ['linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic']
        if interp_method not in valid_methods:
            print(f"Invalid method {interp_method}. Defaulting to linear.")
            interp_method = 'linear'
            
        ref_f = interp1d(ref_df.iloc[:,0], ref_df.iloc[:,1],
                        kind=interp_method, bounds_error=False, fill_value="extrapolate")
        test_f = interp1d(test_df.iloc[:,0], test_df.iloc[:,1],
                         kind=interp_method, bounds_error=False, fill_value="extrapolate")

    # Rest of the function remains the same...
