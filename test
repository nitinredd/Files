#Backend
import os
import re
import glob
import base64
import io
import json
from typing import Union
from jose import jwt
import threading
from typing import List, Optional, Dict, Any
from fastapi import FastAPI, HTTPException, UploadFile, File, Form, Depends
from fastapi.responses import JSONResponse, FileResponse, StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBasic
from datetime import datetime, timedelta
from pydantic import BaseModel
import fitz  # PyMuPDF
import pandas as pd
from PIL import Image
from langchain_openai import AzureChatOpenAI
from langchain.embeddings.cache import CacheBackedEmbeddings
from langchain.storage.file_system import LocalFileStore
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.docstore.document import Document
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
import config
import mimetypes
from fastapi import HTTPException
from fastapi.responses import FileResponse

# ---------------------------
# Configuration (as provided by you ‚Äî DO NOT CHANGE unless you need to)
# ---------------------------
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

# Azure Configuration (kept exactly as requested)
base_url=""
api_version="2025-01-01-preview"

api_key=""
deployment_name="api-ai4o"
model_name="gpt-4o"

# Initialize Azure services
file_store = LocalFileStore('langchain-embeddings')
base = AzureOpenAIEmbeddings(
    model="text-embedding-3-large",
    api_version="2025-01-01-preview",
    azure_endpoint="",
    api_key="",
    azure_deployment="api-ai-3l"
)
chat_model = AzureChatOpenAI(
    azure_deployment=deployment_name,
    model=model_name,
    api_version=api_version,
    api_key=api_key,
    azure_endpoint=base_url
)
cached_embeddings = CacheBackedEmbeddings.from_bytes_store(base, file_store, namespace=base.model)
# ---------------------------

# üîê JWT Config
SECRET_KEY = "myFAVsecretKEY"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

# Reaction types and filesystem layout (kept from your code)
REACTION_TYPES = [
    "C-C_Bond_Formation", "C-N_Bond_Formation", "Salt_Formation", "Hydrolysis",
    "Amidation", "Reduction", "Oxidation", "Cyclization", "Purification",
    "Metal_mediated_catalyzed", "C-halogen Bond Formation", "Miscellaneous"
]

BASE_DIR = r"C:\Users\Desktop\WORK\API\Reaction_Database\Datasets_O\Reaction_Database"
PRODUCTS_DIR = os.path.join(BASE_DIR, "Products")
SCHEMES_DIR = os.path.join(BASE_DIR, "Synthetic_Schemes")

# Ensure dirs exist (idempotent)
os.makedirs(PRODUCTS_DIR, exist_ok=True)
os.makedirs(SCHEMES_DIR, exist_ok=True)

# Prompt template (kept largely the same)
PROMPT_TEMPLATE = """
You are a pharmaceutical chemistry expert specializing in reaction chemistry. Extract the following information from the document in a structured format Mandatorily:
1. **API Name**: The active pharmaceutical ingredient
2. **Reaction Chemistry**: Type and description
3. **Yield**: Exact yield percentages or values mentioned in the source
4. **Procedure**: Summarize the complete procedure into clear, concise Number bullet points, preserving the key steps and important details. Do NOT omit any steps or essential content.
5. **Tabular Data**: Provide COMPLETE tabular data in markdown table format. Do NOT omit, summarize, or transform any content.

Structure your response as follows (literal headers must appear in the LLM output exactly like below):

### API Name
[API name here]
### Reaction Chemistry
[Reaction chemistry description here]
### Yield
[Yield value here]
### Procedure
[Complete procedure here]
### Tabular Data
[Markdown table here]

Document Content:
{context}
Question: {question}
Answer:
"""
PROMPT = PromptTemplate(template=PROMPT_TEMPLATE, input_variables=["context", "question"])

# ------------------------------
# Helper functions
# ------------------------------
def find_scheme_image(reaction_type: str, product_name: str) -> Optional[str]:
    for ext in ['.jpeg', '.jpg', '.png', '.gif']:
        scheme_path = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}{ext}")
        if os.path.exists(scheme_path):
            return scheme_path
    return None

def list_products() -> List[Dict[str, Any]]:
    products = []
    for reaction_type in REACTION_TYPES:
        reaction_dir = os.path.join(PRODUCTS_DIR, reaction_type)
        if not os.path.exists(reaction_dir):
            continue
        pdf_files = glob.glob(os.path.join(reaction_dir, "*.pdf"))
        for pdf_path in pdf_files:
            filename = os.path.basename(pdf_path)
            product_name = os.path.splitext(filename)[0]
            scheme_image = find_scheme_image(reaction_type, product_name)
            scheme_cdx = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}.cdx")
            product_id = f"{reaction_type}_{product_name}"
            products.append({
                "id": product_id,
                "name": product_name,
                "reaction_type": reaction_type,
                "pdf_path": pdf_path,
                "scheme_image": scheme_image if scheme_image else None,
                "scheme_cdx": scheme_cdx if os.path.exists(scheme_cdx) else None
            })
    return products

def extract_pdf_text(pdf_path: str) -> str:
    try:
        doc = fitz.open(pdf_path)
        text = ""
        for page in doc:
            text += page.get_text() + "\n"
        return text
    except Exception as e:
        raise RuntimeError(f"Error reading PDF {pdf_path}: {e}")

# Cache for vectorstores and product details
_vectorstore_cache: Dict[str, FAISS] = {}
_product_details_cache: Dict[str, Dict[str, Any]] = {}
_vectorstore_lock = threading.Lock()

def build_product_vector_store(product: Dict[str, Any]) -> Optional[FAISS]:
    pid = product["id"]
    with _vectorstore_lock:
        if pid in _vectorstore_cache:
            return _vectorstore_cache[pid]
        text = extract_pdf_text(product["pdf_path"])
        if not text or len(text.strip()) < 50:
            return None
        doc = Document(page_content=text, metadata={
            "product_id": pid,
            "product_name": product["name"],
            "reaction_type": product["reaction_type"],
            "source": product["pdf_path"]
        })
        vs = FAISS.from_documents([doc], cached_embeddings)
        _vectorstore_cache[pid] = vs
        return vs

def parse_structured_response(text: str) -> Dict[str, Any]:
    """
    Parse the LLM output (which we instructed to use literal '### API Name', etc.)
    Return JSON with keys: api_name, reaction_chemistry, yield, procedure, tables (list)
    Each table is {headers: [], rows: [[], [], ...]}
    """
    result = {"raw": text, "api_name": None, "reaction_chemistry": None, "yield": None, "procedure": None, "tables": []}
    def grab(section):
        m = re.search(rf"###\s*{re.escape(section)}\s*(.*?)\s*(?=###\s*\w+|\Z)", text, re.DOTALL | re.IGNORECASE)
        return m.group(1).strip() if m else None

    result["api_name"] = grab("API Name")
    result["reaction_chemistry"] = grab("Reaction Chemistry")
    result["yield"] = grab("Yield")
    result["procedure"] = grab("Procedure")
    tab_raw = grab("Tabular Data")
    if tab_raw:
        # find markdown tables starting with |...|
        table_patterns = re.findall(r"(\|[^\n]*\|\s*\n\|[-:\s|]*\|\s*\n(?:\|[^\n]*\|\s*\n?)*)", tab_raw, re.DOTALL)
        if table_patterns:
            for tbl_md in table_patterns:
                # normalize lines
                lines = [ln.strip().strip("|").strip() for ln in tbl_md.splitlines() if ln.strip()]
                if len(lines) >= 2:
                    # header line and separator
                    header = [h.strip() for h in lines[0].split("|")]
                    rows = []
                    for rowline in lines[2:]:
                        cols = [c.strip() for c in rowline.split("|")]
                        rows.append(cols)
                    result["tables"].append({"headers": header, "rows": rows, "raw_md": tbl_md})
        else:
            # fallback: provide the raw block
            result["tables"].append({"headers": [], "rows": [], "raw_md": tab_raw})
    return result

# ------------------------------
# FastAPI app
# ------------------------------
app = FastAPI(title="Reaction Database AI (FastAPI)")

# Allow the React dev server origin (adjust if you host differently)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # add your host/origin if different
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ------------------------------
# Pydantic models
# ------------------------------
class ProductOut(BaseModel):
    id: str
    name: str
    reaction_type: str
    has_scheme_image: bool
    has_scheme_cdx: bool

class QARequest(BaseModel):
    product_id: Optional[str] = None  # Make product_id optional
    question: str = "Extract API Name, Reaction Chemistry, Yield, Procedure, and Tabular Data"

# ------------------------------
# Endpoints
# ------------------------------
@app.get("/reactions", response_model=List[str])
def get_reactions():
    return REACTION_TYPES

@app.get("/products", response_model=List[ProductOut])
def get_products(reaction_type: Optional[str] = None):
    allp = list_products()
    if reaction_type:
        allp = [p for p in allp if p["reaction_type"] == reaction_type]
    out = []
    for p in allp:
        out.append(ProductOut(
            id=p["id"],
            name=p["name"],
            reaction_type=p["reaction_type"],
            has_scheme_image=bool(p["scheme_image"]),
            has_scheme_cdx=bool(p["scheme_cdx"])
        ))
    return out

@app.get("/product/{product_id}/meta")
def product_meta(product_id: str):
    products = list_products()
    for p in products:
        if p["id"] == product_id:
            return {
                "id": p["id"],
                "name": p["name"],
                "reaction_type": p["reaction_type"],
                "pdf_path": p["pdf_path"],
                "scheme_image": p["scheme_image"],
                "scheme_cdx": p["scheme_cdx"]
            }
    raise HTTPException(status_code=404, detail="Product not found")

@app.get("/product/{product_id}/pdf")
def product_pdf(product_id: str):
    meta = product_meta(product_id)
    pdf_path = meta["pdf_path"]
    if os.path.exists(pdf_path):
        return FileResponse(pdf_path, media_type="application/pdf", filename=os.path.basename(pdf_path))
    raise HTTPException(status_code=404, detail="PDF not found")

@app.get("/product/{product_id}/scheme-image")
def product_scheme_image(product_id: str):
    meta = product_meta(product_id)
    path = meta.get("scheme_image")
    if path and os.path.exists(path):
        return FileResponse(path, media_type="image/png", filename=os.path.basename(path))
    raise HTTPException(status_code=404, detail="Scheme image not found")

@app.post("/product/details")
def product_details(req: QARequest):
    # If no `product_id` is provided, handle the question directly using the model
    if not req.product_id:
        try:
            # Handle the random question by hitting the model directly
            qa_chain = RetrievalQA.from_chain_type(
                llm=chat_model,
                chain_type="stuff",
                retriever=None,  # No retriever, as there's no associated document
                chain_type_kwargs={"prompt": PROMPT_TEMPLATE},  # Update the prompt as necessary
                return_source_documents=False,
            )
            raw_response = qa_chain.run(req.question)
            return {"response": raw_response}
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error responding to random question: {e}")

    # Lookup product meta if `product_id` is provided
    products = list_products()
    product = next((p for p in products if p["id"] == req.product_id), None)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")

    # Process based on the type of question provided
    random_question_flag = req.question.lower() not in [
        "extract api name, reaction chemistry, yield, procedure, and tabular data",
        "reaction chemistry",
    ]

    if random_question_flag:
        # Handle random question for the provided product/document
        try:
            text = extract_pdf_text(product["pdf_path"])
            doc = Document(page_content=text, metadata={
                "product_id": product["id"],
                "product_name": product["name"],
                "reaction_type": product["reaction_type"],
                "source": product["pdf_path"],
            })
            vs = FAISS.from_documents([doc], cached_embeddings)

            retriever = vs.as_retriever(search_kwargs={"k": 1})
            qa_chain = RetrievalQA.from_chain_type(
                llm=chat_model,
                chain_type="stuff",
                retriever=retriever,
                chain_type_kwargs={"prompt": PROMPT},
                return_source_documents=False,
            )

            raw_response = qa_chain.run(req.question)
            return {"response": raw_response}
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error processing the random question: {e}")

    # Process regular reaction chemistry queries as before
    if req.product_id in _product_details_cache:
        return _product_details_cache[req.product_id]

    vs = build_product_vector_store(product)
    if not vs:
        raise HTTPException(status_code=500, detail="Failed to build vector store (empty/invalid PDF)")

    retriever = vs.as_retriever(search_kwargs={"k": 1})
    qa_chain = RetrievalQA.from_chain_type(
        llm=chat_model,
        chain_type="stuff",
        retriever=retriever,
        chain_type_kwargs={"prompt": PROMPT},
        return_source_documents=False,
    )

    try:
        raw_response = qa_chain.run(req.question)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"LLM error: {e}")

    parsed = parse_structured_response(raw_response)
    _product_details_cache[req.product_id] = parsed
    return parsed

# ------------------------------
# Transcription endpoint (optional Google Cloud)
# ------------------------------
# If you want server-side Google STT you can paste your credentials JSON string into
# GOOGLE_CREDENTIALS_JSON below (NOT recommended for public repos). For demos, prefer browser Web Speech API.
GOOGLE_CREDENTIALS_JSON = ""  # <<< If you want to enable server-side Google STT, paste credentials JSON string here.

@app.post("/transcribe")
async def transcribe_audio(file: UploadFile = File(...), use_google: Optional[bool] = Form(False)):
    """
    Accept an audio file (wav/webm/mp3) and return a transcript.
    By default this endpoint will only provide a simple error unless GOOGLE_CREDENTIALS_JSON is provided.
    The recommended demo approach is to use the browser Web Speech API for instant transcripts.
    """
    content = await file.read()
    if not use_google:
        # We recommend using browser speech API ‚Äî but if user uploaded audio anyway, we can attempt a naive fallback:
        # Try to return an error telling front-end to use browser API.
        return {"error": "Server-side transcription disabled. Use browser Web Speech API for demo, or set use_google=True and provide GOOGLE_CREDENTIALS_JSON in main.py."}

    # If user wants Google transcription server-side:
    if not GOOGLE_CREDENTIALS_JSON:
        return {"error": "GOOGLE_CREDENTIALS_JSON not configured in main.py. Paste credentials JSON string into file to enable."}

    # Server-side Google Cloud Speech-to-Text usage (if enabled)
    try:
        from google.cloud import speech_v1p1beta1 as speech
        from google.oauth2 import service_account
    except Exception as e:
        return {"error": f"google-cloud-speech library not installed: {e}"}

    # Create credentials from JSON string (in-memory)
    creds_info = json.loads(GOOGLE_CREDENTIALS_JSON)
    credentials = service_account.Credentials.from_service_account_info(creds_info)
    client = speech.SpeechClient(credentials=credentials)

    audio = speech.RecognitionAudio(content=content)
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=16000,
        language_code="en-US",
        enable_automatic_punctuation=True,
    )

    response = client.recognize(config=config, audio=audio)
    transcripts = [r.alternatives[0].transcript for r in response.results]
    return {"transcript": " ".join(transcripts)}

# ------------------------------
# Health
# ------------------------------
@app.get("/health")
def health():
    return {"status": "ok"}


# üîê JWT Token Creation Function
def create_access_token(data: dict, expires_delta: Union[timedelta , None] = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

# üîì Login Endpoint
@app.post("/login")
async def login(user_info: dict = Depends(config.check_ldap_auth)):
    if not user_info:
        raise HTTPException(status_code=400, detail="Invalid Credentials")

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user_info["first_name"]},
        expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "Bearer",
        "firstname": user_info["first_name"],
        "lastname": user_info["last_name"],
    }
################################################
import React, { useEffect, useState } from 'react';
import ChatWindow from "./ChatWindow";
import ProductTabs from "./ProductTabs";
import ProductDetailModal from "./ProductDetailModal";
import SidebarHistory from "./SidebarHistory";
import { fetchReactions, fetchProducts, fetchProductMeta, fetchProductDetails, fetchSchemeImageUrl } from './api';
import Navbar from "../Navbar/Navbar";
import Footer from "../Footer/Footer";

import chem_logo from "../../assets/Chemhub_Logo_Colored.png";


export default function App(){
  const [reactions, setReactions] = useState([]);
  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);
  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);
  const [detailModalOpen, setDetailModalOpen] = useState(false);
  const [messages, setMessages] = useState([]); // start empty; chat bar only
  const [history, setHistory] = useState([]);
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  useEffect(() => {
    fetchReactions().then(setReactions).catch(e=>console.error(e));
  }, []);

  const pushMessage = (m) => setMessages(prev => [...prev, m]);

  const normalize = s => (s||'').toString().toLowerCase().replace(/[^a-z0-9]/g, '');

  const handleUserSend = async (text) => {
    pushMessage({ role: 'user', content: text });

    const norm = normalize(text);
    const match = reactions.find(r => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g,'_')));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        pushMessage({ role: 'assistant', content: `Found ${prods.length} product${(prods.length === 1 ? '' : 's')} ‚Äî pick one below.`});
      } catch (e) {
        console.error(e);
        pushMessage({ role:'assistant', content: 'Error loading products for that reaction.' });
      }
      return;
    }

    const prefix = text.match(/(?:show|list|find).{0,20}for\s+(.+)/i);
    if (prefix && prefix[1]) {
      const candidate = prefix[1].trim();
      const found = reactions.find(r => normalize(r).includes(normalize(candidate)) || normalize(candidate).includes(normalize(r)));
      if (found) {
        setSelectedReaction(found);
        try {
          const prods = await fetchProducts(found);
          setProducts(prods || []);
          setProductListVisible(true);
          pushMessage({ role: 'assistant', content: `Found ${prods.length} product${(prods.length === 1 ? '' : 's')}. Select below.`});
        } catch (e) {
          console.error(e);
          pushMessage({ role:'assistant', content: 'Error fetching products.'});
        }
        return;
      }
    }

    if (!selectedProduct) {
      pushMessage({ role: 'assistant', content: 'Please select a product/document first (or type a reaction name to list products).' });
      return;
    }

    try {
      setLoadingDetails(true);
      const res = await fetchProductDetails(selectedProduct.id, text);
      const d = res.data || res;
      let assistantText = '';
      if (d.api_name) assistantText += `API: ${d.api_name}\n\n`;
      if (d.reaction_chemistry) assistantText += `Reaction: ${d.reaction_chemistry}\n\n`;
      if (d.yield) assistantText += `Yield: ${d.yield}\n\n`;
      if (d.procedure) assistantText += `Procedure (excerpt):\n${(d.procedure||'').slice(0,600)}\n\n`;
      if (!assistantText) assistantText = 'No structured answer found.';
      pushMessage({ role: 'assistant', content: assistantText });
      setProductDetails(d);
      setDetailModalOpen(true);
      setHistory(h => [{ title: selectedProduct.name, content: text, productId: selectedProduct.id }, ...h]);
    } catch (err) {
      console.error(err);
      pushMessage({ role: 'assistant', content: 'Error querying backend.'});
    } finally {
      setLoadingDetails(false);
    }
  };

  const handleSelectProduct = async (productId) => {
    const meta = await fetchProductMeta(productId);
    setSelectedProduct(meta);
    setProductDetails(null);
    setSelectedSchemeUrl(null);
    setLoadingDetails(true);
    // show fancy loader by opening the modal early
    setDetailModalOpen(true);
    try {
      // preload scheme url (for chat preview)
      const scheme = await fetchSchemeImageUrl(productId);
      setSelectedSchemeUrl(scheme);
    } catch(e){
      // ignore
    }
    try {
      const res = await fetchProductDetails(productId);
      const d = res.data || res;
      setProductDetails(d);
      setHistory(h => [{ title: meta.name, content: d.procedure ? d.procedure.slice(0,120) : '', productId: meta.id }, ...h]);
    } catch (e) {
      console.error(e);
      pushMessage({ role: 'assistant', content: 'Failed to load product details.'});
    } finally {
      setLoadingDetails(false);
    }
  };

  return (
    <>
    <Navbar/>
    <div className="min-h-screen bg-gradient-to-b from-bg to-white flex">
      {/* center column */}
      <div className="mx-auto my-8 w-full max-w-6xl px-4">
        {/* Header */}
        <div className="flex flex-col items-center justify-center mb-6">
          {/* Logo */}
          <img
            className="h-50 w-30"
            src={chem_logo}
            alt="chemhub-logo"
          />
          
          {/* Tagline
          <h2 className="text-[30px] font-extrabold text-gray-900 mt-4 text-center font-poppins">
            Ask, Browse & Explore
          </h2> */}
        </div>

        <div className="relative">
          <ChatWindow
            messages={messages}
            onSend={handleUserSend}
            centeredWidth="max-w-4xl"
            selectedSchemeUrl={selectedSchemeUrl}
            selectedProduct={selectedProduct}
          />

          {productListVisible && products && products.length > 0 && (
            <div className="mt-6">
              <ProductTabs products={products} onSelect={handleSelectProduct} />
            </div>
          )}
        </div>
      </div>

      <SidebarHistory history={history} onSelect={(h) => {
        if (h && h.productId) handleSelectProduct(h.productId);
      }} />

      <ProductDetailModal
        open={detailModalOpen}
        onClose={() => setDetailModalOpen(false)}
        meta={selectedProduct}
        details={productDetails}
        loading={loadingDetails}
      />
    </div>
    <Footer/>
    </>
  );
}
##########################################################
import React, { useRef, useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { FiSend } from 'react-icons/fi';
import MicrophoneButton from './MicrophoneButton'; // keep your mic component

export default function ChatWindow({ messages, onSend, centeredWidth = "max-w-3xl" }){
  const [text, setText] = useState('');
  const textareaRef = useRef();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [text, messages]);

  const submit = () => {
    const t = text.trim();
    if (!t) return;
    onSend(t);
    setText('');
  };

  return (
    <div className={`mx-auto ${centeredWidth}`}>
      <div className="bg-white rounded-3xl shadow-2xl p-6">
        <div className="min-h-[220px] max-h-[54vh] overflow-auto pr-2">
          {messages.map((m, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.28, delay: idx * 0.02 }}
              className={`mb-3 ${m.role === 'user' ? 'flex justify-end' : 'flex justify-start'}`}
            >
              <div className={`${m.role === 'user' ? 'bg-gradient-to-br from-secondary to-primary text-white' : 'bg-gray-50 text-gray-800'} px-4 py-3 rounded-2xl max-w-[80%] whitespace-pre-wrap break-words`}>
                {m.content}
              </div>
            </motion.div>
          ))}
        </div>

        {/* Input area */}
        <div className="mt-4 flex items-end gap-3">
          <MicrophoneButton onText={(t) => setText(t)} />
          <textarea
            ref={textareaRef}
            value={text}
            onChange={(e)=> setText(e.target.value)}
            rows={1}
            placeholder="Ask about reaction chemistry or type a reaction name..."
            className="flex-1 resize-none px-4 py-3 text-white rounded-3xl border focus:outline-none focus:ring-2 focus:ring-secondary scrollbar-hide"
            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); } }}
          />
          <button onClick={submit} className="p-3 rounded-full bg-primary text-white shadow hover:scale-95">
            <FiSend />
          </button>
        </div>
      </div>
    </div>
  );
}
###########################################
import React, { useRef } from "react";
import { motion } from "framer-motion";

// Props: products: [{id, name, reaction_type, has_scheme_image, has_scheme_cdx}]
// onSelect(productId)

export default function ProductTabs({ products = [], onSelect }) {
  const scrollContainerRef = useRef(null);
  let scrollInterval = null;

  // Scroll a small amount repeatedly for fast scrolling
  const startScrolling = (direction) => {
    if (scrollInterval) return; // Prevent multiple intervals
    scrollInterval = setInterval(() => {
      scrollContainerRef.current.scrollBy({
        left: direction === "left" ? -60 : 60,
        behavior: "smooth",
      });
    }, 100); // Adjust speed by modifying interval timing (100ms here).
  };

  // Stop continuous scrolling
  const stopScrolling = () => {
    clearInterval(scrollInterval);
    scrollInterval = null;
  };

  // Immediate single scroll (used for a normal click)
  const scrollOnce = (direction) => {
    stopScrolling(); // Clear any existing interval
    scrollContainerRef.current.scrollBy({
      left: direction === "left" ? -240 : 240,
      behavior: "smooth",
    });
  };

  return (
    <div className="bg-transparent">
      {/* Header Section */}
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-lg font-semibold text-primary">Matched Products</h3>
        <div className="text-sm text-gray-500">Click a tile to view details</div>
      </div>

      {/* Tabs Container with Navigation */}
      <div className="flex items-center">
        {/* Left Navigation Button */}
        <button
          className="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-full shadow-md transition"
          title="Scroll Left"
          onClick={() => scrollOnce("left")} // Normal click behavior
          onMouseDown={() => startScrolling("left")} // Start long press scrolling
          onMouseUp={stopScrolling} // Stop scrolling when mouse is released
          onTouchStart={() => startScrolling("left")} // Start scrolling on touch
          onTouchEnd={stopScrolling} // Stop scrolling when touch ends
        >
          ‚Üê
        </button>

        {/* Scrollable Tabs */}
        <div
          ref={scrollContainerRef}
          className="overflow-x-auto py-2 w-full no-scrollbar flex gap-3"
        >
          {products.map((product) => (
            <motion.button
              key={product.id}
              whileHover={{ y: -6 }}
              onClick={() => onSelect(product.id)}
              title={product.name}
              className="min-w-[220px] max-w-[240px] flex-shrink-0 bg-white border rounded-2xl p-3 shadow hover:shadow-lg transition flex flex-col"
            >
              {/* Product Tabs Content */}
              <div className="flex items-center justify-between gap-3">
                <div className="text-sm font-semibold truncate">
                  {product.name}
                </div>
                <div className="text-xs text-gray-400">
                  {product.reaction_type.replace(/_/g, " ")}
                </div>
              </div>
              <div className="text-xs mt-2 text-gray-500 truncate">
                {product.pdf_path ? product.pdf_path.split(/[\\/]/).pop() : ""}
              </div>
            </motion.button>
          ))}
        </div>

        {/* Right Navigation Button */}
        <button
          className="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-full shadow-md transition"
          title="Scroll Right"
          onClick={() => scrollOnce("right")} // Normal click behavior
          onMouseDown={() => startScrolling("right")} // Start long press scrolling
          onMouseUp={stopScrolling} // Stop scrolling when mouse is released
          onTouchStart={() => startScrolling("right")} // Start scrolling on touch
          onTouchEnd={stopScrolling} // Stop scrolling when touch ends
        >
          ‚Üí
        </button>
      </div>
    </div>
  );
}
