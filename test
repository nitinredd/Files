import os
import re
import glob
import base64
import fitz  # PyMuPDF
import pandas as pd
import streamlit as st
from langchain_openai import AzureChatOpenAI
from langchain.embeddings.cache import CacheBackedEmbeddings
from langchain.storage.file_system import LocalFileStore
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.docstore.document import Document
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate

# Configuration - Replace with your Azure credentials
st.set_page_config(page_title="PharmaReaction AI", page_icon="ðŸ§ª", layout="wide")
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

# Azure Configuration
base_url = "https://your-azure-openai-service.openai.azure.com/"
api_version = "2024-02-15-preview"
api_key = "your-azure-api-key"
deployment_name = "GPT4o"
model_name = "GPT4o"

# Initialize Azure services
file_store = LocalFileStore('langchain-embeddings')
base_embeddings = AzureOpenAIEmbeddings(
    model="text-embedding-ada-002",
    api_version="2023-07-01-preview",
    azure_endpoint=base_url,
    api_key=api_key,
    azure_deployment="Def_data_qa"
)
cached_embeddings = CacheBackedEmbeddings.from_bytes_store(base_embeddings, file_store, namespace=base_embeddings.model)

chat_model = AzureChatOpenAI(
    azure_deployment=deployment_name,
    model=model_name,
    api_version=api_version,
    api_key=api_key,
    azure_endpoint=base_url
)

# Reaction Chemistry Categories (folder names)
REACTION_TYPES = [
    "C-C Bond Formation", "C-N Bond Formation", "Salt Formation", "Hydrolysis",
    "Amidation", "Reduction", "Oxidation", "Cyclization", "Purification",
    "Metal mediated-catalyzed", "C-halogen Bond Formation", "Miscellaneous"
]

# Base directories
BASE_DIR = r"C:\Reaction_Database"
PRODUCTS_DIR = os.path.join(BASE_DIR, "Products")
SCHEMES_DIR = os.path.join(BASE_DIR, "Synthetic_Schemes")

# Create directories if they don't exist
os.makedirs(PRODUCTS_DIR, exist_ok=True)
os.makedirs(SCHEMES_DIR, exist_ok=True)

# Custom CSS for professional UI
st.markdown("""
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .stApp {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 65vh;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 1rem;
            background: white;
            margin-bottom: 1rem;
            overflow-y: auto;
        }
        
        .message {
            max-width: 80%;
            padding: 0.8rem 1.2rem;
            margin-bottom: 1rem;
            border-radius: 18px;
            line-height: 1.4;
        }
        
        .user-message {
            background: var(--secondary);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }
        
        .bot-message {
            background: var(--light);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }
        
        .product-card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1rem;
            margin: 0.5rem 0;
            cursor: pointer;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .product-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: var(--secondary);
        }
        
        .product-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.3rem;
        }
        
        .reaction-type {
            font-size: 0.85rem;
            color: var(--accent);
            background: #fdecea;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
        }
        
        .input-container {
            display: flex;
            gap: 0.5rem;
        }
        
        .chat-input {
            flex: 1;
            padding: 0.8rem 1.2rem;
            border-radius: 25px;
            border: 2px solid var(--secondary);
            font-size: 1rem;
        }
        
        .send-button {
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 0 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .send-button:hover {
            background: var(--primary);
        }
        
        .detail-view {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding: 1.5rem;
            margin-top: 1rem;
        }
        
        .back-button {
            background: #f0f0f0;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-title {
            color: var(--primary);
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
            margin-top: 1.5rem;
        }
        
        .scheme-container {
            text-align: center;
            margin: 1.5rem 0;
        }
        
        .download-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
            text-decoration: none;
        }
        
        .tab-content {
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 5px;
            margin-top: 1rem;
            border: 1px solid #eee;
        }
    </style>
""", unsafe_allow_html=True)

# Product Database
@st.cache_resource(show_spinner=False)
def load_product_database():
    products = []
    
    # Load products organized by reaction type folders
    for reaction_type in REACTION_TYPES:
        reaction_dir = os.path.join(PRODUCTS_DIR, reaction_type)
        if not os.path.exists(reaction_dir):
            continue
            
        pdf_files = glob.glob(os.path.join(reaction_dir, "*.pdf"))
        
        for pdf_path in pdf_files:
            try:
                filename = os.path.basename(pdf_path)
                product_name = os.path.splitext(filename)[0]
                
                # Find associated scheme files
                scheme_jpeg = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}.jpeg")
                scheme_cdx = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}.cdx")
                
                # Create unique ID based on reaction type and product name
                product_id = f"{reaction_type}_{product_name}"
                
                products.append({
                    "id": product_id,
                    "name": product_name,
                    "reaction_type": reaction_type,
                    "pdf_path": pdf_path,
                    "scheme_jpeg": scheme_jpeg if os.path.exists(scheme_jpeg) else None,
                    "scheme_cdx": scheme_cdx if os.path.exists(scheme_cdx) else None
                })
            except Exception as e:
                st.error(f"Error processing file {pdf_path}: {str(e)}")
    
    return products

# Robust PDF text extraction using PyMuPDF
def extract_pdf_text(pdf_path):
    text = ""
    try:
        doc = fitz.open(pdf_path)
        for page in doc:
            text += page.get_text() + "\n"
        return text
    except Exception as e:
        st.error(f"Error reading PDF {pdf_path}: {str(e)}")
        return ""

# Build vector database with reaction type filtering
@st.cache_resource(show_spinner="Building knowledge base...")
def build_vector_database(products):
    documents = []
    
    for product in products:
        try:
            text = extract_pdf_text(product["pdf_path"])
            if text and len(text.strip()) > 100:  # Ensure meaningful content
                # Include reaction type in metadata for filtering
                documents.append(Document(
                    page_content=text,
                    metadata={
                        "product_id": product["id"],
                        "product_name": product["name"],
                        "reaction_type": product["reaction_type"],
                        "source": product["pdf_path"]
                    }
                ))
        except Exception:
            continue
    
    if documents:
        return FAISS.from_documents(documents, cached_embeddings)
    return None

# Custom prompt template for precise answers
PROMPT_TEMPLATE = """
You are a pharmaceutical chemistry expert specializing in reaction chemistry. 
When answering questions, you MUST provide the following information if available:

1. **API Name**: The active pharmaceutical ingredient
2. **Reaction Chemistry**: Type and description
3. **Yield**: Exact yield percentage or value
4. **Procedure**: Complete procedure EXACTLY as written in the source. 
   Preserve all formatting, punctuation, and structure. Do NOT modify or summarize.
5. **Tabular Data**: Provide COMPLETE tabular data verbatim. 
   Do NOT omit, summarize, or transform any content.

If the question is about a specific product, provide detailed information for that product.
If the question is general, provide an overview and list relevant products.

Context: {context}
Question: {question}
Answer:
"""

PROMPT = PromptTemplate(
    template=PROMPT_TEMPLATE,
    input_variables=["context", "question"]
)

# Session state initialization
def init_session_state():
    if "all_products" not in st.session_state:
        st.session_state.all_products = load_product_database()
    
    if "vector_db" not in st.session_state:
        st.session_state.vector_db = build_vector_database(st.session_state.all_products)
    
    if "messages" not in st.session_state:
        st.session_state.messages = [
            {"role": "assistant", "content": "Hello! I'm your Pharma Reaction Expert. Ask me about any reaction chemistry or pharmaceutical product."}
        ]
    
    if "current_product" not in st.session_state:
        st.session_state.current_product = None
    
    if "search_results" not in st.session_state:
        st.session_state.search_results = []
    
    if "user_query" not in st.session_state:
        st.session_state.user_query = ""

# Get product by ID
def get_product_by_id(product_id):
    for product in st.session_state.all_products:
        if product["id"] == product_id:
            return product
    return None

# File download helper
def get_binary_file_downloader_html(file_path, label="Download"):
    if not os.path.exists(file_path):
        return f'<span class="error">File not found: {os.path.basename(file_path)}</span>'
    
    with open(file_path, "rb") as f:
        data = f.read()
    b64 = base64.b64encode(data).decode()
    return f'<a href="data:application/octet-stream;base64,{b64}" download="{os.path.basename(file_path)}" class="download-btn">{label}</a>'

# Process user query
def process_query(query):
    if not query.strip():
        return "Please enter a valid question."
    
    # Clear previous search results
    st.session_state.search_results = []
    
    # Check if we have a vector database
    if st.session_state.vector_db is None:
        return "Knowledge base is not ready. Please try again later."
    
    try:
        # Check for greeting
        if re.search(r"\b(hi|hello|hey)\b", query, re.IGNORECASE):
            return "Hello! I'm your Pharma Reaction Expert. How can I assist you with reaction chemistry today?"
        
        # Check if query mentions a specific reaction type
        reaction_filter = None
        for rtype in REACTION_TYPES:
            if re.search(rtype, query, re.IGNORECASE):
                reaction_filter = rtype
                break
        
        # Create retriever with potential filter
        search_kwargs = {"k": 5}
        if reaction_filter:
            search_kwargs["filter"] = {"reaction_type": reaction_filter}
        
        retriever = st.session_state.vector_db.as_retriever(search_kwargs=search_kwargs)
        
        # Create QA chain
        qa_chain = RetrievalQA.from_chain_type(
            llm=chat_model,
            chain_type="stuff",
            retriever=retriever,
            chain_type_kwargs={"prompt": PROMPT},
            return_source_documents=True
        )
        
        # Run the query
        result = qa_chain.invoke({"query": query})
        
        # Extract source products
        source_products = set()
        for doc in result["source_documents"]:
            if "product_id" in doc.metadata:
                source_products.add(doc.metadata["product_id"])
        
        st.session_state.search_results = list(source_products)
        
        # Format the response
        response = result["result"]
        
        # If we found products, mention them
        if st.session_state.search_results:
            if reaction_filter:
                response += f"\n\n**Relevant Products for {reaction_filter}:**"
            else:
                response += "\n\n**Relevant Products Found:**"
            
        return response
        
    except Exception as e:
        return f"Error processing your query: {str(e)}"

# Render chat message
def render_message(message):
    if message["role"] == "user":
        return f'<div class="message user-message">{message["content"]}</div>'
    else:
        # Convert newlines to HTML breaks
        content = message["content"].replace('\n', '<br>')
        return f'<div class="message bot-message">{content}</div>'

# Render product card
def render_product_card(product):
    return f"""
    <div class="product-card" onclick="selectProduct('{product['id']}')">
        <div class="product-title">{product['name']}</div>
        <div class="reaction-type">{product['reaction_type']}</div>
    </div>
    """

# Render product detail view
def render_product_detail(product):
    # Initialize agent for this product
    retriever = st.session_state.vector_db.as_retriever(
        search_kwargs={"k": 1, "filter": {"product_id": product["id"]}}
    )
    
    # Create QA chain
    qa_chain = RetrievalQA.from_chain_type(
        llm=chat_model,
        chain_type="stuff",
        retriever=retriever,
        chain_type_kwargs={"prompt": PROMPT},
        return_source_documents=False
    )
    
    # Get product details
    with st.spinner(f"Retrieving details for {product['name']}..."):
        query = f"Provide complete details for {product['name']} including API, reaction chemistry, yield, procedure, and tabular data"
        response = qa_chain.invoke({"query": query})["result"]
    
    # Display details
    st.markdown(f'<div class="detail-view">', unsafe_allow_html=True)
    
    # Back button
    st.markdown("""
        <button class="back-button" onclick="goBack()">
            &larr; Back to Chat
        </button>
    """, unsafe_allow_html=True)
    
    # Product header
    st.markdown(f'<h2>{product["name"]}</h2>', unsafe_allow_html=True)
    st.markdown(f'<div class="reaction-type">{product["reaction_type"]}</div>', unsafe_allow_html=True)
    
    # API Name
    api_match = re.search(r"\*\*API Name\*\*:(.*?)(?=\n\*\*|\Z)", response, re.DOTALL)
    if api_match:
        st.markdown(f'<div class="section-title">API Name</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{api_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Reaction Chemistry
    rxn_match = re.search(r"\*\*Reaction Chemistry\*\*:(.*?)(?=\n\*\*|\Z)", response, re.DOTALL)
    if rxn_match:
        st.markdown(f'<div class="section-title">Reaction Chemistry</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{rxn_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Yield
    yield_match = re.search(r"\*\*Yield\*\*:(.*?)(?=\n\*\*|\Z)", response, re.DOTALL)
    if yield_match:
        st.markdown(f'<div class="section-title">Yield</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{yield_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Procedure
    proc_match = re.search(r"\*\*Procedure\*\*:(.*?)(?=\n\*\*|\Z)", response, re.DOTALL)
    if proc_match:
        st.markdown(f'<div class="section-title">Procedure</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{proc_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Tabular Data
    table_match = re.search(r"\*\*Tabular Data\*\*:(.*?)(?=\n\*\*|\Z)", response, re.DOTALL)
    if table_match:
        st.markdown(f'<div class="section-title">Tabular Data</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{table_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Synthetic scheme
    st.markdown(f'<div class="section-title">Synthetic Scheme</div>', unsafe_allow_html=True)
    if product["scheme_jpeg"] and os.path.exists(product["scheme_jpeg"]):
        st.markdown(f'<div class="scheme-container">', unsafe_allow_html=True)
        st.image(product["scheme_jpeg"], use_column_width=True)
        
        if product["scheme_cdx"] and os.path.exists(product["scheme_cdx"]):
            st.markdown(get_binary_file_downloader_html(
                product["scheme_cdx"], 
                f"Download {product['name']} for ChemDraw"
            ), unsafe_allow_html=True)
        else:
            st.warning("CDX format not available for this product")
        
        st.markdown(f'</div>', unsafe_allow_html=True)
    else:
        st.warning("Synthetic scheme not available for this product")
    
    # Source document
    st.markdown(f'<div class="section-title">Source Document</div>', unsafe_allow_html=True)
    if os.path.exists(product["pdf_path"]):
        with open(product["pdf_path"], "rb") as f:
            pdf_bytes = f.read()
        
        st.download_button(
            label="Download Full PDF",
            data=pdf_bytes,
            file_name=os.path.basename(product["pdf_path"]),
            mime="application/pdf",
            use_container_width=True
        )
    else:
        st.error("PDF file not found")
    
    st.markdown(f'</div>', unsafe_allow_html=True)

# Main App
def main():
    # Initialize session state
    init_session_state()
    
    # Navigation Header
    st.markdown("""
        <div class="header">
            <h1>PharmaReaction AI</h1>
            <p>Chatbot for Reaction Chemistry Knowledge Base</p>
        </div>
    """, unsafe_allow_html=True)
    
    # If we're viewing a product detail, show that
    if st.session_state.current_product:
        product = get_product_by_id(st.session_state.current_product)
        if product:
            render_product_detail(product)
        else:
            st.error("Product not found")
            st.session_state.current_product = None
        return
    
    # Chat interface
    st.markdown('<div class="chat-container" id="chat-container">', unsafe_allow_html=True)
    
    # Display chat messages
    for message in st.session_state.messages:
        st.markdown(render_message(message), unsafe_allow_html=True)
    
    # Display search results if any
    if st.session_state.search_results:
        st.markdown('<div class="section-title">Relevant Products</div>', unsafe_allow_html=True)
        for product_id in st.session_state.search_results:
            product = get_product_by_id(product_id)
            if product:
                st.markdown(render_product_card(product), unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)  # Close chat container
    
    # Input area
    st.markdown('<div class="input-container">', unsafe_allow_html=True)
    user_input = st.text_input("Type your message...", st.session_state.user_query, 
                              key="user_input", 
                              placeholder="Ask about reaction chemistry or products...",
                              label_visibility="collapsed")
    st.markdown('</div>', unsafe_allow_html=True)
    
    # JavaScript for navigation
    st.markdown("""
        <script>
            // Scroll to bottom of chat
            function scrollToBottom() {
                const container = document.getElementById("chat-container");
                container.scrollTop = container.scrollHeight;
            }
            
            // Select product
            function selectProduct(productId) {
                Streamlit.setComponentValue({
                    type: "select_product",
                    productId: productId
                });
            }
            
            // Go back to chat
            function goBack() {
                Streamlit.setComponentValue({
                    type: "go_back"
                });
            }
            
            // Handle messages
            Streamlit.on('message', function(event) {
                if (event.data.type === "select_product") {
                    Streamlit.setComponentValue(event.data);
                }
                if (event.data.type === "go_back") {
                    Streamlit.setComponentValue(event.data);
                }
            });
            
            // Scroll to bottom on load
            window.addEventListener('load', scrollToBottom);
        </script>
    """, unsafe_allow_html=True)
    
    # Send button
    col1, col2 = st.columns([1, 3])
    with col1:
        if st.button("Send", key="send_button", use_container_width=True):
            if st.session_state.user_input.strip():
                # Add user message to chat
                st.session_state.messages.append({"role": "user", "content": st.session_state.user_input})
                
                # Process query and get response
                with st.spinner("Analyzing reaction chemistry..."):
                    response = process_query(st.session_state.user_input)
                
                # Add bot response to chat
                st.session_state.messages.append({"role": "assistant", "content": response})
                
                # Clear input
                st.session_state.user_query = ""
                st.rerun()
    
    with col2:
        if st.button("Clear Chat", key="clear_button", use_container_width=True):
            st.session_state.messages = [
                {"role": "assistant", "content": "Hello! I'm your Pharma Reaction Expert. Ask me about any reaction chemistry or pharmaceutical product."}
            ]
            st.session_state.search_results = []
            st.session_state.user_query = ""
            st.rerun()

# Run the app
if __name__ == "__main__":
    # Handle component messages
    query_params = st.experimental_get_query_params()
    
    if "select_product" in query_params:
        st.session_state.current_product = query_params["select_product"][0]
        st.experimental_set_query_params()
        st.rerun()
    
    if "go_back" in query_params:
        st.session_state.current_product = None
        st.experimental_set_query_params()
        st.rerun()
    
    main()
