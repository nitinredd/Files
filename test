import streamlit as st
import io
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
import pdfplumber
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.platypus import Table, TableStyle, Paragraph
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
import time

# Initialize OpenAI API
import os
from langchain.llms import AzureOpenAI

os.environ["OPENAI_API_KEY"] = "your-api-key-here"
os.environ["OPENAI_API_TYPE"] = "azure"
os.environ["OPENAI_API_BASE"] = "your-api-base-url-here"
os.environ["OPENAI_API_VERSION"] = "2023-05-15"

MODEL_NAME = "gpt-4"  # or your specific Azure OpenAI model deployment name

def chunk_text(text, chunk_size=4000, chunk_overlap=200):
    chunks = []
    start = 0
    while start < len(text):
        end = start + chunk_size
        if end < len(text):
            last_period = text.rfind('.', start, end)
            last_newline = text.rfind('\n', start, end)
            end = max(last_period, last_newline)
            if end <= start:
                end = start + chunk_size
        chunk = text[start:end]
        chunks.append(chunk)
        start = end - chunk_overlap
    return chunks

def translate_text(text, source_lang):
    try:
        llm = AzureOpenAI(
            deployment_name=MODEL_NAME,
            temperature=0,
            max_tokens=1024,
            top_p=1,
            frequency_penalty=0,
            presence_penalty=0
        )
        prompt = PromptTemplate(
            input_variables=["text", "source_lang"],
            template="Translate the following {source_lang} text to English, preserving the original meaning and style:\n\n{text}"
        )
        chain = LLMChain(llm=llm, prompt=prompt)
        result = chain.run(text=text, source_lang=source_lang)
        return result
    except Exception as e:
        st.error(f"Translation error: {str(e)}")
        return f"Translation error: {str(e)}"

def create_pdf(translated_content):
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    styles = getSampleStyleSheet()
    normal_style = styles['Normal']

    try:
        for page_content in translated_content:
            y = height - 50
            for content_type, content in page_content:
                if content_type == "text":
                    for line in content.split('\n'):
                        p = Paragraph(line, normal_style)
                        p_width, p_height = p.wrap(width - 100, height)
                        if y - p_height < 50:
                            c.showPage()
                            y = height - 50
                        p.drawOn(c, 50, y - p_height)
                        y -= p_height + 10
                elif content_type == "table":
                    table = Table(content)
                    table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 14),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                        ('FONTSIZE', (0, 1), (-1, -1), 12),
                        ('TOPPADDING', (0, 1), (-1, -1), 6),
                        ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black)
                    ]))
                    table_width, table_height = table.wrap(width - 100, height)
                    if y - table_height < 50:
                        c.showPage()
                        y = height - 50
                    table.drawOn(c, 50, y - table_height)
                    y -= table_height + 20
            c.showPage()

        c.save()
        buffer.seek(0)
        return buffer
    except Exception as e:
        st.error(f"PDF creation error: {str(e)}")
        return None

st.title("PDF Translation App")

uploaded_file = st.file_uploader("Choose a PDF file", type="pdf")
source_lang = st.selectbox("Select source language", ["Chinese", "Japanese"])

if uploaded_file is not None:
    with pdfplumber.open(uploaded_file) as pdf:
        content = []
        for page in pdf.pages:
            page_content = []
            tables = page.extract_tables()
            if tables:
                for table in tables:
                    page_content.append(("table", table))
            text = page.extract_text()
            if text:
                page_content.append(("text", text))
            content.append(page_content)
    
    if st.button("Translate"):
        translated_content = []
        progress_bar = st.progress(0)
        status_text = st.empty()
        translated_text = st.empty()
        total_pages = len(content)
        
        for page_num, page_content in enumerate(content):
            translated_page = []
            for content_type, item in page_content:
                if content_type == "text":
                    chunks = chunk_text(item)
                    translated_chunks = []
                    for chunk in chunks:
                        translated_chunk = translate_text(chunk, source_lang)
                        translated_chunks.append(translated_chunk)
                    translated_page.append(("text", " ".join(translated_chunks)))
                elif content_type == "table":
                    translated_table = [[translate_text(cell, source_lang) if cell else "" for cell in row] for row in item]
                    translated_page.append(("table", translated_table))
            
            translated_content.append(translated_page)
            
            progress = (page_num + 1) / total_pages
            progress_bar.progress(progress)
            status_text.text(f"Translating page {page_num + 1} of {total_pages} ({progress:.0%})")
            
            translated_text.subheader(f"Translated Content (Page {page_num + 1})")
            for content_type, item in translated_page:
                if content_type == "text":
                    translated_text.write(item)
                elif content_type == "table":
                    translated_text.table(item)
            
            time.sleep(0.1)
        
        status_text.text("Translation completed!")
        
        if progress >= 0.5:
            pdf_buffer = create_pdf(translated_content)
            if pdf_buffer:
                st.download_button(
                    label="Download translated PDF",
                    data=pdf_buffer,
                    file_name="translated_document.pdf",
                    mime="application/pdf"
                )
            else:
                st.error("Failed to create PDF. Check the error message above.")
        else:
            st.warning("Translation is less than 50% complete. Please wait for more pages to be translated before downloading.")
