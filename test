import pandas as pd
import numpy as np
import math

def calculate_mean_profile(df):
    times = df.iloc[:, 0].astype(float).values
    vals  = df.iloc[:, 1:].astype(float)
    return pd.DataFrame({'Time': times, 'Mean': vals.mean(axis=1)})

def create_monotonic_profile(times, means, step=0.25, window_max=12):
    """Returns (profile, grid)."""
    grid = np.arange(0, window_max + step, step)
    prof = np.interp(grid, times, means, left=0.0, right=means[-1])
    return np.maximum.accumulate(prof), grid

def select_bracket_points_v5(ref, test, grid, brackets, max_per=2):
    selected = set([0])  # always include t=0

    for L, U in brackets:
        # eligible: ref in [L, U)
        idxs = np.where((ref >= L) & (ref < U))[0].tolist()
        # fallback: first ref ≥ L
        if not idxs:
            idxs = np.where(ref >= L)[0].tolist()
        if not idxs:
            continue  # nothing even ≥ L

        picks = []
        # always take the earliest
        picks.append(idxs[0])
        # if there's a second, pick the one with minimal |ref-test|
        if len(idxs) > 1:
            diffs = np.abs(test[idxs] - ref[idxs])
            best = idxs[int(np.argmin(diffs))]
            if best not in picks:
                picks.append(best)

        # limit to max_per
        for ix in sorted(picks)[:max_per]:
            selected.add(ix)

    return sorted(selected)

def find_85_point(ref, test, grid, regulation):
    for i in range(len(grid)):
        if regulation in ("FDA", "ANVISA"):
            if ref[i] >= 85 and test[i] >= 85:
                return i
        else:
            if ref[i] >= 85 or test[i] >= 85:
                return i
    return None

def format_results(grid, indices, ref, test, regulation):
    times, rvals, tvals = [], [], []
    last = -np.inf

    for i in indices:
        if abs(ref[i] - last) < 7:
            continue
        times.append(grid[i])
        rvals.append(ref[i])
        tvals.append(test[i])
        last = ref[i]

    idx85 = find_85_point(ref, test, grid, regulation)
    if idx85 is not None and grid[idx85] not in times:
        times.append(grid[idx85])
        rvals.append(ref[idx85])
        tvals.append(test[idx85])

    order = np.argsort(times)
    return ([times[j] for j in order],
            [rvals[j] for j in order],
            [tvals[j] for j in order])

def predictive_optimal_combinations_monotonic_v5(
    ref_df, test_df, regulation,
    window_max=12, step_hours=0.25
):
    # 1. Mean
    rm = calculate_mean_profile(ref_df)
    tm = calculate_mean_profile(test_df)

    # 2. Monotonic interp
    ref_prof, grid = create_monotonic_profile(rm.Time, rm.Mean, step_hours, window_max)
    test_prof, _    = create_monotonic_profile(tm.Time, tm.Mean, step_hours, window_max)

    # 3. Bracket picking
    brackets = [(0,30), (30,60), (60,80)]
    idxs = select_bracket_points_v5(ref_prof, test_prof, grid, brackets, max_per=2)

    # 4. Format & 85%
    times, rvals, tvals = format_results(grid, idxs, ref_prof, test_prof, regulation)

    # 5. f2 (skip first point in RMSD)
    if len(rvals) > 1:
        diffs = np.array(tvals[1:]) - np.array(rvals[1:])
        f2 = 50 * math.log10(100.0 / (1.0 + np.sqrt(np.mean(diffs**2))))
    else:
        f2 = 0.0

    # Clean rounding
    seq = [int(t) if float(t).is_integer() else round(t,2) for t in times]
    return [{
        'sequence': seq,
        'f2': round(f2,2),
        'compliant': f2 >= 50,
        'reasons': [],
        'ref_vals': [round(v,2) for v in rvals],
        'test_vals': [round(v,2) for v in tvals]
    }]
