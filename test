import numpy as np
import math

def predictive_optimal_combinations_final(ref_df, test_df, regulation,
                                          window_max, step_hours=0.25):
    """
    ref_df / test_df each have columns ['time', 'diss'] (diss = mean %).
    regulation ∈ {"FDA","ANVISA","EMA","China","ASEAN"}.
    """
    # 1) Build grid 0→window_max
    times = np.arange(0.0, window_max + 1e-8, step_hours)
    ref_pred  = np.array(np.interp(times, ref_df['time'],  ref_df['diss']),  dtype=float)
    test_pred = np.array(np.interp(times, test_df['time'], test_df['diss']), dtype=float)

    # 2) Always start with t=0
    seq_idxs = [0]  # index into `times`

    # 3) Three percent‐brackets
    for low, high in [(0,30), (30,60), (60,80)]:
        # indices whose ref_pred ∈ [low, high)
        idxs = [i for i,p in enumerate(ref_pred) if p >= low and p < high]
        if len(idxs) >= 2:
            pick = [idxs[0], idxs[-1]]
        elif len(idxs) == 1:
            i0 = idxs[0]
            mid = (low + high) / 2
            # find grid‐point closest to that midpoint
            dists = [(abs(ref_pred[j] - mid), j) for j in range(len(times)) if j != i0]
            i1 = min(dists, key=lambda x: x[0])[1]
            pick = sorted([i0, i1])
        else:
            # no hits: pick closest to the low‐edge and high‐edge
            low_d  = [(abs(ref_pred[j] - low),  j) for j in range(len(times))]
            high_d = [(abs(ref_pred[j] - (high - 1e-6)), j) for j in range(len(times))]
            i_low  = min(low_d,  key=lambda x: x[0])[1]
            i_high = min(high_d, key=lambda x: x[0])[1]
            pick = sorted({i_low, i_high})
        seq_idxs.extend(pick)

    # de‐dupe & keep in time order
    seq_idxs = sorted(dict.fromkeys(seq_idxs))  # preserves order

    # 4) FDA/ANVISA extra point > last
    last_i = seq_idxs[-1]
    post   = list(range(last_i+1, len(times)))
    extra_i = None

    if regulation in ("FDA","ANVISA"):
        for i in post:
            if ref_pred[i] >= 85 and test_pred[i] >= 85:
                extra_i = i
                break
    else:
        for i in post:
            if ref_pred[i] >= 85 or test_pred[i] >= 85:
                extra_i = i
                break

    if extra_i is None:
        # fallback: pick the post‐time that maximizes min(ref, test)
        best_v, best_i = -1, None
        for i in post:
            v = min(ref_pred[i], test_pred[i])
            if v > best_v:
                best_v, best_i = v, i
        extra_i = best_i

    if extra_i is not None and extra_i not in seq_idxs:
        seq_idxs.append(extra_i)
        seq_idxs = sorted(seq_idxs)

    # 5) Build actual time points & values
    seq = [float(times[i]) for i in seq_idxs]
    ref_vals  = [float(ref_pred[i])  for i in seq_idxs]
    test_vals = [float(test_pred[i]) for i in seq_idxs]

    # force 0% at t=0
    ref_vals[0]  = 0.0
    test_vals[0] = 0.0

    # 6) Compute f2 EXCLUDING the first point
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    mse   = np.mean(diffs**2)
    f2    = 50 * math.log10(100 / (1 + math.sqrt(mse)))

    return [{
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals,
        'test_vals': test_vals,
    }], None
###############################################
if input1 == 1:
    # … your existing FDA‐rule checks/plots here …

    run_predictive = input("\nDo you want to run predictive optimal combination analysis? (yes/no): ")
    if run_predictive.lower() == 'yes':
        window_min, window_max = determine_candidate_window(
            reference_mean_df,
            test_mean_df,
            step=5,
            initial_threshold=10
        )
        regulation_map     = {1:"FDA",2:"EMA",3:"China",4:"ASEAN",5:"ANVISA"}
        selected_regulation = regulation_map.get(input1, "FDA")
        print(f"\nCandidate window: {window_min} to {window_max}\n")

        # Always use the new “final” function for robust behavior
        results, _ = predictive_optimal_combinations_final(
            reference_mean_df,
            test_mean_df,
            selected_regulation,
            window_max,
            step_hours=0.25
        )

        # Clean up sequence types
        for cand in results:
            cand['sequence'] = [
                int(t) if float(t).is_integer() else t
                for t in cand['sequence']
            ]

        best = results[0]
        print("=== Optimal Predictive Combination ===")
        print(f"Time Points: {best['sequence']}")
        print(f"Predicted f2 Score: {best['f2']}")

        # … (your plotting & printing of best['ref_vals'] / best['test_vals']) …
