import os
import re
from fastapi import Request

# ... keep the rest of your imports and setup as-is above ...

@app.post("/chat")
def chat(req: ChatRequest, request: Request):
    q = req.message.strip()
    if not q:
        raise HTTPException(400, "Empty query")

    logger.info(f"[API] /chat query='{q}'")

    # Match 'formula', 'formulas', or 'formulae' (case-insensitive)
    if re.search(r'\bformula(?:s|e)?\b', q, flags=re.IGNORECASE):
        # Build an absolute URL for frontend to download easily
        try:
            download_url = request.url_for("download_formulas")
        except Exception:
            download_url = "/download-formulas"

        # prepare file metadata if available
        filename = None
        size_bytes = None
        try:
            if FORMULAS_EXCEL_PATH and os.path.exists(FORMULAS_EXCEL_PATH):
                filename = os.path.basename(FORMULAS_EXCEL_PATH)
                size_bytes = os.path.getsize(FORMULAS_EXCEL_PATH)
        except Exception as e:
            logger.warning(f"Error retrieving formulas file metadata: {e}")

        human_msg = "Please refer to the Excel sheet for formulas. Use the button below to download it."

        logger.info(f"[API] /chat detected 'formula' keyword; returning download URL: {download_url}")

        # Return response + explicit download fields
        return {
            "response": human_msg,
            "formula_download": download_url,
            "formula_filename": filename,
            "formula_size_bytes": size_bytes
        }

    # Normal handling otherwise
    ans = MANAGER.handle_query(q)
    return {"response": ans}


@app.get("/download-formulas", name="download_formulas")
def download_formulas():
    """
    Stream the formulas Excel file for download.
    """
    path = FORMULAS_EXCEL_PATH
    if not path or not os.path.exists(path):
        logger.error(f"[API] /download-formulas file not found at {path}")
        raise HTTPException(404, detail="Formulas file not found on server.")

    filename = os.path.basename(path)

    def file_iterator():
        with open(path, "rb") as f:
            while True:
                chunk = f.read(1024 * 64)
                if not chunk:
                    break
                yield chunk

    media_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    headers = {"Content-Disposition": f'attachment; filename="{filename}"'}
    return StreamingResponse(file_iterator(), media_type=media_type, headers=headers)
#############################
// src/components/Message.jsx
import React from 'react'
import { motion } from 'framer-motion'
import { FiVolume2, FiDownload } from 'react-icons/fi'
import { parseResponseToTable } from '../utils/parseResponseToTable'

function humanFileSize(bytes) {
  if (!bytes && bytes !== 0) return ''
  const thresh = 1024
  if (Math.abs(bytes) < thresh) return bytes + ' B'
  const units = ['KB', 'MB', 'GB', 'TB']
  let u = -1
  let b = bytes
  do {
    b /= thresh
    ++u
  } while (Math.abs(b) >= thresh && u < units.length - 1)
  return b.toFixed( (b >= 100) ? 0 : (b >= 10) ? 1 : 2 ) + ' ' + units[u]
}

export default function Message({ from, text, onReadAloud, layoutId, downloadUrl, downloadName, downloadSizeBytes }) {
  const table = parseResponseToTable(text)
  const isUser = from === 'user'

  const variants = {
    initial: { opacity: 0, scale: 0.98, y: 6 },
    enter: { opacity: 1, scale: 1, y: 0, transition: { duration: 0.28, ease: 'easeOut' } },
    exit: { opacity: 0, scale: 0.98, y: 6, transition: { duration: 0.18 } }
  }

  const bubbleClass = isUser ? 'msg-user p-4 rounded-2xl text-white' : 'msg-agent p-4 rounded-2xl bg-white glass text-gray-900'

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <motion.div
        layoutId={layoutId}
        initial="initial"
        animate="enter"
        exit="exit"
        variants={variants}
        className={`max-w-[78%] shadow-soft ${bubbleClass}`}
        style={{ overflow: 'hidden' }}
      >
        <div className="prose-sm whitespace-pre-wrap break-words">
          {!table && <div>{text}</div>}

          {table?.type === 'json' && (
            <div className="overflow-auto">
              <table className="min-w-full text-sm table-auto">
                <thead>
                  <tr className="text-left">
                    {Object.keys(table.data[0]).map(h => <th key={h} className="px-3 py-2 border-b">{h}</th>)}
                  </tr>
                </thead>
                <tbody>
                  {table.data.map((row, idx) => (
                    <tr key={idx}>
                      {Object.keys(table.data[0]).map(k => <td key={k} className="px-3 py-2 border-b align-top">{String(row[k] ?? '')}</td>)}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {table?.type === 'matrix' && (
            <div className="overflow-auto">
              <table className="min-w-full text-sm table-auto">
                <thead>
                  <tr>{table.headers.map(h => <th key={h} className="px-3 py-2 border-b">{h}</th>)}</tr>
                </thead>
                <tbody>
                  {table.rows.map((r, i) => <tr key={i}>{r.map((c,j) => <td key={j} className="px-3 py-2 border-b">{c}</td>)}</tr>)}
                </tbody>
              </table>
            </div>
          )}
        </div>

        {/* Agent controls: Read aloud + Download (when available) */}
        {!isUser && (
          <div className="mt-3 flex items-center justify-end gap-2">
            {onReadAloud && (
              <button onClick={() => onReadAloud?.(text)} className="px-3 py-1 text-xs rounded read-btn flex items-center gap-2">
                <FiVolume2 /> Read
              </button>
            )}

            {downloadUrl && (
              <a
                href={downloadUrl}
                target="_blank"
                rel="noopener noreferrer"
                download={downloadName || true}
                className="px-3 py-1 text-xs rounded bg-accent/5 border flex items-center gap-2 hover:bg-accent/10"
              >
                <FiDownload />
                <span>Download</span>
                {downloadName && <span className="text-xs text-gray-500 ml-2">({downloadName}{downloadSizeBytes ? ` · ${humanFileSize(downloadSizeBytes)}` : ''})</span>}
              </a>
            )}
          </div>
        )}
      </motion.div>
    </div>
  )
}
##############################
// src/components/ChatWidget.jsx
import React, { useEffect, useRef, useState } from 'react'
import { motion } from 'framer-motion'
import {
  FiMessageCircle,
  FiX,
  FiMic,
  FiSend,
  FiChevronDown
} from 'react-icons/fi'
import Message from './Message'
import PromptModal from './PromptModal'
import FileUploader from './FileUploader'
import OpenWebUILoader from './OpenWebUILoader'
import { chatRequest, speechToTextUpload, textToSpeechUrl } from '../api'

const TILE_QUESTIONS = {
  "Product A": ["What is the API used?", "What is the batch size?", "Who is the manufacturer?"],
  "Line B": ["What is the speed range?", "What equipment is used?", "What is the pressure limit?"],
  "Formulation Z": ["List excipients used", "Describe dissolution method"],
  "Process Y": ["Steps in granulation?", "Drying temperature?"],
  "Machine Q": ["Model number details?", "Maintenance interval?"]
}

export default function ChatWidget() {
  const [open, setOpen] = useState(false)
  const [promptOpen, setPromptOpen] = useState(false)
  const [messages, setMessages] = useState([])
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [recording, setRecording] = useState(false)
  const [suggests, setSuggests] = useState([])

  const recorderRef = useRef(null)
  const audioChunksRef = useRef([])
  const scrollRef = useRef(null)
  const loaderRef = useRef(null)
  const pendingLayoutIdRef = useRef(null)
  const typingTimeout = useRef(null)

  useEffect(() => {
    if (loading && loaderRef.current) {
      setTimeout(() => { try { loaderRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' }) } catch (e) {} }, 80)
    } else {
      setTimeout(() => { try { scrollRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' }) } catch (e) {} }, 120)
    }
  }, [messages, loading])

  function appendMsg(from, text, extra = {}) {
    setMessages(prev => [...prev, { id: crypto?.randomUUID?.() ?? Date.now(), from, text, ...extra }])
  }

  async function send(promptToSend = null) {
    const q = (promptToSend !== null) ? String(promptToSend).trim() : input.trim()
    if (!q) return

    appendMsg('user', q)
    setInput('')

    const layoutId = `pending-${Date.now()}`
    pendingLayoutIdRef.current = layoutId
    setLoading(true)

    try {
      const resp = await chatRequest(q)
      // resp may be { response: "...", formula_download: "...", formula_filename: "...", formula_size_bytes: ... }
      const agentText = resp?.response ?? 'Oops! No relevant information found.'

      if (resp?.formula_download) {
        appendMsg('agent', agentText, {
          layoutId,
          downloadUrl: resp.formula_download,
          downloadName: resp.formula_filename,
          downloadSizeBytes: resp.formula_size_bytes
        })
      } else {
        appendMsg('agent', agentText, { layoutId })
      }
    } catch (e) {
      appendMsg('agent', 'Error calling backend — ' + String(e.message ?? e), { layoutId })
    } finally {
      setTimeout(() => {
        setLoading(false)
        pendingLayoutIdRef.current = null
      }, 40)
    }
  }

  function onPromptPick(p) {
    setInput(p)
    setTimeout(() => send(p), 260)
  }

  useEffect(() => {
    clearTimeout(typingTimeout.current)
    const val = (input || '').toLowerCase()
    typingTimeout.current = setTimeout(() => {
      const list = []
      if (val.includes('capacity') || val.includes('capacities')) {
        list.push({
          title: 'Capacities table',
          prompt: 'Provide a table with columns: Line | Max Capacity (kg/h) | Typical Batch Size (kg). Return only a markdown table.'
        })
      }
      if (val.includes('dissolution')) {
        list.push({
          title: 'Dissolution conditions table',
          prompt: 'Provide a table with columns: Method | Medium | RPM | Temperature. Return only a markdown table.'
        })
      }
      setSuggests(list)
    }, 220)
    return () => clearTimeout(typingTimeout.current)
  }, [input])

  function onSuggestionClick(item) {
    setInput(item.prompt)
    setTimeout(() => send(item.prompt), 200)
  }

  // STT logic unchanged (convert to WAV etc.)
  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const mr = new MediaRecorder(stream)
      recorderRef.current = mr
      audioChunksRef.current = []
      mr.ondataavailable = (e) => audioChunksRef.current.push(e.data)
      mr.onstop = async () => {
        try {
          const blob = new Blob(audioChunksRef.current, { type: audioChunksRef.current[0]?.type || 'audio/webm' })
          const wavBlob = await convertBlobToWav(blob)
          const r = await speechToTextUpload(wavBlob)
          const text = r?.text ?? ''
          if (text) setInput(text)
        } catch (err) {
          appendMsg('agent', 'STT Error: ' + String(err.message ?? err))
        }
      }
      mr.start()
      setRecording(true)
    } catch (e) {
      appendMsg('agent', 'Mic access denied: ' + (e.message || e))
    }
  }

  function stopRecording() { const mr = recorderRef.current; if (mr && mr.state !== 'inactive') mr.stop(); setRecording(false) }

  async function convertBlobToWav(blob) {
    const arrayBuffer = await blob.arrayBuffer()
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer)
    const numChannels = audioBuffer.numberOfChannels
    const sampleRate = audioBuffer.sampleRate
    let interleaved
    if (numChannels === 1) interleaved = audioBuffer.getChannelData(0)
    else {
      const ch = []
      for (let i = 0; i < numChannels; i++) ch.push(audioBuffer.getChannelData(i))
      const len = ch[0].length
      interleaved = new Float32Array(len * numChannels)
      let idx = 0
      for (let i = 0; i < len; i++) for (let c = 0; c < numChannels; c++) interleaved[idx++] = ch[c][i]
    }
    const wavView = encodeWAV(interleaved, numChannels, sampleRate)
    return new Blob([wavView], { type: 'audio/wav' })
  }

  function encodeWAV(samples, numChannels, sampleRate) {
    const bytesPerSample = 2
    const blockAlign = numChannels * bytesPerSample
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)
    const view = new DataView(buffer)
    function writeString(v, o, s) { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)) }
    function floatTo16BitPCM(output, offset, input) {
      for (let i = 0; i < input.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, input[i])); s = s < 0 ? s * 0x8000 : s * 0x7FFF; output.setInt16(offset, s, true)
      }
    }
    writeString(view, 0, 'RIFF')
    view.setUint32(4, 36 + samples.length * bytesPerSample, true)
    writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true)
    view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * blockAlign, true)
    view.setUint16(32, blockAlign, true); view.setUint16(34, 16, true); writeString(view, 36, 'data')
    view.setUint32(40, samples.length * bytesPerSample, true); floatTo16BitPCM(view, 44, samples); return view
  }

  function readAloud(text) { const url = textToSpeechUrl(text); const audio = new Audio(url); audio.play() }

  function onFileUploaded(data) { if (data?.filename) appendMsg('agent', `Uploaded: ${data.filename} — indexed and available for querying.`) else appendMsg('agent', `Upload result: ${JSON.stringify(data)}`) }

  // render messages and insert loader as before
  const lastUserIndex = (() => { for (let i = messages.length - 1; i >= 0; i--) if (messages[i].from === 'user') return i; return -1 })()
  const renderedMessages = []
  messages.forEach((m, idx) => {
    renderedMessages.push(
      <Message key={m.id}
               from={m.from}
               text={m.text}
               onReadAloud={readAloud}
               layoutId={m.layoutId}
               downloadUrl={m.downloadUrl}
               downloadName={m.downloadName}
               downloadSizeBytes={m.downloadSizeBytes}
      />
    )

    if (loading && idx === lastUserIndex) {
      const layoutId = pendingLayoutIdRef.current
      renderedMessages.push(
        <div key="__loader__" ref={loaderRef} className="pt-2 pb-4">
          <OpenWebUILoader lines={4} compact={false} variant="dark" layoutId={layoutId} />
          <div className="text-xs text-gray-400 text-center mt-2">Generating response...</div>
        </div>
      )
    }
  })

  if (loading && messages.length === 0) {
    const layoutId = pendingLayoutIdRef.current
    renderedMessages.unshift(
      <div key="__loader-first__" ref={loaderRef} className="pt-2 pb-4">
        <OpenWebUILoader lines={4} compact={false} variant="dark" layoutId={layoutId} />
        <div className="text-xs text-gray-400 text-center mt-2">Generating response...</div>
      </div>
    )
  }

  return (
    <>
      <div className="fixed bottom-6 right-6 z-50">
        <motion.button whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.96 }} onClick={() => setOpen(true)}
          className="w-16 h-16 rounded-full shadow-glow bg-gradient-to-br from-primary to-indigo-500 flex items-center justify-center text-white text-2xl">
          <FiMessageCircle />
        </motion.button>
      </div>

      {open && (
        <div className="fixed inset-0 z-60 flex items-center justify-center p-4">
          <div onClick={() => setOpen(false)} className="absolute inset-0 bg-black/40 backdrop-blur-sm" />

          <motion.div initial={{ opacity: 0, scale: 0.98 }} animate={{ opacity: 1, scale: 1 }}
            className="relative chat-modal bg-white rounded-2xl shadow-2xl overflow-hidden" style={{ height: 'min(760px,86vh)', width: 'min(1100px,94vw)' }} role="dialog" aria-modal="true">

            <div className="flex items-center justify-between px-6 py-4 border-b">
              <div className="flex items-center gap-3">
                <div className="w-11 h-11 rounded-lg bg-gradient-to-br from-primary to-indigo-400 flex items-center justify-center text-white font-bold">SP</div>
                <div>
                  <div className="font-semibold text-lg">Scaleup Predictor</div>
                  <div className="text-xs text-gray-500">Ask your documents & dataset</div>
                </div>
              </div>

              <div className="flex items-center gap-3">
                <button onClick={() => setPromptOpen(true)} className="px-3 py-2 rounded bg-white border flex items-center gap-2">
                  <FiChevronDown /> Prompts
                </button>

                <FileUploader onUploaded={onFileUploaded} />

                <button onClick={() => setOpen(false)} className="p-2 rounded hover:bg-gray-100" aria-label="Close chat">
                  <FiX />
                </button>
              </div>
            </div>

            <div className="flex flex-col h-full">
              <div className="flex-1 p-6 pb-6 overflow-auto scrollbar-thin relative">
                <div className="flex flex-col gap-4">
                  {renderedMessages.length === 0 && !loading && (
                    <div className="text-center text-gray-400">Welcome — ask anything related to your dataset or uploaded documents.</div>
                  )}

                  {renderedMessages}

                  <div ref={scrollRef} />
                </div>
              </div>

              <div className="px-6 py-4 border-t bg-white relative -translate-y-0">
                <div className="flex items-start gap-3">
                  <textarea value={input} onChange={(e) => setInput(e.target.value)} placeholder="Type your question (Enter to send; Shift+Enter newline)" className="flex-1 resize-none p-3 rounded-xl border focus:outline-none" rows={2}
                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send() } }} aria-label="Message input" />

                  <div className="flex flex-col gap-2">
                    <button title={recording ? 'Stop recording' : 'Record (speech-to-text)'} onClick={() => { recording ? stopRecording() : startRecording() }} className={`p-3 rounded-lg border ${recording ? 'bg-red-50' : 'bg-white'}`} aria-pressed={recording}><FiMic /></button>

                    <button onClick={() => send()} className="px-4 py-2 rounded-lg bg-primary text-white flex items-center gap-2" aria-label="Send message"><FiSend /> Send</button>
                  </div>
                </div>

                <div className="mt-3">
                  {suggests.length > 0 && (
                    <div className="flex gap-3">
                      {suggests.map((s, i) => (
                        <motion.div key={i} whileHover={{ y: -6 }} className="p-3 rounded-lg bg-gray-50 border">
                          <div className="text-xs font-medium">{s.title}</div>
                          <div className="text-xs text-gray-500 mt-1 max-w-xs">{s.prompt}</div>
                          <div className="mt-2"><button onClick={() => onSuggestionClick(s)} className="px-2 py-1 text-xs rounded bg-primary text-white">Use</button></div>
                        </motion.div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      )}

      <PromptModal open={promptOpen} onClose={() => setPromptOpen(false)} tiles={TILE_QUESTIONS} onPick={onPromptPick} />
    </>
  )
}
