import numpy as np
import math

def predictive_optimal_combinations_by_percent(reference_mean_df, test_mean_df,
                                               regulation, window_max,
                                               step_hours=0.25):
    """
    Picks based on explicit dissolution-percentage targets:
    - Always includes t=0 (0%).
    - Targets at 10,20,40,50,70,80% for well-separated points.
    - FDA/ANVISA extra: time when both curves hit 85% (max of their individual 85%‐crossing times).
    - EMA/China/ASEAN extra: time when either curve hits 85% (min of their 85%‐crossing times).
    - Computes f2 excluding the 0-h point.
    """
    # 1) Extract and ensure 0% point
    t_ref  = reference_mean_df.iloc[:,0].astype(float).values
    d_ref  = reference_mean_df.iloc[:,1].astype(float).values
    t_test= test_mean_df.iloc[:,0].astype(float).values
    d_test= test_mean_df.iloc[:,1].astype(float).values
    if t_ref[0] != 0.0:
        t_ref  = np.insert(t_ref,  0, 0.0); d_ref  = np.insert(d_ref,  0, 0.0)
        t_test = np.insert(t_test, 0, 0.0); d_test = np.insert(d_test, 0, 0.0)

    # 2) Build fine grid
    grid      = np.arange(0.0, window_max + 1e-8, step_hours)
    ref_pred   = np.interp(grid, t_ref,  d_ref)
    test_pred  = np.interp(grid, t_test, d_test)

    # 3) Initialize sequence
    seq = [0.0]

    # 4) Dissolution‐target times
    for pct in [10, 20, 40, 50, 70, 80]:
        # invert interpolation on ref curve
        if pct <= ref_pred[-1]:
            t_pt = float(np.interp(pct, ref_pred, grid))
        else:
            t_pt = float(grid[-1])
        seq.append(t_pt)

    # 5) Regulatory extra at 85%
    # find when each curve hits 85%
    t_ref85  = float(np.interp(85, ref_pred,  grid))
    t_test85 = float(np.interp(85, test_pred, grid))
    if regulation in ("FDA","ANVISA"):
        extra = max(t_ref85, t_test85)
    else:
        extra = min(t_ref85, t_test85)
    # ensure within window
    extra = min(extra, float(window_max))
    seq.append(extra)

    # 6) Deduplicate and sort
    seq = sorted(set(seq))

    # 7) Compute f2 (exclude 0)
    ref_vals  = [float(np.interp(t, grid, ref_pred))  for t in seq]
    test_vals = [float(np.interp(t, grid, test_pred)) for t in seq]
    ref_vals[0]  = 0.0
    test_vals[0] = 0.0
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    mse   = np.mean(diffs**2)
    f2    = 50 * math.log10(100 / (1 + math.sqrt(mse)))

    return [{
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals,
        'test_vals': test_vals
    }], None

# === Updated wrapper ===
# Replace the try/except fallback with this percent-based function

try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced
")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent-targeted predictive function...
")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

# Normalize int/float
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]

# proceed to plotting/printing as before
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals,
        'test_vals': test_vals
    }], None

# === Updated wrapper in your if input1==1 block ===
# After window_min, window_max determination:
try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced
")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent‐targeted predictive function...
")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

# Normalize int/float
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]

# Then proceed to plot and print `results` as before
 ===

# ... inside `if input1 == 1:` after computing window_min/window_max ...
try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced\n")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent-targeted predictive function...\n")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

# Normalize int/float
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]

# Then proceed to plot and print `results` as before
