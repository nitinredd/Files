import streamlit as st
import cv2
import numpy as np
from skimage.feature import graycomatrix, graycoprops
from skimage.segmentation import watershed
from scipy import ndimage
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import os
import tempfile
import io
from google.auth import default
from langchain_google_vertexai import VertexAI
import google.api_core.exceptions
from PIL import Image, ImageDraw, ImageFont

# Configuration for VertexAI
class Config:
    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "C:/Users/Downloads/filename-254609-genai.json"  # Path to your API file
    credentials, project_id = default()
    llm = VertexAI(model_name="gemini-pro", temperature=0.3)

config = Config()

def preprocess_image(image):
    # Apply noise reduction
    denoised = cv2.fastNlMeansDenoising(image, None, 10, 7, 21)
    
    # Enhance contrast
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    enhanced = clahe.apply(denoised)
    
    # Apply adaptive thresholding
    thresh = cv2.adaptiveThreshold(enhanced, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                   cv2.THRESH_BINARY, 11, 2)
    return thresh

def detect_tablets(image):
    edges = cv2.Canny(image, 50, 150)
    edge_profile = np.sum(edges, axis=0)
    peaks, _ = find_peaks(edge_profile, distance=50)
    return peaks

def analyze_texture(image):
    glcm = graycomatrix(image, [1], [0], 256, symmetric=True, normed=True)
    contrast = graycoprops(glcm, 'contrast')[0, 0]
    homogeneity = graycoprops(glcm, 'homogeneity')[0, 0]
    return contrast, homogeneity

def watershed_segmentation(image):
    distance = ndimage.distance_transform_edt(image)
    local_max = ndimage.maximum_filter(distance, size=20) == distance
    markers = ndimage.label(local_max)[0]
    labels = watershed(-distance, markers, mask=image)
    return labels

def analyze_tablet_porosity(image, n_clusters=3):
    processed_img = preprocess_image(image)
    tablet_boundaries = detect_tablets(processed_img)
    
    results = []
    
    for i in range(len(tablet_boundaries) - 1):
        start, end = tablet_boundaries[i], tablet_boundaries[i+1]
        tablet = processed_img[:, start:end]
        
        # Texture analysis
        contrast, homogeneity = analyze_texture(tablet)
        
        # Watershed segmentation
        segmented = watershed_segmentation(tablet)
        
        # K-means clustering
        tablet_normalized = tablet.astype(float) / 255.0
        pixel_values = tablet_normalized.reshape((-1, 1))
        
        optimal_n_clusters = min(n_clusters, len(np.unique(pixel_values)))
        
        kmeans = KMeans(n_clusters=optimal_n_clusters, random_state=42)
        kmeans.fit(pixel_values)
        
        centers = kmeans.cluster_centers_.flatten()
        sorted_centers = np.sort(centers)
        
        labels = ['Porous', 'Intermediate', 'Dense'][:optimal_n_clusters]
        cluster_map = {i: label for i, label in enumerate(labels)}
        
        unique, counts = np.unique(kmeans.labels_, return_counts=True)
        percentages = dict(zip([cluster_map[i] for i in unique], counts / len(kmeans.labels_) * 100))
        
        results.append({
            'tablet_index': i,
            'percentages': percentages,
            'contrast': contrast,
            'homogeneity': homogeneity,
            'start': int(start),
            'end': int(end)
        })
    
    return results

def analyze_zones(image):
    height, width = image.shape
    zone_width = width // 3
    
    zones = {
        'Dry Zone': image[:, :zone_width],
        'Wet Zone': image[:, zone_width:2*zone_width],
        'Optimum Zone': image[:, 2*zone_width:]
    }
    
    zone_results = {}
    
    for zone_name, zone_image in zones.items():
        zone_results[zone_name] = analyze_tablet_porosity(zone_image)
    
    return zone_results

def analyze_tablet_data_with_gemini(zone_results):
    summary = []
    for zone_name, tablets in zone_results.items():
        summary.append(f"{zone_name}:")
        for i, tablet in enumerate(tablets):
            summary.append(f"  Tablet {i+1}:")
            for category, percentage in tablet['percentages'].items():
                summary.append(f"    {category}: {percentage:.2f}%")
            summary.append(f"    Contrast: {tablet['contrast']:.2f}")
            summary.append(f"    Homogeneity: {tablet['homogeneity']:.2f}")
    
    summary_text = "\n".join(summary)
    
    prompt = f"""
    Analyze the following quantitative data for tablet porosity across different zones:

    {summary_text}

    Provide a scientific analysis of:
    1. Overall porosity trends in each zone
    2. Density variations between tablets within zones
    3. Comparison of texture features (contrast and homogeneity) across zones
    4. Potential implications for tablet quality in each zone
    5. Recommendations for process improvements or further analysis

    Format your response as a detailed text analysis, focusing on the most significant observations and their implications.
    """
    
    try:
        response = config.llm.predict(prompt)
        return response
    except Exception as e:
        st.error(f"An error occurred during Gemini analysis: {str(e)}")
        return None

def create_annotated_image(original_image, zone_results, gemini_analysis):
    # Convert grayscale to RGB if necessary
    if len(original_image.shape) == 2:
        original_image = cv2.cvtColor(original_image, cv2.COLOR_GRAY2RGB)
    
    # Create a PIL Image from the numpy array
    pil_image = Image.fromarray(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
    draw = ImageDraw.Draw(pil_image)
    
    # Use a default font
    font = ImageFont.load_default()
    
    # Draw zone boundaries
    height, width = original_image.shape[:2]
    zone_width = width // 3
    for i in range(1, 3):
        x = i * zone_width
        draw.line([(x, 0), (x, height)], fill="red", width=2)
    
    # Add zone labels
    zone_labels = ["Dry Zone", "Wet Zone", "Optimum Zone"]
    for i, label in enumerate(zone_labels):
        x = i * zone_width + zone_width // 2
        draw.text((x, 10), label, fill="red", font=font, anchor="mt")
    
    # Draw tablet boundaries and porosity percentages for each zone
    for zone_name, tablets in zone_results.items():
        zone_index = zone_labels.index(zone_name)
        zone_start = zone_index * zone_width
        
        for tablet in tablets:
            start, end = zone_start + tablet['start'], zone_start + tablet['end']
            draw.line([(start, 0), (start, height)], fill="blue", width=1)
            draw.line([(end, 0), (end, height)], fill="blue", width=1)
            
            y_pos = 40
            for category, percentage in tablet['percentages'].items():
                text = f"{category}: {percentage:.2f}%"
                draw.text((start + 5, y_pos), text, fill="blue", font=font)
                y_pos += 20
            
            draw.text((start + 5, y_pos), f"Contrast: {tablet['contrast']:.2f}", fill="blue", font=font)
            y_pos += 20
            draw.text((start + 5, y_pos), f"Homogeneity: {tablet['homogeneity']:.2f}", fill="blue", font=font)
    
    # Add Gemini analysis to the bottom of the image
    if gemini_analysis:
        # Calculate text size and position
        text_width, text_height = draw.multiline_textsize(gemini_analysis, font=font)
        text_position = (10, height - text_height - 10)
        
        # Add a semi-transparent background for text readability
        draw.rectangle([text_position, (width, height)], fill=(255, 255, 255, 128))
        
        # Draw the text
        draw.multiline_text(text_position, gemini_analysis, fill="black", font=font)
    
    return pil_image

def main():
    st.title("Advanced Tablet Porosity Analysis App")

    uploaded_file = st.file_uploader("Choose an image file", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        try:
            file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
            image = cv2.imdecode(file_bytes, cv2.IMREAD_GRAYSCALE)

            st.image(image, caption="Uploaded Image", use_column_width=True)

            if st.button("Analyze Image"):
                with st.spinner("Performing advanced computer vision analysis..."):
                    zone_results = analyze_zones(image)
                
                st.success("Computer vision analysis complete!")
                st.session_state.zone_results = zone_results
                st.session_state.original_image = image

                # Display a summary of the CV results
                for zone_name, tablets in zone_results.items():
                    st.subheader(zone_name)
                    for i, tablet in enumerate(tablets):
                        st.write(f"Tablet {i+1}")
                        st.write("Porosity Percentages:")
                        for category, percentage in tablet['percentages'].items():
                            st.write(f"  {category}: {percentage:.2f}%")
                        st.write(f"Contrast: {tablet['contrast']:.2f}")
                        st.write(f"Homogeneity: {tablet['homogeneity']:.2f}")

                if st.button("Analyze with Gemini"):
                    with st.spinner("Processing with Gemini..."):
                        gemini_analysis = analyze_tablet_data_with_gemini(zone_results)
                    if gemini_analysis:
                        st.subheader("Gemini Analysis")
                        st.write(gemini_analysis)

                        # Create annotated image
                        annotated_image = create_annotated_image(st.session_state.original_image, zone_results, gemini_analysis)
                        
                        # Display the annotated image
                        st.image(annotated_image, caption="Annotated Analysis", use_column_width=True)
                        
                        # Provide download link for the annotated image
                        buffered = io.BytesIO()
                        annotated_image.save(buffered, format="JPEG")
                        st.download_button(
                            label="Download Annotated Image",
                            data=buffered.getvalue(),
                            file_name="annotated_tablet_analysis.jpg",
                            mime="image/jpeg"
                        )
                    else:
                        st.warning("Gemini analysis failed. Please check the error message above.")

        except Exception as e:
            st.error(f"An error occurred during analysis: {str(e)}")

if __name__ == "__main__":
    main()
