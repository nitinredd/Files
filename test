import fitz
import pytesseract
from PIL import Image
import numpy as np
import cv2
from openpyxl import Workbook
import os
import logging
from pathlib import Path
from tqdm import tqdm


class PDFTableToExcelConverter:
    def __init__(self, input_path, output_path, dpi=300):
        self.input_path = input_path
        self.output_path = output_path
        self.dpi = dpi
        self.wb = Workbook()
        self.ws = self.wb.active
        self.ws.title = "Extracted Tables"
        self.setup_logging()

    def setup_logging(self):
        """Setup logging configuration."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('conversion.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def detect_tables(self, image):
        """Detect table boundaries in an image."""
        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                       cv2.THRESH_BINARY_INV, 11, 2)

        # Detect horizontal and vertical lines
        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40, 1))
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 40))
        horizontal_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel)
        vertical_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel)

        # Combine horizontal and vertical lines to detect tables
        table_mask = cv2.addWeighted(horizontal_lines, 1, vertical_lines, 1, 0)
        contours, _ = cv2.findContours(table_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        tables = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            if w > 50 and h > 50:  # Minimum size to qualify as a table
                tables.append((y, y + h, x, x + w))
        return sorted(tables)

    def extract_table(self, image, table_coords):
        """Extract text data from the table region."""
        y1, y2, x1, x2 = table_coords
        table_image = image[y1:y2, x1:x2]

        # Detect horizontal and vertical lines within the table
        gray = cv2.cvtColor(table_image, cv2.COLOR_RGB2GRAY)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                       cv2.THRESH_BINARY_INV, 11, 2)

        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40, 1))
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 40))
        horizontal_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel)
        vertical_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel)

        # Detect lines
        horizontal_lines = cv2.HoughLinesP(horizontal_lines, 1, np.pi / 180, 100,
                                           minLineLength=50, maxLineGap=10)
        vertical_lines = cv2.HoughLinesP(vertical_lines, 1, np.pi / 180, 100,
                                         minLineLength=50, maxLineGap=10)

        if not horizontal_lines or not vertical_lines:
            return []

        # Get row and column positions
        row_positions = sorted({y1 for line in horizontal_lines for _, y1, _, y2 in line})
        col_positions = sorted({x1 for line in vertical_lines for x1, _, x2, _ in line})

        # Extract cells
        table_data = []
        for i in range(len(row_positions) - 1):
            row = []
            for j in range(len(col_positions) - 1):
                cell_image = table_image[row_positions[i]:row_positions[i + 1],
                                         col_positions[j]:col_positions[j + 1]]
                cell_text = pytesseract.image_to_string(cell_image, lang='eng', config='--psm 6')
                row.append(cell_text.strip())
            table_data.append(row)
        return table_data

    def write_table_to_excel(self, table_data):
        """Write extracted table data to Excel sheet."""
        for row_data in table_data:
            self.ws.append(row_data)
        self.ws.append([])  # Add an empty row after each table

    def convert(self):
        """Main conversion process."""
        try:
            pdf_document = fitz.open(self.input_path)
            total_pages = pdf_document.page_count

            with tqdm(total=total_pages, desc="Processing PDF") as pbar:
                for page_num in range(total_pages):
                    try:
                        page = pdf_document[page_num]
                        pix = page.get_pixmap(matrix=fitz.Matrix(self.dpi / 72, self.dpi / 72))
                        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                        img_np = np.array(img)

                        tables = self.detect_tables(img_np)
                        for table_coords in tables:
                            table_data = self.extract_table(img_np, table_coords)
                            if table_data:
                                self.write_table_to_excel(table_data)

                        pbar.update(1)
                    except Exception as e:
                        self.logger.error(f"Error processing page {page_num + 1}: {str(e)}")
                        continue

            # Save Excel file
            output_dir = os.path.dirname(self.output_path)
            if output_dir:
                os.makedirs(output_dir, exist_ok=True)

            self.wb.save(self.output_path)
            self.logger.info(f"Excel file successfully saved as {self.output_path}")

        except Exception as e:
            self.logger.error(f"Conversion error: {str(e)}")
        finally:
            if 'pdf_document' in locals():
                pdf_document.close()


def main():
    print("PDF Table to Excel Converter")
    print("-" * 30)

    input_path = input("Enter the input PDF path: ")
    output_path = str(Path(input_path).with_suffix('.xlsx'))

    try:
        dpi = int(input("Enter DPI (300-600, press Enter for default 300): ") or 300)
        dpi = max(300, min(600, dpi))
    except ValueError:
        dpi = 300

    converter = PDFTableToExcelConverter(input_path, output_path, dpi)
    converter.convert()


if __name__ == "__main__":
    main()
