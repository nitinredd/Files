## File 1: `app.py`

### Change 1.1: Add None check for main_results
**Location:** After line 396 (after `main_results = main_function(...)`)
**Insert at:** Line 398-402

```python
# FIND THIS LINE:
main_results = main_function(market, test_prepared, ref_prepared)

# ADD THESE LINES IMMEDIATELY AFTER:
# Check if main_results is None (error occurred in main_function)
if main_results is None:
    st.error("‚ùå An error occurred during analysis. Please check your data and try again.")
    st.info("üí° Common issues: invalid data format, missing values, or incompatible time points.")
    return

# THEN CONTINUES WITH:
# Unpack results based on return values
if len(main_results) == 8:
```

---

### Change 1.2: Add validation after unpacking
**Location:** After line 406 (after unpacking the tuple)
**Insert at:** Line 408-412

```python
# FIND THIS SECTION:
if len(main_results) == 8:
    conv_f2, fig1, fig2, seq_print, recom_f2, plotly_fig, cv_checks, ai_df = main_results

# ADD THESE LINES IMMEDIATELY AFTER THE UNPACKING:
    # Check if the first element is None (indicating an error occurred)
    if conv_f2 is None:
        st.error("‚ùå An error occurred during analysis. Please check your data and try again.")
        st.info("üí° Common issues: invalid data format, missing values, or incompatible time points.")
        return

# THEN CONTINUES WITH:
else:
    st.error("Unexpected number of return values from main_function")
    return
```

---

## File 2: `Similarity_analyzer_final_version.py`

### Change 2.1: Fix .lower() method on integer column name
**Location:** Line 237 in `min15__check` function
**Action:** Replace lines 237-239

```python
# BEFORE (Lines 237-239):
if "min" in time_string.lower() or "minutes" in time_string.lower():
    condition = df.iloc[:, 0] <= 15

# AFTER (Lines 237-240):
# Convert to string if it's not already (handles integer column names)
time_string_str = str(time_string).lower()
if "min" in time_string_str or "minutes" in time_string_str:
    condition = df.iloc[:, 0] <= 15
```

---

### Change 2.2: Fix exception handler return value
**Location:** Line 3982-3983 (end of main_function)
**Action:** Replace lines 3982-3983

```python
# BEFORE (Lines 3982-3983):
except Exception as e:
    print(e,"ERROR")

# AFTER (Lines 3982-3985):
except Exception as e:
    print(e,"ERROR")
    # Return None values for all expected return values when an error occurs
    return None, None, None, None, None, None, None, None
```

---

### Change 2.3: Add comprehensive exception handling for optimal prediction
**Location:** 5 instances - search for this pattern
**Pattern to find:**
```python
try:
    window_min, window_max = determine_candidate_window(
        reference_mean_df, test_mean_df, step=5, initial_threshold=10
    )
    # first, original
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation         = input1,
        window_min         = window_min,
        window_max         = window_max,
        diff_threshold     = None,
        interp_method      = 'linear',
        points_per_stratum = None
    )
    print("‚úÖ Used original integer‚Äêgrid function\n")
except ValueError:
    results, _ = optimal_timepoints(
        reference_mean_df, test_mean_df,
        input1, window_max=12,
        step_hours=0.25
    )
```

**Action:** Replace the entire try-except block with:

```python
try:
    window_min, window_max = determine_candidate_window(
        reference_mean_df, test_mean_df, step=5, initial_threshold=10
    )
    # first, original
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation         = input1,
        window_min         = window_min,
        window_max         = window_max,
        diff_threshold     = None,
        interp_method      = 'linear',
        points_per_stratum = None
    )
    print("‚úÖ Used original integer‚Äêgrid function\n")
except ValueError:
    try:
        results, _ = optimal_timepoints(
            reference_mean_df, test_mean_df,
            input1, window_max=12,
            step_hours=0.25
        )
    except Exception as e:
        print(f"‚ö†Ô∏è Optimal prediction failed: {e}")
        print("Falling back to conventional f2")
        results = []
except Exception as e:
    print(f"‚ö†Ô∏è Optimal prediction failed: {e}")
    print("Falling back to conventional f2")
    results = []
```

**Approximate Line Numbers (search for the pattern):**
- Instance 1: ~Line 2380 (US FDA, cross_85 = False)
- Instance 2: ~Line 2750 (EMA/ICH/Canada/Australia, cross_85 = False)
- Instance 3: ~Line 3100 (CHINA)
- Instance 4: ~Line 3460 (ASEAN)
- Instance 5: ~Line 3830 (ANVISA)

---

### Change 2.4: Add empty results check - Pattern A
**Pattern to find:**
```python
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else round(t, 2)
        for t in cand['sequence']
    ]

best = results[0]
print("=== Optimal Predictive Combination ===")

if best['f2'] < f2_conv:
```

**Action:** Replace with:

```python
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else round(t, 2)
        for t in cand['sequence']
    ]

# Check if results is not empty before accessing
if not results or len(results) == 0:
    print("No optimal combinations found. Using conventional f2.")
    best = None
else:
    best = results[0]

print("=== Optimal Predictive Combination ===")

if best is None or best['f2'] < f2_conv:
```

**Approximate Line Numbers (search for the pattern):**
- Instance 1: ~Line 2404 (US FDA)
- Instance 2: ~Line 2774 (EMA)
- Instance 3: ~Line 3868 (ANVISA)

---

### Change 2.5: Add empty results check - Pattern B
**Pattern to find:**
```python
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else round(t, 2)
        for t in cand['sequence']
    ]

best = results[0]
print("=== Optimal Predictive Combination ===")
print(f"Time Points: {best['sequence']}")
print(f"Predicted f2 Score: {best['f2']}")

if best['f2'] < f2_conv:
```

**Action:** Replace with:

```python
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else round(t, 2)
        for t in cand['sequence']
    ]

# Check if results is not empty before accessing
if not results or len(results) == 0:
    print("No optimal combinations found. Using conventional f2.")
    best = None
else:
    best = results[0]

print("=== Optimal Predictive Combination ===")

if best is not None:
    print(f"Time Points: {best['sequence']}")
    print(f"Predicted f2 Score: {best['f2']}")

if best is None or best['f2'] < f2_conv:
