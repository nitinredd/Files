import streamlit as st
import pandas as pd
import json
import vertexai
import google.auth
import os
import tempfile
import warnings

import utils.optimization, utils.domain, utils.lhs, utils.hplcread, utils.flowrate
from vertexai.preview.generative_models import GenerativeModel, HarmCategory, HarmBlockThreshold, SafetySetting

# ---------------------------------------
# Vertex AI / Gemini Configuration
# ---------------------------------------
def configure_gemini():
    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"  # adjust as needed
    credentials, project_id = google.auth.default()
    safety_config = [SafetySetting(category=hc, threshold=HarmBlockThreshold.BLOCK_NONE) for hc in HarmCategory]
    return {
        "flash_thinking": GenerativeModel("gemini-2.0-flash-thinking-exp-01-21"),
        "pro_model": GenerativeModel("gemini-2.0-pro-exp-02-05"),
        "safety": safety_config
    }

gemini_config = configure_gemini()

# ---------------------------------------
# Predefined Prompt Templates
# ---------------------------------------
PROMPT_TEMPLATES = {
    "3-Pump Basic": """Reaction Scheme: KSM+R1+R2 -> P
Calculate flow rates using:
- Reaction time = ResidencetimeT1 * Reactor Volume (from Reactor Details, first row, 4th column)
- Flow rate of Pump 1: use primary reactant (from Pump Details, first reagent)
- Flow rate of Pump 2: use reagent 1 (from Pump Details, second reagent)
- Flow rate of Pump 3: use reagent 2 (from Pump Details, third reagent)

Return the result as a JSON array of objects, each corresponding to one row of the LHS data.  
Each object should include all columns from the LHS sheet plus the computed 'Reaction time', 'Flow rate of Pump 1', 'Flow rate of Pump 2', and 'Flow rate of Pump 3'.""",
    
    "4-Pump Advanced": """Reaction Scheme: KSM+R1->I1+R2->I2+QD->P  
Calculate flow rates using:
- Reaction time = (ResidenceTimeT1 + ResidenceTimeT2) * Reactor Volume
- Pump flows for Pumps 1-4 calculated with the established formulas for 4-pump systems.

Return the result as a JSON array of objects (with additional columns for pump flows and reaction time).""",
    
    "Custom Setup": """Create a custom flow rate calculation where:
- Reaction time depends on both ResidencetimeT1 and CatalystLoading.
- Flow rates are computed to maintain stoichiometric ratios (using provided equivalences).
- Include a safety margin of 15% on all flows.
- Handle unit conversions between ml/min and L/hour.

Return the final results as a JSON array of objects, one for each LHS row, including the computed 'Reaction time' and flow rates for each pump."""
}

# ---------------------------------------
# Autonomous Reasoning for Flowrate Calculation
# ---------------------------------------
def calculate_flowrates_with_agent(query, use_deepthink, dfs):
    """
    Given the user's natural language query (or formula) and the uploaded Excel data
    (converted to JSON), this function asks the Gemini agent to calculate the flow rates.
    The agent is instructed to return a JSON array (one object per row in the LHS DataFrame)
    containing all original LHS columns plus the computed values.
    """
    model = gemini_config["flash_thinking"] if use_deepthink else gemini_config["pro_model"]
    
    # Convert the relevant DataFrames to JSON strings.
    pump_json = dfs["pump"].to_json(orient="records")
    reactor_json = dfs["reactor"].to_json(orient="records")
    lhs_json = dfs["lhs"].to_json(orient="records")
    
    prompt = f"""
You are an expert chemical engineer. 
You are given the following data as JSON strings:
Pump Details: {pump_json}
Reactor Details: {reactor_json}
LHS Data: {lhs_json}

The reaction scheme and calculation requirements are described as follows:
{query}

Using the formulas:
- Reaction time = ResidencetimeT1 multiplied by the Reactor Volume from Reactor Details (use first row, 4th column).
- For pump flow rates, follow the established formulas for the selected reaction scheme (e.g., for 3-pump scheme: 
   Flow rate of Pump 1, Pump 2, and Pump 3 calculated based on molar ratios and equivalences).

Return only a JSON array of objects, where each object corresponds to one row of the LHS data,
and includes all original LHS fields plus the computed fields: 'Reaction time', 'Flow rate of Pump 1', 
'Flow rate of Pump 2', and 'Flow rate of Pump 3'. Do not include any explanation.
"""
    response = model.generate_content(contents=prompt, safety_settings=gemini_config["safety"])
    return response.text

def parse_flowrates(response_text):
    try:
        # Attempt to parse the agent's response as JSON.
        result_list = json.loads(response_text)
        return pd.DataFrame(result_list)
    except Exception as e:
        st.error(f"Error parsing JSON output from Gemini: {str(e)}")
        return None

# ---------------------------------------
# Main App: Single Page Autonomous UI
# ---------------------------------------
def main():
    st.set_page_config(page_title="Autonomous Flowrate & Optimization", layout="wide")
    st.title("Autonomous Flowrate & Optimization via Gemini")
    
    # Initialize session state variables
    if "query_input" not in st.session_state:
        st.session_state.query_input = ""
    if "dfs" not in st.session_state:
        st.session_state.dfs = {}
    if "inputs" not in st.session_state:
        st.session_state.inputs = {}

    # --- Chat Input (Query) ---
    st.markdown("### Your Query:")
    st.session_state.query_input = st.text_area("Enter your reaction scheme or calculation requirements here...", 
                                                 value=st.session_state.query_input, height=100)
    
    col1, col2, col3 = st.columns([1, 1, 1])
    with col1:
        uploaded_file = st.file_uploader("ðŸ“¤ Upload Excel File", type=["xlsx"], key="excel_upload")
    with col2:
        deepthink = st.checkbox("Deepthink", value=False)
    with col3:
        send_button = st.button("Send")
    
    # --- Prompt Template Buttons ---
    st.markdown("#### Prompt Templates")
    temp_cols = st.columns(len(PROMPT_TEMPLATES))
    for idx, (title, text) in enumerate(PROMPT_TEMPLATES.items()):
        if temp_cols[idx].button(title):
            st.session_state.query_input = text
    
    # --- Process Excel File Upload and Show Data/Inputs ---
    if uploaded_file:
        try:
            st.session_state.dfs = {
                "lhs": pd.read_excel(uploaded_file, sheet_name="LHS"),
                "objectives": pd.read_excel(uploaded_file, sheet_name="Objectives"),
                "pump": pd.read_excel(uploaded_file, sheet_name="Pump Details"),
                "reactor": pd.read_excel(uploaded_file, sheet_name="Reactor Details")
            }
            st.success("Excel file loaded successfully!")
            with st.expander("Review & Edit Excel Data and Input Parameters", expanded=True):
                st.markdown("#### Excel Data Editing")
                st.session_state.dfs["lhs"] = st.data_editor(st.session_state.dfs["lhs"], key="lhs_editor")
                st.session_state.dfs["objectives"] = st.data_editor(st.session_state.dfs["objectives"], key="objectives_editor")
                st.session_state.dfs["pump"] = st.data_editor(st.session_state.dfs["pump"], key="pump_editor")
                st.session_state.dfs["reactor"] = st.data_editor(st.session_state.dfs["reactor"], key="reactor_editor")
                
                st.markdown("#### Input Parameters")
                colA, colB, colC = st.columns(3)
                with colA:
                    nexp = st.number_input("Number of LHS Experiments", min_value=1, value=10, step=1)
                with colB:
                    nobj = st.number_input("Number of Objectives", min_value=1, value=2, step=1)
                with colC:
                    nsor = st.number_input("Number of SOR Iterations", min_value=1, value=3, step=1)
                
                colP1, colP2 = st.columns(2)
                with colP1:
                    npump = st.selectbox("Number of Pumps", options=[3, 4])
                with colP2:
                    rscheme = st.selectbox("Reaction Scheme Identifier", options=[1, 2])
                
                st.markdown("#### HPLC Parameters")
                colH1, colH2 = st.columns(2)
                with colH1:
                    YminRT = st.number_input("Min RT for Purity (Yield)", value=2.0, format="%.2f")
                    YmaxRT = st.number_input("Max RT for Purity (Yield)", value=2.35, format="%.2f")
                    n_imp = st.number_input("Number of Impurities", min_value=0, value=1)
                    IminRT_list = []
                    ImaxRT_list = []
                    if n_imp > 0:
                        for i in range(int(n_imp)):
                            Imin = st.number_input(f"Min RT for Impurity {i+1}", value=1.3, format="%.2f", key=f"Imin_{i}")
                            Imax = st.number_input(f"Max RT for Impurity {i+1}", value=1.98, format="%.2f", key=f"Imax_{i}")
                            IminRT_list.append(Imin)
                            ImaxRT_list.append(Imax)
                with colH2:
                    minRTISO = st.number_input("Min RT for Standard", value=3.9, format="%.2f")
                    maxRTISO = st.number_input("Max RT for Standard", value=4.2, format="%.2f")
                    hplc_folder = st.text_input("Enter HPLC folder path", value="")
                
                st.session_state.inputs = {
                    "nexp": nexp,
                    "nobj": nobj,
                    "nsor": nsor,
                    "npump": npump,
                    "rscheme": rscheme,
                    "YminRT": YminRT,
                    "YmaxRT": YmaxRT,
                    "IminRT_list": IminRT_list,
                    "ImaxRT_list": ImaxRT_list,
                    "minRTISO": minRTISO,
                    "maxRTISO": maxRTISO,
                    "hplc_folder": hplc_folder
                }
        except Exception as e:
            st.error(f"Error processing Excel file: {str(e)}")
    
    # --- When the Send button is clicked ---
    if send_button and st.session_state.query_input and st.session_state.dfs:
        with st.spinner("Calculating flow rates via Gemini..."):
            # Use the autonomous reasoning agent to compute flow rates directly.
            agent_response = calculate_flowrates_with_agent(st.session_state.query_input, deepthink, st.session_state.dfs)
            st.info("Gemini response:")
            st.text(agent_response)
            flow_df = parse_flowrates(agent_response)
            if flow_df is None:
                st.error("Failed to calculate flow rates using the agent.")
                st.stop()
            st.success("Flow rates calculated successfully!")
            st.dataframe(flow_df.head())
        
        # ----------------------------------
        # Continue with Original Workflow
        # ----------------------------------
        st.info("Initializing domain and performing LHS design...")
        domain = utils.domain.create_domain_X(st.session_state.dfs["lhs"])
        domain = utils.domain.create_domain_y(domain, st.session_state.dfs["objectives"])
        lhs_exp = utils.lhs.LHSDesign(st.session_state.inputs["nexp"], domain, st.session_state.inputs["nobj"])
        save_path = os.path.join(tempfile.gettempdir(), "SOR_result.xlsx")
        lhs_exp.to_excel(save_path)
        st.success(f"LHS results saved at {save_path}")
        
        st.info("Calculating pump flowrates using the established formulas...")
        # For the pump flowrates, we call our alreadyâ€“implemented functions.
        if st.session_state.inputs["npump"] == 3 and st.session_state.inputs["rscheme"] == 1:
            lhs_pump = utils.flowrate.pump3_flow_rate1(lhs_exp, st.session_state.dfs["pump"], st.session_state.dfs["reactor"])
        elif st.session_state.inputs["npump"] == 3 and st.session_state.inputs["rscheme"] == 2:
            lhs_pump = utils.flowrate.pump3_flow_rate2(lhs_exp, st.session_state.dfs["pump"], st.session_state.dfs["reactor"])
        elif st.session_state.inputs["npump"] == 4 and st.session_state.inputs["rscheme"] == 1:
            lhs_pump = utils.flowrate.pump4_flow_rate1(lhs_exp, st.session_state.dfs["pump"], st.session_state.dfs["reactor"])
        elif st.session_state.inputs["npump"] == 4 and st.session_state.inputs["rscheme"] == 2:
            lhs_pump = utils.flowrate.pump4_flow_rate2(lhs_exp, st.session_state.dfs["pump"], st.session_state.dfs["reactor"])
        else:
            st.error("Invalid pump configuration.")
            st.stop()
        lhs_pump.to_excel(save_path)
        st.success("Pump flowrates calculated and saved!")
        
        # HPLC Data Reading
        if st.session_state.inputs["hplc_folder"]:
            st.info("Reading HPLC data from folder...")
            monitor_generator = utils.hplcread.monitor_folder_creation1_csv(
                lhs_pump,
                st.session_state.inputs["hplc_folder"],
                st.session_state.inputs["nobj"],
                st.session_state.inputs["YminRT"],
                st.session_state.inputs["YmaxRT"],
                st.session_state.inputs["IminRT_list"],
                st.session_state.inputs["ImaxRT_list"],
                st.session_state.inputs["minRTISO"],
                st.session_state.inputs["maxRTISO"]
            )
            i = 1
            while i <= st.session_state.inputs["nexp"]:
                try:
                    result = next(monitor_generator)
                    if result is not None:
                        result.to_excel(save_path)
                        st.write(f"HPLC results read for experiment {i}")
                        i += 1
                except StopIteration:
                    st.warning("HPLC data generator stopped early.")
                    break
            st.success("HPLC data read and saved!")
        else:
            st.warning("No HPLC folder provided, skipping HPLC data read.")
        
        # Optimization Step (SOR)
        st.info("Running optimization (SOR)...")
        sor_in = flow_df[flow_df.columns.drop(list(flow_df.filter(regex='Flow rate')))]
        if "Reaction time" in sor_in.columns:
            sor_in = sor_in.drop(columns={"Reaction time"})
        sor_in, opt_result = utils.optimization.run_optimization(
            domain,
            sor_in,
            st.session_state.inputs["nobj"],
            st.session_state.inputs["npump"],
            st.session_state.inputs["rscheme"],
            lhs_exp,
            st.session_state.dfs["pump"],
            st.session_state.dfs["reactor"]
        )
        combined_results = sor_in.copy()
        st.dataframe(sor_in)
        for i in range(1, st.session_state.inputs["nsor"]):
            st.info(f"Optimization iteration {i+1} of {st.session_state.inputs['nsor']}")
            opt_result.to_excel(save_path)
            if st.session_state.inputs["hplc_folder"]:
                monitor_generator1 = utils.hplcread.monitor_folder_creation1_csv(
                    sor_in,
                    st.session_state.inputs["hplc_folder"],
                    st.session_state.inputs["nobj"],
                    st.session_state.inputs["YminRT"],
                    st.session_state.inputs["YmaxRT"],
                    st.session_state.inputs["IminRT_list"],
                    st.session_state.inputs["ImaxRT_list"],
                    st.session_state.inputs["minRTISO"],
                    st.session_state.inputs["maxRTISO"],
                    use_dataframe_last_idx=True
                )
                try:
                    sor_in = next(monitor_generator1)
                except StopIteration:
                    st.warning("HPLC data generator for optimization stopped early.")
                    break
            sor_in, opt_result = utils.optimization.run_optimization(
                domain,
                sor_in,
                st.session_state.inputs["nobj"],
                st.session_state.inputs["npump"],
                st.session_state.inputs["rscheme"],
                lhs_exp,
                st.session_state.dfs["pump"],
                st.session_state.dfs["reactor"]
            )
            combined_results = pd.concat([combined_results, sor_in])
            st.dataframe(sor_in)
        st.success("Optimization Complete!")
        st.balloons()
        st.info(f"Final results saved at {save_path}")

if __name__ == "__main__":
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
    main()
########################################
You are an expert chemical engineer. You are given three JSON strings representing data from an Excel file:

1. LHS Data (a JSON array): Each object represents one row from the "LHS" sheet and includes at least the keys "ResidencetimeT1", "Equivalence1", and "Equivalence2".
2. Pump Details (a JSON array): 
   - The 0th element contains:
       - "Concentration of reagent (g/ml)" for the primary reagent,
       - "Molecular weight (g/mol)" for the primary reagent.
   - The 1st element contains:
       - "Concentration of reagent (g/ml)" and "Molecular weight (g/mol)" for reagent 1.
   - The 2nd element contains:
       - "Concentration of reagent (g/ml)" and "Molecular weight (g/mol)" for reagent 2.
3. Reactor Details (a JSON array): 
   - The value at row index 1, column 0 is called ReactorFactor.
   - (The Reactor Volume is at row index 3, column 0, but is not used in this calculation.)

For each row in the LHS Data, calculate a new field "Flow rate of Pump 1" using the following formula:

   Flow rate of Pump 1 = 
      ( ( ReactorFactor / [ResidencetimeT1] ) *
         ( ( 1 / ( (Concentration0 / MolecularWeight0) * 1000 ) ) /
           ( ( 1 / ( (Concentration0 / MolecularWeight0) * 1000 ) ) +
             ( Equivalence1 / ( (Concentration1 / MolecularWeight1) * 1000 ) ) +
             ( Equivalence2 / ( (Concentration2 / MolecularWeight2) * 1000 ) )
           )
         )
      )[0]

Where:
- [ResidencetimeT1] is the value from the "ResidencetimeT1" key of the current LHS row.
- ReactorFactor is the value from Reactor Details at row index 1, column 0.
- Concentration0 and MolecularWeight0 are from the 0th element of Pump Details.
- Equivalence1 and Equivalence2 come from the current LHS row (from keys "Equivalence1" and "Equivalence2").
- Concentration1 and MolecularWeight1 come from the 1st element of Pump Details.
- Concentration2 and MolecularWeight2 come from the 2nd element of Pump Details.
- The division by 1000 converts units appropriately.
- The [0] at the end indicates that the final result should be a single numeric value.

Return the final results as a JSON array of objects. Each object should correspond to one row of the LHS Data and include all its original fields plus the new field "Flow rate of Pump 1" holding the computed value.

Here are the JSON strings (replace the placeholders with your actual JSON data):

LHS Data: <INSERT LHS JSON HERE>  
Pump Details: <INSERT Pump Details JSON HERE>  
Reactor Details: <INSERT Reactor Details JSON HERE>

Please compute the values and return only the JSON array of results.
