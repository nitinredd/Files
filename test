import os
import streamlit as st
import tempfile
import logging
from io import BytesIO
import json
import time
import google.auth
from vertexai.preview.generative_models import GenerativeModel, Image as GeminiImage
import fitz  # PyMuPDF
from xhtml2pdf import pisa

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Set up Vertex AI
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()
multimodal_model = GenerativeModel("gemini-pro-vision")

def get_safe_extraction_prompt():
    return """Extract and analyze the document content with focus on structure and organization.
    Tasks:
    1. Identify document sections and hierarchy
    2. Extract text content preserving formatting
    3. Note any special formatting or structure
    
    Format as JSON:
    {
        "elements": [
            {
                "type": "section",
                "content": "text content",
                "level": "heading level number",
                "indent": "number of spaces"
            }
        ]
    }
    
    Focus on accuracy and clarity. Maintain original formatting."""

def safe_gemini_call(image, max_retries=3, delay=2):
    """Make API calls with retry logic and safety filter handling"""
    prompt = get_safe_extraction_prompt()
    
    for attempt in range(max_retries):
        try:
            response = multimodal_model.generate_content(
                [
                    prompt,
                    image
                ],
                safety_settings={
                    "HARASSMENT": "block_none",
                    "HATE_SPEECH": "block_none",
                    "SEXUALLY_EXPLICIT": "block_none",
                    "DANGEROUS_CONTENT": "block_none"
                }
            )
            
            # Check if we got a valid response
            if hasattr(response, 'text') and response.text:
                return response
            
        except Exception as e:
            logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
            if attempt < max_retries - 1:
                time.sleep(delay)
                continue
            raise
    
    raise Exception("Failed to get valid response after maximum retries")

def translate_text(text, language):
    if not text:
        return ""
    
    prompt = f"""Provide a professional translation from {language} to English.
    Original text: {text}
    Rules:
    - Maintain all formatting
    - Preserve technical terms
    - Keep document structure"""
    
    try:
        responses = multimodal_model.generate_content([prompt])
        return responses.text if hasattr(responses, 'text') else ''.join([r.text for r in responses])
    except Exception as e:
        logger.error(f"Translation error: {str(e)}")
        return text  # Return original text if translation fails

def extract_images_from_pdf(pdf_file):
    images = []
    temp_pdf_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_pdf:
            temp_pdf.write(pdf_file.getvalue())
            temp_pdf_path = temp_pdf.name
        
        doc = fitz.open(temp_pdf_path)
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            # Increased resolution and using RGB color space
            pix = page.get_pixmap(matrix=fitz.Matrix(3, 3), alpha=False)
            image_bytes = pix.tobytes("png")
            images.append(image_bytes)
            logger.info(f"Extracted image from page {page_num}")
        
        doc.close()
        return images
    finally:
        if temp_pdf_path and os.path.exists(temp_pdf_path):
            try:
                os.unlink(temp_pdf_path)
            except Exception as e:
                logger.error(f"Error deleting temporary PDF file: {str(e)}")

def parse_response(response):
    """Parse API response with robust error handling"""
    try:
        # Handle string response
        if isinstance(response, str):
            return json.loads(response)
            
        # Handle Gemini response object
        if hasattr(response, 'text'):
            text = response.text
        else:
            text = ''.join([r.text for r in response])
        
        # Try to find and parse JSON content
        start = text.find('{')
        end = text.rfind('}') + 1
        
        if start >= 0 and end > start:
            json_str = text[start:end]
            return json.loads(json_str)
            
    except Exception as e:
        logger.error(f"Error parsing response: {str(e)}")
    
    # Fallback: return text as single element
    return {
        "elements": [
            {
                "type": "section",
                "content": str(text),
                "level": 1,
                "indent": 0
            }
        ]
    }

def convert_to_html(parsed_data):
    html_content = """
    <html>
    <head>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                margin: 20px; 
                line-height: 1.6;
            }
            .section {
                margin: 10px 0;
                white-space: pre-wrap;
            }
            .level-1 { margin-left: 0px; font-weight: bold; font-size: 1.2em; }
            .level-2 { margin-left: 20px; font-weight: bold; }
            .level-3 { margin-left: 40px; }
            .level-4 { margin-left: 60px; }
        </style>
    </head>
    <body>
    """
    
    for element in parsed_data.get('elements', []):
        indent = int(element.get('indent', 0))
        level = int(element.get('level', 1))
        content = element.get('content', '')
        
        html_content += f"""
        <div class="section level-{level}" style="margin-left: {indent * 10}px">
            {content}
        </div>
        """
    
    html_content += "</body></html>"
    return html_content

def create_pdf(html_content):
    pdf_buffer = BytesIO()
    pisa.CreatePDF(
        BytesIO(html_content.encode('utf-8')),
        dest=pdf_buffer,
        encoding='utf-8'
    )
    pdf_buffer.seek(0)
    return pdf_buffer

def process_document(image_data, language):
    """Process document with improved error handling"""
    try:
        # Get content with retries
        response = safe_gemini_call(image_data)
        
        # Parse the response
        parsed_data = parse_response(response)
        
        # Translate content
        translated_data = {"elements": []}
        for element in parsed_data.get('elements', []):
            translated_content = translate_text(element.get('content', ''), language)
            translated_data['elements'].append({
                "type": element.get('type', 'section'),
                "content": translated_content,
                "level": element.get('level', 1),
                "indent": element.get('indent', 0)
            })
        
        return translated_data
    except Exception as e:
        logger.error(f"Document processing error: {str(e)}")
        raise

def main():
    st.title("Document Translator - Chinese & Japanese to English")
    
    # File upload options
    option = st.selectbox("Select document type:", ["PDF", "Image"])
    
    if option == "PDF":
        uploaded_file = st.file_uploader("Upload PDF document", type="pdf")
    else:
        uploaded_file = st.file_uploader("Upload image", type=["png", "jpg", "jpeg"])
    
    language = st.selectbox("Source language:", ["Chinese", "Japanese"])
    
    if st.button("Translate"):
        if uploaded_file:
            try:
                with st.spinner('Processing document...'):
                    if option == "PDF":
                        images = extract_images_from_pdf(uploaded_file)
                        if not images:
                            st.error("Could not extract images from PDF.")
                            return
                        
                        combined_data = {"elements": []}
                        progress = st.progress(0)
                        
                        for idx, img_data in enumerate(images):
                            image = GeminiImage.from_bytes(img_data)
                            page_data = process_document(image, language)
                            combined_data['elements'].extend(page_data['elements'])
                            progress.progress((idx + 1) / len(images))
                        
                        html_content = convert_to_html(combined_data)
                        pdf_buffer = create_pdf(html_content)
                        
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                    
                    else:  # Single image
                        st.image(uploaded_file, caption='Original Document', use_column_width=True)
                        image = GeminiImage.from_bytes(uploaded_file.getvalue())
                        
                        translated_data = process_document(image, language)
                        
                        st.subheader("Translation Preview")
                        html_content = convert_to_html(translated_data)
                        st.markdown(html_content, unsafe_allow_html=True)
                        
                        pdf_buffer = create_pdf(html_content)
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                
            except Exception as e:
                st.error(f"An error occurred: {str(e)}")
                logger.exception("Processing error")
        else:
            st.error("Please upload a document to translate.")

if __name__ == "__main__":
    main()
