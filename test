from pydantic import BaseModel
from typing import List

class QueryRequest(BaseModel):
    product_ids: List[str]
    question: str

@app.post("/query")
def query_documents(req: QueryRequest):
    """
    Query multiple product documents (product_ids) and return an answer + sources.
    """
    if not req.product_ids:
        raise HTTPException(status_code=400, detail="product_ids must be a non-empty list")
    if not req.question or not req.question.strip():
        raise HTTPException(status_code=400, detail="question required")

    # Collect documents
    docs = []
    for pid in req.product_ids:
        try:
            meta = product_meta(pid)
        except HTTPException:
            continue
        pdf_path = meta.get("pdf_path")
        if not pdf_path or not os.path.exists(pdf_path):
            continue
        text = extract_pdf_text(pdf_path)
        if not text or len(text.strip()) < 50:
            continue
        doc = Document(
            page_content=text,
            metadata={
                "product_id": pid,
                "product_name": meta.get("name", ""),
                "reaction_type": meta.get("reaction_type", "")
            }
        )
        docs.append(doc)

    if len(docs) == 0:
        raise HTTPException(status_code=404, detail="No documents available for the provided product_ids")

    # Build FAISS on-the-fly (safe for moderate numbers of docs)
    try:
        vector_store = FAISS.from_documents(docs, cached_embeddings)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed building vector index: {e}")

    retriever = vector_store.as_retriever(search_kwargs={"k": 3})

    qa_chain = RetrievalQA.from_chain_type(
        llm=chat_model,
        chain_type="stuff",
        retriever=retriever,
        chain_type_kwargs={"prompt": PROMPT},
        return_source_documents=True
    )

    try:
        out = qa_chain({"query": req.question})
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"QA execution failed: {e}")

    answer_text = out.get("result") or out.get("output_text") or str(out)
    source_docs = out.get("source_documents", [])

    # Build sources: unique product ids preserving order
    seen = set()
    sources = []
    for sd in source_docs:
        pid = sd.metadata.get("product_id")
        pname = sd.metadata.get("product_name")
        if pid and pid not in seen:
            seen.add(pid)
            sources.append({"product_id": pid, "product_name": pname})

    return {"answer": answer_text, "sources": sources}
#####################################################
class QARequest(BaseModel):
    product_id: Optional[str] = None
    question: str = "Extract API Name, Reaction Chemistry, Yield, Procedure, and Tabular Data"

@app.post("/product/details")
def product_details(req: QARequest):
    """
    If product_id provided -> run on that product.
    If no product_id provided -> try to detect product name mention in the question and run on that product (intelligent chunking).
    Otherwise (no product and no name mention) fallback to a model-only response (best-effort).
    """
    q_text = (req.question or "").strip()
    if not q_text:
        raise HTTPException(status_code=400, detail="question required")

    # If product_id explicitly provided -> use it
    if req.product_id:
        pid = req.product_id
    else:
        # Try to detect product name mention in the query
        # Build normalized map: normalized_name -> product_id
        products = list_products()
        norm_map = {}
        for p in products:
            # normalize product name: remove non-alnum, lowercase
            name_norm = re.sub(r'[^a-z0-9]', '', p["name"].lower())
            norm_map[name_norm] = p["id"]

        # Normalize question and search for any product name token matches
        q_norm = re.sub(r'[^a-z0-9\s]', ' ', q_text.lower())  # keep spaces
        # Try to find longest matching product name substring
        matched_pid = None
        matched_name = None
        # iterate products by length descending to prefer longer matches
        for p in sorted(products, key=lambda x: len(x["name"]), reverse=True):
            candidate_norm = re.sub(r'[^a-z0-9]', '', p["name"].lower())
            if candidate_norm and candidate_norm in q_norm.replace(' ', ''):
                matched_pid = p["id"]
                matched_name = p["name"]
                break

        if matched_pid:
            pid = matched_pid
        else:
            pid = None

    # If we have a pid now, run QA against that single product
    if pid:
        # find product metadata
        products = list_products()
        product = next((x for x in products if x["id"] == pid), None)
        if not product:
            raise HTTPException(status_code=404, detail="Product not found")

        # For a user query, run retriever on that product
        try:
            text = extract_pdf_text(product["pdf_path"])
            doc = Document(page_content=text, metadata={
                "product_id": product["id"],
                "product_name": product["name"],
                "reaction_type": product["reaction_type"],
                "source": product["pdf_path"],
            })
            vs = FAISS.from_documents([doc], cached_embeddings)
            retriever = vs.as_retriever(search_kwargs={"k": 3})
            qa_chain = RetrievalQA.from_chain_type(
                llm=chat_model,
                chain_type="stuff",
                retriever=retriever,
                chain_type_kwargs={"prompt": PROMPT},
                return_source_documents=True
            )
            out = qa_chain({"query": q_text})
            answer_text = out.get("result") or out.get("output_text") or ""
            # sources
            sdocs = out.get("source_documents", [])
            seen = set()
            sources = []
            for sd in sdocs:
                pid_src = sd.metadata.get("product_id")
                pname_src = sd.metadata.get("product_name")
                if pid_src and pid_src not in seen:
                    seen.add(pid_src)
                    sources.append({"product_id": pid_src, "product_name": pname_src})
            return {"answer": answer_text, "sources": sources}
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error processing product-specific QA: {e}")

    # If no product context: fallback to generative model response (no retriever)
    try:
        qa_chain = RetrievalQA.from_chain_type(
            llm=chat_model,
            chain_type="stuff",
            retriever=None,
            chain_type_kwargs={"prompt": PROMPT},
            return_source_documents=False
        )
        raw_response = qa_chain.run(q_text)
        return {"response": raw_response}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating response: {e}")
############################################
// append to src/api.js
export const queryWithCitations = (productIds = [], question = "") => {
  return api.post('/query', { product_ids: productIds, question });
};
#########################
import React from 'react';
import { motion } from 'framer-motion';

/**
 * ProductTabs with right-click citation support
 * props:
 *  - products
 *  - onSelect(productId)
 *  - onContext(product) // right-click to toggle citation
 *  - citedIds: Set of product ids currently cited
 */
export default function ProductTabs({ products = [], onSelect, onContext, citedIds = new Set() }) {
  return (
    <div className="bg-transparent">
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-lg font-semibold text-primary">Matched Products</h3>
        <div className="text-sm text-gray-500">Left-click to view • Right-click to cite</div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {products.map(p => {
          const selected = citedIds.has(p.id);
          return (
            <motion.button
              key={p.id}
              whileHover={{ y: -4 }}
              onClick={() => onSelect && onSelect(p.id)}
              onContextMenu={(e) => {
                e.preventDefault();
                onContext && onContext(p);
              }}
              title={p.name}
              className={`relative bg-white border rounded-2xl p-4 shadow hover:shadow-xl transition flex flex-col justify-between text-left text-sm ${selected ? 'ring-2 ring-accent' : ''}`}
            >
              <div className="flex items-start gap-3">
                <div className="flex-1">
                  <div className="font-semibold text-primary truncate">{p.name}</div>
                  <div className="text-xs text-gray-400 mt-1">{p.reaction_type?.replace(/_/g,' ')}</div>
                </div>
                {selected && <div className="text-xs text-white bg-accent px-2 py-1 rounded-full">CITED</div>}
              </div>
              <div className="mt-3 text-xs text-gray-500 truncate">{p.pdf_path ? p.pdf_path.split(/[\\/]/).pop() : ''}</div>
            </motion.button>
          );
        })}
      </div>
    </div>
  );
}
#########################################
import React, { useRef, useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { FiSend } from 'react-icons/fi';
import MicrophoneButton from './MicrophoneButton';

export default function ChatWindow({ messages, onSend, centeredWidth = "max-w-3xl", selectedCitedDocs = [], removeCitation = () => {} }){
  const [text, setText] = useState('');
  const textareaRef = useRef();

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [text, messages]);

  const submit = () => {
    const t = text.trim();
    if (!t) return;
    onSend(t);
    setText('');
  };

  return (
    <div className={`mx-auto ${centeredWidth}`}>
      <div className="bg-white rounded-3xl shadow-2xl p-6">
        {/* Citation chips */}
        {selectedCitedDocs && selectedCitedDocs.length > 0 && (
          <div className="mb-4 flex flex-wrap gap-2">
            {selectedCitedDocs.map(d => (
              <div key={d.id} className="flex items-center gap-2 bg-purple-50 text-purple-800 px-3 py-1 rounded-full text-xs">
                <span className="max-w-[220px] truncate">{d.name}</span>
                <button onClick={() => removeCitation(d.id)} className="ml-1 px-1 rounded-full bg-white shadow text-xs" title="Remove citation">✕</button>
              </div>
            ))}
          </div>
        )}

        <div className="min-h-[220px] max-h-[54vh] overflow-auto pr-2">
          {messages.map((m, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.28, delay: idx * 0.02 }}
              className={`mb-3 ${m.role === 'user' ? 'flex justify-end' : 'flex justify-start'}`}
            >
              <div className={`${m.role === 'user' ? 'bg-gradient-to-br from-secondary to-primary text-white' : 'bg-gray-50 text-gray-800'} px-4 py-3 rounded-2xl max-w-[80%] whitespace-pre-wrap break-words`}>
                {m.content}
              </div>
            </motion.div>
          ))}
        </div>

        {/* Input area */}
        <div className="mt-4 flex items-end gap-3">
          <MicrophoneButton onText={(t) => setText(t)} />
          <textarea
            ref={textareaRef}
            value={text}
            onChange={(e)=> setText(e.target.value)}
            rows={1}
            placeholder="Ask about reaction chemistry or type a reaction name..."
            className="flex-1 resize-none px-4 py-3 rounded-3xl border focus:outline-none focus:ring-2 focus:ring-secondary scrollbar-hide"
            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submit(); } }}
          />
          <button onClick={submit} className="p-3 rounded-full bg-primary text-white shadow hover:scale-95">
            <FiSend />
          </button>
        </div>
      </div>
    </div>
  );
}
########################
// src/App.jsx
import React, { useEffect, useState } from 'react';
import ChatWindow from "./ChatWindow";
import ProductTabs from "./ProductTabs";
import ProductDetailModal from "./ProductDetailModal";
import SidebarHistory from "./SidebarHistory";
import {
  fetchReactions,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  queryWithCitations
} from './api';
import Navbar from "../Navbar/Navbar";
import Footer from "../Footer/Footer";

import chem_logo from "../../assets/Chemhub_Logo_Colored.png";

export default function App() {
  // Core state
  const [reactions, setReactions] = useState([]);
  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);
  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);
  const [detailModalOpen, setDetailModalOpen] = useState(false);
  const [messages, setMessages] = useState([]); // chat messages
  const [history, setHistory] = useState([]);
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  // Citation-specific state (multi-select)
  // Each item: { id, name, reaction_type }
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);

  // Load reactions on mount
  useEffect(() => {
    fetchReactions().then(setReactions).catch(e => console.error("fetchReactions:", e));
  }, []);

  // Helpers
  const pushMessage = (m) => setMessages(prev => [...prev, m]);
  const normalize = s => (s || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');

  // Set of cited ids for ProductTabs styling
  const citedIdsSet = new Set(selectedCitedDocs.map(d => d.id));

  // Toggle citation on right-click
  const handleToggleCite = (product) => {
    // determine if currently cited
    const exists = selectedCitedDocs.find(p => p.id === product.id);
    if (exists) {
      // remove
      setSelectedCitedDocs(prev => prev.filter(p => p.id !== product.id));
      pushMessage({ role: 'assistant', content: `Removed citation: ${product.name}` });
    } else {
      // add (prepend)
      setSelectedCitedDocs(prev => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: 'assistant', content: `Added citation: ${product.name}` });
    }
  };

  // Remove citation from chip
  const removeCitation = (id) => {
    const found = selectedCitedDocs.find(d => d.id === id);
    setSelectedCitedDocs(prev => prev.filter(d => d.id !== id));
    if (found) pushMessage({ role: 'assistant', content: `Removed citation: ${found.name}` });
  };

  // Handle user sending a message
  const handleUserSend = async (text) => {
    // 1. Append user's message to chat
    pushMessage({ role: 'user', content: text });

    // 2. Quick reaction-type detection (unchanged)
    const norm = normalize(text);
    const match = reactions.find(r => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g, '_')));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        pushMessage({ role: 'assistant', content: `Found ${prods.length} product${(prods.length === 1 ? '' : 's')} — pick one below.` });
      } catch (e) {
        console.error("fetchProducts by reaction:", e);
        pushMessage({ role: 'assistant', content: 'Error loading products for that reaction.' });
      }
      return;
    }

    // 3. "show/list/find ... for X" style detection (unchanged)
    const prefix = text.match(/(?:show|list|find).{0,20}for\s+(.+)/i);
    if (prefix && prefix[1]) {
      const candidate = prefix[1].trim();
      const found = reactions.find(r => normalize(r).includes(normalize(candidate)) || normalize(candidate).includes(normalize(r)));
      if (found) {
        setSelectedReaction(found);
        try {
          const prods = await fetchProducts(found);
          setProducts(prods || []);
          setProductListVisible(true);
          pushMessage({ role: 'assistant', content: `Found ${prods.length} product${(prods.length === 1 ? '' : 's')}. Select below.` });
        } catch (e) {
          console.error("fetchProducts by candidate:", e);
          pushMessage({ role: 'assistant', content: 'Error fetching products.' });
        }
        return;
      }
    }

    // 4. If there are cited documents -> use the /query endpoint to search ONLY those docs
    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      try {
        pushMessage({ role: 'assistant', content: 'Searching selected documents...' });
        const productIds = selectedCitedDocs.map(d => d.id);
        const res = await queryWithCitations(productIds, text);
        const payload = (res && res.data) ? res.data : res;

        // Primary answer
        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        pushMessage({ role: 'assistant', content: answer });

        // Citations block (if provided)
        if (payload?.sources && Array.isArray(payload.sources) && payload.sources.length > 0) {
          const citationsText = payload.sources.map((s, i) => `${i + 1}. ${s.product_name} (id: ${s.product_id})`).join('\n');
          pushMessage({ role: 'assistant', content: `Citations:\n${citationsText}` });
        } else {
          pushMessage({ role: 'assistant', content: 'No citation sources returned.' });
        }
      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: 'assistant', content: 'Error querying selected documents.' });
      }
      return;
    }

    // 5. If no product selected, try to let backend detect product mention (your backend handles name-detection)
    //    We call fetchProductDetails without a productId (backend will detect if a product name is mentioned)
    if (!selectedProduct) {
      try {
        pushMessage({ role: 'assistant', content: 'Searching documents for mentioned product (if any)...' });
        const res = await fetchProductDetails(undefined, text); // backend expects product_id optional
        const payload = (res && res.data) ? res.data : res;

        // Handle response shapes: {answer, sources} or {response} or parsed structured object
        if (payload?.answer || payload?.sources) {
          const answer = payload.answer || payload.response || "No relevant answer.";
          pushMessage({ role: 'assistant', content: answer });

          if (payload?.sources && Array.isArray(payload.sources) && payload.sources.length > 0) {
            const citationsText = payload.sources.map((s, i) => `${i + 1}. ${s.product_name} (id: ${s.product_id})`).join('\n');
            pushMessage({ role: 'assistant', content: `Citations:\n${citationsText}` });
          }
        } else if (payload?.response) {
          pushMessage({ role: 'assistant', content: payload.response });
        } else {
          // fallback: no structured answer -> ask user to select product
          pushMessage({ role: 'assistant', content: 'Please select a product/document first (or right-click to cite documents).' });
        }
      } catch (err) {
        console.error("fetchProductDetails (no product) error:", err);
        pushMessage({ role: 'assistant', content: 'Error querying documents.' });
      }
      return;
    }

    // 6. If a single product is selected -> perform per-product QA (existing flow)
    try {
      setLoadingDetails(true);
      const res = await fetchProductDetails(selectedProduct.id, text);
      const d = (res && res.data) ? res.data : res;

      // The backend may return {answer, sources} for queries or parsed structured object for extraction.
      if (d?.answer || d?.sources) {
        const answer = d.answer || d.response || "No answer.";
        pushMessage({ role: 'assistant', content: answer });
        if (d.sources && d.sources.length > 0) {
          const citationsText = d.sources.map((s, i) => `${i + 1}. ${s.product_name} (id: ${s.product_id})`).join('\n');
          pushMessage({ role: 'assistant', content: `Citations:\n${citationsText}` });
        }
      } else {
        // If backend returned structured parsed info (api_name, procedure, tables...), display a summary and open detail modal
        let assistantText = '';
        if (d?.api_name) assistantText += `API: ${d.api_name}\n\n`;
        if (d?.reaction_chemistry) assistantText += `Reaction: ${d.reaction_chemistry}\n\n`;
        if (d?.yield) assistantText += `Yield: ${d.yield}\n\n`;
        if (d?.procedure) assistantText += `Procedure (excerpt):\n${(d.procedure || '').slice(0, 600)}\n\n`;
        if (!assistantText) assistantText = 'No structured answer found.';
        pushMessage({ role: 'assistant', content: assistantText });

        // set details & modal for user to inspect
        setProductDetails(d);
        setDetailModalOpen(true);
        setHistory(h => [{ title: selectedProduct.name, content: text, productId: selectedProduct.id }, ...h]);
      }
    } catch (err) {
      console.error("fetchProductDetails (selectedProduct) error:", err);
      pushMessage({ role: 'assistant', content: 'Error querying backend.' });
    } finally {
      setLoadingDetails(false);
    }
  };

  // When user clicks a product tile to open detail modal
  const handleSelectProduct = async (productId) => {
    try {
      const meta = await fetchProductMeta(productId);
      setSelectedProduct(meta);
      setProductDetails(null);
      setSelectedSchemeUrl(null);
      setLoadingDetails(true);

      // open modal early with loader
      setDetailModalOpen(true);

      // preload scheme url for chat preview (optional)
      try {
        const scheme = await fetchSchemeImageUrl(productId);
        setSelectedSchemeUrl(scheme);
      } catch (e) {
        // ignore scheme preload errors
      }

      const res = await fetchProductDetails(productId); // default behavior will return parsed structured info
      const d = (res && res.data) ? res.data : res;
      setProductDetails(d);
      setHistory(h => [{ title: meta.name, content: d.procedure ? d.procedure.slice(0, 120) : '', productId: meta.id }, ...h]);
    } catch (e) {
      console.error("handleSelectProduct error:", e);
      pushMessage({ role: 'assistant', content: 'Failed to load product details.' });
    } finally {
      setLoadingDetails(false);
    }
  };

  return (
    <>
      <Navbar />
      <div className="min-h-screen bg-gradient-to-b from-bg to-white flex">
        {/* center column */}
        <div className="mx-auto my-8 w-full max-w-6xl px-4">
          {/* Header / Logo */}
          <div className="flex flex-col items-center justify-center mb-6">
            <img className="h-50 w-30" src={chem_logo} alt="chemhub-logo" />
          </div>

          {/* Main area (chat + product tabs) */}
          <div className="relative">
            <ChatWindow
              messages={messages}
              onSend={handleUserSend}
              centeredWidth="max-w-4xl"
              selectedSchemeUrl={selectedSchemeUrl}
              selectedProduct={selectedProduct}
              selectedCitedDocs={selectedCitedDocs}
              removeCitation={removeCitation}
            />

            {productListVisible && products && products.length > 0 && (
              <div className="mt-6">
                <ProductTabs
                  products={products}
                  onSelect={handleSelectProduct}
                  onContext={handleToggleCite} // right-click toggles citation
                  citedIds={citedIdsSet}
                />
              </div>
            )}
          </div>
        </div>

        {/* Right-side collapsible history */}
        <SidebarHistory
          history={history}
          onSelect={(h) => {
            if (h && h.productId) handleSelectProduct(h.productId);
          }}
        />

        {/* Product detail modal */}
        <ProductDetailModal
          open={detailModalOpen}
          onClose={() => setDetailModalOpen(false)}
          meta={selectedProduct}
          details={productDetails}
          loading={loadingDetails}
        />
      </div>
      <Footer />
    </>
  );
}
##########################
// src/components/ProductTabs.jsx
import React, { useRef, useEffect } from "react";
import { motion } from "framer-motion";

/**
 * ProductTabs
 *
 * Props:
 *  - products: Array<{id, name, reaction_type, pdf_path, has_scheme_image, has_scheme_cdx}>
 *  - onSelect(productId)        // left-click / keyboard Enter to open product
 *  - onContext(product)         // right-click to toggle citation selection
 *  - citedIds: Set<string>      // set of product ids currently cited (for visual state)
 *
 * Features:
 *  - horizontal scroll area with left/right nav buttons
 *  - long-press / hold to continuously scroll (mouse + touch)
 *  - right-click toggles citation (prevents default context menu)
 *  - accessible: supports Enter key to select tile
 *  - graceful truncation + full name via title attribute
 */
export default function ProductTabs({
  products = [],
  onSelect,
  onContext,
  citedIds = new Set(),
}) {
  const scrollContainerRef = useRef(null);
  const scrollIntervalRef = useRef(null);

  useEffect(() => {
    // Cleanup on unmount
    return () => {
      if (scrollIntervalRef.current) {
        clearInterval(scrollIntervalRef.current);
        scrollIntervalRef.current = null;
      }
    };
  }, []);

  const startScrolling = (direction) => {
    if (!scrollContainerRef.current) return;
    if (scrollIntervalRef.current) return; // already scrolling

    scrollIntervalRef.current = setInterval(() => {
      scrollContainerRef.current.scrollBy({
        left: direction === "left" ? -60 : 60,
        behavior: "smooth",
      });
    }, 100);
  };

  const stopScrolling = () => {
    if (scrollIntervalRef.current) {
      clearInterval(scrollIntervalRef.current);
      scrollIntervalRef.current = null;
    }
  };

  const scrollOnce = (direction) => {
    if (!scrollContainerRef.current) return;
    stopScrolling();
    scrollContainerRef.current.scrollBy({
      left: direction === "left" ? -240 : 240,
      behavior: "smooth",
    });
  };

  return (
    <div className="bg-transparent">
      {/* Header */}
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-lg font-semibold text-primary">Matched Products</h3>
        <div className="text-sm text-gray-500">Left-click to open • Right-click to cite</div>
      </div>

      {/* Navigation + Scroll area */}
      <div className="flex items-center gap-3">
        {/* Left nav */}
        <button
          aria-label="Scroll left"
          title="Scroll Left"
          className="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-full shadow-md transition"
          onClick={() => scrollOnce("left")}
          onMouseDown={() => startScrolling("left")}
          onMouseUp={stopScrolling}
          onMouseLeave={stopScrolling}
          onTouchStart={() => startScrolling("left")}
          onTouchEnd={stopScrolling}
        >
          ←
        </button>

        {/* Scrollable container */}
        <div
          ref={scrollContainerRef}
          className="overflow-x-auto py-2 w-full no-scrollbar flex gap-3"
          role="list"
        >
          {products.map((product) => {
            const isCited = citedIds && citedIds.has && citedIds.has(product.id);
            return (
              <motion.button
                key={product.id}
                role="listitem"
                whileHover={{ y: -6 }}
                whileTap={{ scale: 0.98 }}
                onClick={() => onSelect && onSelect(product.id)}
                onContextMenu={(e) => {
                  if (onContext) {
                    e.preventDefault();
                    onContext(product);
                  }
                }}
                onKeyDown={(e) => {
                  if (e.key === "Enter" || e.key === " ") {
                    e.preventDefault();
                    onSelect && onSelect(product.id);
                  }
                }}
                title={product.name}
                className={`min-w-[220px] max-w-[240px] flex-shrink-0 bg-white border rounded-2xl p-3 shadow hover:shadow-lg transition flex flex-col justify-between text-left
                  ${isCited ? "ring-2 ring-accent" : ""}`}
                aria-pressed={isCited ? "true" : "false"}
              >
                <div className="flex items-start justify-between gap-3">
                  <div className="flex-1">
                    <div className="text-sm font-semibold text-primary truncate" style={{ maxWidth: "100%" }}>
                      {product.name}
                    </div>
                    <div className="text-xs text-gray-400 mt-1">{(product.reaction_type || "").replace(/_/g, " ")}</div>
                  </div>

                  {isCited && (
                    <div className="text-xs text-white bg-accent px-2 py-1 rounded-full">CITED</div>
                  )}
                </div>

                <div className="text-xs mt-2 text-gray-500 truncate">
                  {product.pdf_path ? product.pdf_path.split(/[\\/]/).pop() : ""}
                </div>
              </motion.button>
            );
          })}
        </div>

        {/* Right nav */}
        <button
          aria-label="Scroll right"
          title="Scroll Right"
          className="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-full shadow-md transition"
          onClick={() => scrollOnce("right")}
          onMouseDown={() => startScrolling("right")}
          onMouseUp={stopScrolling}
          onMouseLeave={stopScrolling}
          onTouchStart={() => startScrolling("right")}
          onTouchEnd={stopScrolling}
        >
          →
        </button>
      </div>
    </div>
  );
}

#############################
