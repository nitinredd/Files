import numpy as np

def calculate_f2_fda(reference_df, test_df):
    """
    FDA >=85% rule:
      - Drop time = 0 if present
      - Find the first timepoint where both reference AND test mean >85%
      - Trim both DataFrames to [0 .. that timepoint]
      - Compute conventional f2 and expected f2 on the trimmed means
    Returns:
      f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
    """
    # 1) Copy & drop time zero
    ref = reference_df.reset_index(drop=True).copy()
    tst = test_df.reset_index(drop=True).copy()
    if float(ref.iloc[0, 0]) == 0.0:
        ref = ref.drop(0).reset_index(drop=True)
        tst = tst.drop(0).reset_index(drop=True)

    # 2) Compute per‑time means
    ref_mean  = ref.iloc[:,1:].mean(axis=1).values
    test_mean = tst.iloc[:,1:].mean(axis=1).values

    # 3) Find first index where both >85%
    cutoff = next((i for i, (r, t) in enumerate(zip(ref_mean, test_mean))
                   if r > 85 and t > 85),
                  None)
    if cutoff is None:
        raise ValueError("Neither profile has a simultaneous >85% timepoint.")

    # 4) Trim both
    trimmed_ref_df  = ref.iloc[:cutoff+1].copy()
    trimmed_test_df = tst.iloc[:cutoff+1].copy()

    # Force 0% at t=0
    if float(trimmed_ref_df.iloc[0, 0]) == 0.0:
        trimmed_ref_df.iloc[0, 1:]  = 0.0
        trimmed_test_df.iloc[0, 1:] = 0.0

    # 5a) conventional f2
    diff    = (trimmed_test_df.iloc[:,1:].mean(axis=1).values
             - trimmed_ref_df.iloc[:,1:].mean(axis=1).values)
    p       = len(diff)
    sum_sq  = np.sum(diff**2)
    f2_conv = 100 - 25 * np.log10(1 + sum_sq / p)

    # 5b) expected f2
    var_ref   = trimmed_ref_df.iloc[:,1:].var(axis=1, ddof=1).values
    var_test  = trimmed_test_df.iloc[:,1:].var(axis=1, ddof=1).values
    avg_var   = np.mean(var_ref + var_test)
    exp_f2    = 100 - 25 * np.log10(1 + (sum_sq + p * avg_var) / p)

    return f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
##############################
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

elif input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Check criteria & CV
    both_85 = check_both_85(reference_df, test_df)
    either_85 = check_either_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:", both_85)
    print("Either ≥ 85% criterion met:", either_85)

    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # 2) Drop time=0 for alignment
    ref0 = reference_df.reset_index(drop=True).copy()
    tst0 = test_df.reset_index(drop=True).copy()
    if float(ref0.iloc[0,0]) == 0.0:
        ref0 = ref0.drop(0).reset_index(drop=True)
        tst0 = tst0.drop(0).reset_index(drop=True)

    if not check_same_time_points(tst0, ref0):
        print("Error: Time points between test and reference do not match.")
        print("Calculations cannot be performed.")
    else:
        try:
            # 3) Compute f2s & get trimmed dfs
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)

            print(f"Conventional f2: {f2_conv:.2f}")
            print(f"Expected    f2: {f2_exp:.2f}")
            if not cv_check:
                print("\nWarning: CV requirements not met; interpret with caution.")

            # --- Graph 1: Simple dissolution curves ---
            times   = ref_trim.iloc[:,0].astype(float)
            r_mean  = ref_trim.iloc[:,1:].mean(axis=1)
            t_mean  = test_trim.iloc[:,1:].mean(axis=1)

            plt.figure(figsize=(12,6))
            plt.plot(times, r_mean,  marker='o', linestyle='-',  label='Reference')
            plt.plot(times, t_mean,  marker='o', linestyle='--', label='Test')
            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0,101,5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('fda_dissolution_curves.png', dpi=300)
            plt.show()
            plt.close()

            # --- Graph 2: Curves with min/max intervals ---
            r_min = ref_trim.iloc[:,1:].min(axis=1)
            r_max = ref_trim.iloc[:,1:].max(axis=1)
            t_min = test_trim.iloc[:,1:].min(axis=1)
            t_max = test_trim.iloc[:,1:].max(axis=1)

            plt.figure(figsize=(12,6))
            plt.errorbar(
                times, r_mean,
                yerr=[r_mean - r_min, r_max - r_mean],
                fmt='o-', label='Reference Mean'
            )
            plt.errorbar(
                times, t_mean,
                yerr=[t_mean - t_min, t_max - t_mean],
                fmt='s--', label='Test Mean'
            )
            for t, mn, mx in zip(times, r_min, r_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)
            for t, mn, mx in zip(times, t_min, t_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)

            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves with Intervals')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0,101,5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('fda_dissolution_curves_with_intervals.png', dpi=300)
            plt.show()
            plt.close()

        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA‑rule f2 calculation.")
