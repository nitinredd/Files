import numpy as np
import math

def predictive_optimal_combinations_targeted(ref_df, test_df, regulation,
                                             window_max, step_hours=0.25):
    """
    1. Build a uniform grid from 0 to window_max in step_hours.
    2. Always include t=0 (0% dissolution; excluded from f2 calc).
    3. For each dissolution stratum (0–30, 30–60, 60–90):
         • Compute two “target” %’s at 1/3 and 2/3 through the stratum.
         • Pick the grid times whose ref_pred is closest to those targets.
    4. Append one “regulatory extra” point after the last candidate:
         – FDA/ANVISA: first time where both ref & test ≥85%
         – EMA/China/ASEAN: first time where either ref or test ≥85%
    5. Compute f2 excluding the 0-h point.
    """
    # 1) Grid + interpolation
    valid_times   = np.arange(0.0, window_max + 1e-8, step_hours)
    ref_pred      = np.array(interpolate_linear(ref_df,  valid_times), dtype=float)
    test_pred     = np.array(interpolate_linear(test_df, valid_times), dtype=float)

    # 2) Always include zero
    candidate = {0.0}

    # 3) Bracket picks at 1/3 and 2/3 dissolution
    for low, high in [(0,30), (30,60), (60,90)]:
        span = high - low
        targets = [low + span/3, low + 2*span/3]
        for tgt in targets:
            idx = int(np.argmin(np.abs(ref_pred - tgt)))
            candidate.add(round(valid_times[idx], 3))

    # 4) Regulatory extra after last candidate
    last = max(candidate)
    post = valid_times[valid_times > last]
    extra = None
    if regulation in ("FDA", "ANVISA"):
        for t in post:
            i = int(np.where(valid_times == t)[0][0])
            if ref_pred[i] >= 85 and test_pred[i] >= 85:
                extra = t
                break
    else:
        for t in post:
            i = int(np.where(valid_times == t)[0][0])
            if ref_pred[i] >= 85 or test_pred[i] >= 85:
                extra = t
                break
    if extra is not None:
        candidate.add(round(extra, 3))

    # 5) Compute f2 (excluding t=0)
    seq     = sorted(candidate)
    idxs    = [int(np.where(valid_times == t)[0][0]) for t in seq]
    r_vals  = ref_pred[idxs].copy()
    t_vals  = test_pred[idxs].copy()
    r_vals[0] = t_vals[0] = 0.0
    diffs   = t_vals[1:] - r_vals[1:]
    mse     = np.mean(diffs**2)
    f2      = 50 * math.log10(100 / (1 + math.sqrt(mse)))

    return [{
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  [float(v) for v in r_vals],
        'test_vals': [float(v) for v in t_vals],
    }], None
############################################################
if input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Criteria & CV
    both_85 = check_both_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:   ", both_85)
    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # Drop t=0 rows from raw data
    reference_df = reference_df[reference_df.iloc[:,0] != 0].reset_index(drop=True)
    test_df      = test_df[test_df.iloc[:,0] != 0].reset_index(drop=True)

    # 2) FDA conventional f2
    if not check_same_time_points(reference_df, test_df):
        print("Error: time points do not match. Cannot proceed.")
    else:
        try:
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)
            # … (your existing trimmed‐data printing/plots) …
        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA‐rule f2 calculation.")

    # 3) Predictive analysis?
    run_predictive = input("\nDo you want to run predictive optimal combination analysis? (yes/no): ")
    if run_predictive.lower() == 'yes':
        window_min, window_max = determine_candidate_window(
            reference_mean_df, test_mean_df,
            step=5, initial_threshold=10
        )
        regulation_map     = {1:"FDA",2:"EMA",3:"China",4:"ASEAN",5:"ANVISA"}
        selected_regulation = regulation_map.get(input1, "FDA")
        print(f"\nCandidate window: {window_min} to {window_max}\n")

        # Try original; on failure, use targeted‐bracket method
        try:
            results, _ = predictive_optimal_combinations_advanced(
                reference_mean_df,
                test_mean_df,
                regulation         = selected_regulation,
                window_min         = window_min,
                window_max         = window_max,
                diff_threshold     = None,
                interp_method      = 'linear',
                points_per_stratum = None
            )
            print("✅ Used original integer‐grid function\n")
        except ValueError as e:
            print(f"⚠️  Original function failed: {e}")
            print("   Falling back to targeted‐bracket selection...\n")
            results, _ = predictive_optimal_combinations_targeted(
                reference_mean_df,
                test_mean_df,
                selected_regulation,
                window_max,
                step_hours=0.25
            )

        # Normalize sequence values
        for cand in results:
            cand['sequence'] = [
                int(t) if float(t).is_integer() else t
                for t in cand['sequence']
            ]

        best = results[0]
        print("=== Optimal Predictive Combination ===")
        print(f"Time Points: {best['sequence']}")
        print(f"Predicted f2 Score: {best['f2']}")

        # Plot predicted dissolution curves
        import matplotlib.pyplot as plt
        from matplotlib.ticker import MaxNLocator

        seq      = best['sequence']
        ref_diss = interpolate_dissolution_curve(reference_mean_df, np.array(seq), method='linear')
        test_diss= interpolate_dissolution_curve(test_mean_df,      np.array(seq), method='linear')

        # force 0% at start for plotting
        ref_diss[0] = test_diss[0] = 0.0

        plt.figure(figsize=(12, 6))
        plt.plot(seq, ref_diss,  'bo-', label='Reference')
        plt.plot(seq, test_diss, 'r*--', label='Test')
        plt.title(f"Optimal Profile (f2 = {best['f2']})")
        plt.xlabel('Time (h)')
        plt.ylabel('Dissolution (%)')
        plt.grid(True)
        plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True))
        plt.legend()
        plt.show()

        # Print predicted percentages
        print("\nPredicted Reference Dissolution (%):")
        for t, d in zip(seq, ref_diss):
            print(f"  {t} h: {d:.2f}%")
        print("\nPredicted Test Dissolution (%):")
        for t, d in zip(seq, test_diss):
            print(f"  {t} h: {d:.2f}%")

        # Print all candidates
        print("\n=== All Candidate Combinations ===")
        for i, cand in enumerate(results, 1):
            pts = cand['sequence']
            print(f"{i:2d}. Points: {pts} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
