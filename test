import os
import streamlit as st
import tempfile
import logging
from io import BytesIO
import json
import google.auth
from vertexai.preview.generative_models import GenerativeModel, Image as GeminiImage
import fitz  # PyMuPDF
from xhtml2pdf import pisa

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Set up Vertex AI
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()
multimodal_model = GenerativeModel("gemini-pro-vision")

def get_layout_analysis_prompt():
    return """Analyze this image and extract content while preserving the exact original layout.
    Follow these strict rules:

    1. Only identify ACTUAL tables (content organized in rows and columns with cells)
       - Do not treat regular text or lists as tables
       - Only mark something as a table if it has clear cells, rows, and columns
    
    2. For all other content:
       - Preserve it as regular text
       - Maintain the original indentation and formatting
       - Keep section numbers and headers as plain text
    
    Return the result in this exact JSON format:
    {
        "elements": [
            {
                "type": "text",
                "content": "exact text content",
                "indentation": number_of_spaces,
                "is_header": boolean
            },
            {
                "type": "table",
                "position": "after_text_content_X", // Reference to preceding text
                "content": [
                    ["header1", "header2"],
                    ["cell1", "cell2"]
                ]
            }
        ]
    }
    
    Only return the JSON object, nothing else.
    Preserve ALL original formatting, spacing, and structure."""

def translate_text(text, language):
    if not text:
        return ""
    
    prompt = f"""Translate the following {language} text to English. 
    Preserve exactly:
    - All numbers and identifiers
    - All formatting and spacing
    - All technical terms
    
    Original text:
    {text}
    
    Provide only the translation, no additional text."""
    
    responses = multimodal_model.generate_content([prompt])
    translated_text = responses.text if hasattr(responses, 'text') else ''.join([response.text for response in responses])
    return translated_text

def extract_images_from_pdf(pdf_file):
    images = []
    temp_pdf_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_pdf:
            temp_pdf.write(pdf_file.getvalue())
            temp_pdf_path = temp_pdf.name
        
        doc = fitz.open(temp_pdf_path)
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))  # Increased resolution
            image_bytes = pix.tobytes("png")
            images.append(image_bytes)
            logger.info(f"Extracted image from page {page_num}")
        
        doc.close()
        return images
    finally:
        if temp_pdf_path and os.path.exists(temp_pdf_path):
            try:
                os.unlink(temp_pdf_path)
            except Exception as e:
                logger.error(f"Error deleting temporary PDF file: {str(e)}")

def parse_gemini_response(response):
    try:
        # First try to parse as direct JSON
        try:
            return json.loads(response.text)
        except:
            pass
        
        # If that fails, try to extract JSON from the text
        text = response.text if hasattr(response, 'text') else ''.join([r.text for r in response])
        start = text.find('{')
        end = text.rfind('}') + 1
        if start >= 0 and end > start:
            json_str = text[start:end]
            return json.loads(json_str)
        
        # If still no valid JSON, create structured format from text
        return {
            "elements": [
                {
                    "type": "text",
                    "content": text,
                    "indentation": 0,
                    "is_header": False
                }
            ]
        }
    except Exception as e:
        logger.error(f"Error parsing Gemini response: {str(e)}")
        return {
            "elements": [
                {
                    "type": "text",
                    "content": str(response.text),
                    "indentation": 0,
                    "is_header": False
                }
            ]
        }

def get_gemini_response(image):
    prompt = get_layout_analysis_prompt()
    response = multimodal_model.generate_content([image, prompt])
    return parse_gemini_response(response)

def convert_to_html(layout_data):
    html_content = """
    <html>
    <head>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                margin: 20px;
                line-height: 1.6;
            }
            .text-content {
                white-space: pre-wrap;
                margin: 8px 0;
            }
            .header {
                font-weight: bold;
                margin-top: 16px;
            }
            table { 
                border-collapse: collapse; 
                width: 100%;
                margin: 16px 0;
            }
            th, td { 
                border: 1px solid #ddd; 
                padding: 8px; 
                text-align: left; 
            }
            th { 
                background-color: #f2f2f2; 
            }
        </style>
    </head>
    <body>
    """
    
    for element in layout_data.get('elements', []):
        if element['type'] == 'text':
            style = f"margin-left: {element['indentation'] * 20}px"
            classes = ['text-content']
            if element.get('is_header'):
                classes.append('header')
            
            html_content += f'<div class="{" ".join(classes)}" style="{style}">{element["content"]}</div>'
            
        elif element['type'] == 'table':
            html_content += "<table>"
            for i, row in enumerate(element['content']):
                html_content += "<tr>"
                for cell in row:
                    tag = "th" if i == 0 else "td"
                    html_content += f"<{tag}>{cell}</{tag}>"
                html_content += "</tr>"
            html_content += "</table>"
    
    html_content += "</body></html>"
    return html_content

def create_pdf_from_html(html_content):
    pdf_buffer = BytesIO()
    pisa.CreatePDF(
        BytesIO(html_content.encode('utf-8')),
        dest=pdf_buffer,
        encoding='utf-8'
    )
    pdf_buffer.seek(0)
    return pdf_buffer

def process_image(image_data, language):
    try:
        # Extract layout and content
        layout_data = get_gemini_response(image_data)
        
        # Translate each element while preserving structure
        translated_data = {"elements": []}
        for element in layout_data.get('elements', []):
            if element['type'] == 'table':
                # Translate each cell in the table
                translated_table = []
                for row in element['content']:
                    translated_row = [translate_text(cell, language) for cell in row]
                    translated_table.append(translated_row)
                translated_data['elements'].append({
                    "type": "table",
                    "position": element.get('position', ''),
                    "content": translated_table
                })
            else:
                # Translate text while preserving formatting
                translated_content = translate_text(element['content'], language)
                translated_data['elements'].append({
                    "type": "text",
                    "content": translated_content,
                    "indentation": element.get('indentation', 0),
                    "is_header": element.get('is_header', False)
                })
        
        return translated_data
    except Exception as e:
        logger.error(f"Error processing image: {str(e)}")
        raise

def main():
    st.title("Document Translator - Chinese & Japanese to English")
    
    option = st.selectbox("Upload a PDF or an Image?", ["PDF", "Image"])
    
    if option == "PDF":
        uploaded_file = st.file_uploader("Upload PDF", type="pdf")
    else:
        uploaded_file = st.file_uploader("Upload Your Image", type=["png", "jpg", "jpeg"])
    
    language = st.selectbox("Select language for translation", ["Chinese", "Japanese"])
    
    if st.button("Submit"):
        if uploaded_file:
            try:
                if option == "PDF":
                    with st.spinner('Processing PDF...'):
                        images = extract_images_from_pdf(uploaded_file)
                        
                        if not images:
                            st.error("No images could be extracted from the PDF.")
                            return
                        
                        all_translated_data = {"elements": []}
                        progress_bar = st.progress(0)
                        
                        for idx, img_data in enumerate(images):
                            image = GeminiImage.from_bytes(img_data)
                            translated_data = process_image(image, language)
                            all_translated_data['elements'].extend(translated_data['elements'])
                            progress_bar.progress((idx + 1) / len(images))
                        
                        # Convert to HTML and PDF
                        html_content = convert_to_html(all_translated_data)
                        pdf_buffer = create_pdf_from_html(html_content)
                        
                        # Offer download
                        st.download_button(
                            label="Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                
                else:  # Single image
                    with st.spinner('Processing image...'):
                        st.image(uploaded_file, caption='Uploaded Image', use_column_width=True)
                        image = GeminiImage.from_bytes(uploaded_file.getvalue())
                        
                        # Process the image
                        translated_data = process_image(image, language)
                        
                        # Show preview
                        st.subheader("Translation Preview")
                        html_preview = convert_to_html(translated_data)
                        st.markdown(html_preview, unsafe_allow_html=True)
                        
                        # Convert to PDF
                        pdf_buffer = create_pdf_from_html(html_preview)
                        
                        # Offer download
                        st.download_button(
                            label="Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
            
            except Exception as e:
                logger.error(f"Error in processing: {str(e)}")
                st.error(f"An error occurred: {str(e)}")
        else:
            st.error("Please upload a file to proceed.")

if __name__ == "__main__":
    main()
