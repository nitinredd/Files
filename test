import numpy as np

def calculate_f2_either85(reference_df, test_df):
    """
    1. Keep time 0.
    2. Find the first non‑zero timepoint where either mean(reference) or mean(test) > 85%.
    3. Trim both DataFrames to include rows [0 .. that timepoint].
    4. Compute:
         - f2_conv: conventional f2
         - exp_f2 : expected f2 (variance‑adjusted)
    Returns:
       f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
    """
    # 1) Extract times & means
    times     = reference_df.iloc[:, 0].astype(float).values
    ref_mean  = reference_df.iloc[:, 1:].mean(axis=1).values
    test_mean = test_df.iloc[:, 1:].mean(axis=1).values

    # 2) Find cutoff index
    cutoff = next((i for i in range(1, len(times))
                   if ref_mean[i] > 85 or test_mean[i] > 85),
                  None)
    if cutoff is None:
        raise ValueError("Neither profile exceeds 85% at any non‑zero timepoint.")

    # 3) Trim full DataFrames
    trimmed_ref_df  = reference_df.iloc[:cutoff+1].copy()
    trimmed_test_df = test_df.iloc[:cutoff+1].copy()

    # Force 0% at t=0
    if float(trimmed_ref_df.iloc[0, 0]) == 0:
        trimmed_ref_df.iloc[0, 1:]  = 0.0
        trimmed_test_df.iloc[0, 1:] = 0.0

    # 4a) conventional f2
    diff    = (trimmed_test_df.iloc[:,1:].mean(axis=1).values
             - trimmed_ref_df.iloc[:,1:].mean(axis=1).values)
    p       = len(diff)
    sum_sq  = np.sum(diff**2)
    f2_conv = 100 - 25 * np.log10(1 + sum_sq / p)

    # 4b) expected f2
    var_ref   = trimmed_ref_df.iloc[:,1:].var(axis=1, ddof=1).values
    var_test  = trimmed_test_df.iloc[:,1:].var(axis=1, ddof=1).values
    avg_var   = np.mean(var_ref + var_test)
    exp_f2    = 100 - 25 * np.log10(1 + (sum_sq + p * avg_var) / p)

    return f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
###########################################################
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

elif input1 == 2:
    print("According to EMA/ICH/Canada/Australia guidelines")

    # 1) CV check
    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("CV <20 at first non-zero, <10 thereafter:", cv_check)

    # 2) Verify time alignment
    if not check_same_time_points(test_df, reference_df):
        print("Error: Time points between test and reference do not match.")
    else:
        print("\nAnalysis based on ‘either >85%’ dissolution criterion:")
        try:
            # Compute f2s and get trimmed DataFrames
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_either85(reference_df, test_df)

            # Print results
            print(f"Conventional f2: {f2_conv:.2f}")
            print(f"Expected    f2: {f2_exp:.2f}")

            if not cv_check:
                print("\nWarning: CV requirements not met; interpret with caution.")

            # --- Graph 1: Simple dissolution curves ---
            times      = ref_trim.iloc[:, 0].astype(float)
            ref_means  = ref_trim.iloc[:, 1:].mean(axis=1)
            test_means = test_trim.iloc[:, 1:].mean(axis=1)

            plt.figure(figsize=(12, 6))
            plt.plot(times, ref_means,  marker='o', linestyle='-',  label='Reference')
            plt.plot(times, test_means, marker='o', linestyle='--', label='Test')
            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0, 101, 5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('dissolution_curves.png', dpi=300)
            plt.show()
            plt.close()

            # --- Graph 2: Curves with min/max intervals ---
            ref_min  = ref_trim.iloc[:, 1:].min(axis=1)
            ref_max  = ref_trim.iloc[:, 1:].max(axis=1)
            test_min = test_trim.iloc[:, 1:].min(axis=1)
            test_max = test_trim.iloc[:, 1:].max(axis=1)

            plt.figure(figsize=(12, 6))
            # Reference with error bars
            plt.errorbar(
                times,
                ref_means,
                yerr=[ref_means - ref_min, ref_max - ref_means],
                fmt='o-',
                label='Reference Mean'
            )
            # Test with error bars
            plt.errorbar(
                times,
                test_means,
                yerr=[test_means - test_min, test_max - test_means],
                fmt='s--',
                label='Test Mean'
            )
            # Horizontal caps for min/max
            for t, mn, mx in zip(times, ref_min, ref_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)
            for t, mn, mx in zip(times, test_min, test_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)

            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves with Intervals')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0, 101, 5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('dissolution_curves_with_intervals.png', dpi=300)
            plt.show()
            plt.close()

        except ValueError as e:
            print("❌", e)
            print("Cannot perform ‘either >85%’–based f2 calculation.")
