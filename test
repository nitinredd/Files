# Display final results
if overall_best:
    print("\n=== Optimal Predictive Combination ===")
    print(f"Condition: {overall_best.get('condition','N/A')}")
    print(f"Dissolution Range: {overall_best['diss_range']}")
    print(f"Time Points (3/5 min intervals): {overall_best['sequence']}")
    print(f"Length: {len(overall_best['sequence'])}")
    print(f"Predicted f2 Score: {overall_best['f2']}")

    # Compute predicted dissolution percentages for the optimal sequence
    optimal_sequence = overall_best['sequence']
    ref_diss_pred = interpolate_dissolution_curve(reference_mean_df, optimal_sequence, method='gpr')
    test_diss_pred = interpolate_dissolution_curve(test_mean_df, optimal_sequence, method='gpr')

    # Print the predicted dissolution percentages
    print(f"Predicted Reference Dissolution: {ref_diss_pred}")
    print(f"Predicted Test Dissolution: {test_diss_pred}")
    
    if overall_best['reasons']:
        print(f"Compliance Issues: {', '.join(overall_best['reasons'])}")
    else:
        print("Regulatory Compliance: Passed")
    
    # Print range statistics using unique candidates
    print_range_stats(unique_candidates)
    
    # Plot results
    plt.figure(figsize=(12, 6))
    time_points = overall_best['sequence']
    # (Re-use the computed predicted values for plotting)
    plt.plot(time_points, ref_diss_pred, 'bo-', label='Reference')
    plt.plot(time_points, test_diss_pred, 'r*--', label='Test')
    plt.title(f"Optimal Profile: {overall_best['diss_range']} Dissolution (f2 = {overall_best['f2']})")
    plt.xlabel('Time (min)')
    plt.ylabel('Dissolution (%)')
    plt.legend()
    plt.grid(True)
    plt.show()
else:
    print("‚ùå No valid combinations found across all dissolution ranges")
