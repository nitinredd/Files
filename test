// src/App.jsx
import React, { useEffect, useState, useRef } from "react";
import { motion } from "framer-motion";

import ChatWindow from "./components/ChatWindow";
import ProductTabs from "./components/ProductTabs";
import ProductDetailModal from "./components/ProductDetailModal";
import SidebarHistory from "./components/SidebarHistory";
import ReactionTiles from "./components/ReactionTiles";
import PromptGallery from "./components/PromptGallery";

import {
  fetchReactions,
  fetchPrompts,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  queryWithCitations,
  uploadFile,
} from "./api";

import Navbar from "./Navbar/Navbar";
import Footer from "./Footer/Footer";

import chem_logo from "../assets/Chemhub_Logo_Colored.png";

export default function App() {
  // Global app state
  const [reactions, setReactions] = useState([]);
  const [prompts, setPrompts] = useState([]);

  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);

  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);

  const [detailModalOpen, setDetailModalOpen] = useState(false);

  const [messages, setMessages] = useState([]); // chat messages
  const [history, setHistory] = useState([]); // conversation history list

  // Loading state flags
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [queryLoading, setQueryLoading] = useState(false);

  // Selected citations (right-click / multi-select)
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);

  // For scheme preview in chat
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  // Prompt Gallery modal state
  const [promptGalleryOpen, setPromptGalleryOpen] = useState(false);

  // Refs
  const chatWindowRef = useRef(null);

  // Initialize reactions and prompts on mount
  useEffect(() => {
    fetchReactions()
      .then((r) => setReactions(r || []))
      .catch((e) => console.error("fetchReactions error:", e));

    fetchPrompts()
      .then((p) => setPrompts(p?.prompts || p || []))
      .catch((e) => console.warn("fetchPrompts failed:", e));

    // onboarding message
    setMessages([
      {
        role: "assistant",
        content:
          "Welcome — type a reaction or product name to find documents, or ask a question directly. Use the Prompt Gallery for ready-made prompts.",
      },
    ]);
  }, []);

  // message utilities
  const pushMessage = (m) => setMessages((prev) => [...prev, m]);

  // normalize helper
  const normalize = (s) => (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");

  // === Product selection flow ===
  const handleSelectProduct = async (productId) => {
    try {
      setLoadingDetails(true);
      const meta = await fetchProductMeta(productId);
      setSelectedProduct(meta);
      setProductDetails(null);
      setSelectedSchemeUrl(null);
      setDetailModalOpen(true);

      // preload scheme image
      try {
        const schemeUrl = await fetchSchemeImageUrl(productId);
        setSelectedSchemeUrl(schemeUrl);
      } catch (e) {
        // ignore if not available
      }

      // fetch canonical extraction for the product (no question arg -> extraction)
      const res = await fetchProductDetails(productId);
      const payload = res?.data ?? res;
      setProductDetails(payload);

      // add to history
      setHistory((h) => [
        { title: meta.name, content: payload?.procedure ? payload.procedure.slice(0, 120) : "", productId: meta.id },
        ...h,
      ]);
    } catch (err) {
      console.error("handleSelectProduct error:", err);
      pushMessage({ role: "assistant", content: "Failed to load product details." });
    } finally {
      setLoadingDetails(false);
    }
  };

  // toggle citation (right-click)
  const handleToggleCite = (product) => {
    const exists = selectedCitedDocs.find((p) => p.id === product.id);
    if (exists) {
      setSelectedCitedDocs((prev) => prev.filter((p) => p.id !== product.id));
      pushMessage({ role: "assistant", content: `Removed citation: ${product.name}` });
    } else {
      setSelectedCitedDocs((prev) => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: "assistant", content: `Added citation: ${product.name}` });
    }
  };

  const removeCitation = (id) => {
    const found = selectedCitedDocs.find((d) => d.id === id);
    setSelectedCitedDocs((prev) => prev.filter((d) => d.id !== id));
    if (found) pushMessage({ role: "assistant", content: `Removed citation: ${found.name}` });
  };

  // === Upload (file) ===
  // The ChatWindow component provides the "+" file input and will call this onUploadFile(file)
  const handleUploadFile = async (file) => {
    if (!file) return;
    try {
      pushMessage({ role: "assistant", content: `Uploading ${file.name}...` });
      const form = new FormData();
      form.append("file", file);
      // You can optionally allow the UI to pick reaction_type; default to "Miscellaneous"
      form.append("reaction_type", "Miscellaneous");
      const resp = await uploadFile(form); // expects backend /upload
      pushMessage({ role: "assistant", content: `Upload complete: ${file.name}` });
      // Optionally refresh product list if user wants
      // If your upload endpoint stored file under Products/<reaction>, it will show in fetchProducts for that reaction
    } catch (err) {
      console.error("uploadFile error:", err);
      pushMessage({ role: "assistant", content: "File upload failed." });
    }
  };

  // === Prompt gallery handlers ===
  const openPromptGallery = () => setPromptGalleryOpen(true);
  const closePromptGallery = () => setPromptGalleryOpen(false);

  const handlePromptPick = async (promptText, sendImmediately = true) => {
    // By default send immediately. If you'd prefer to populate the input instead,
    // you can change sendImmediately=false and use chatWindowRef to set input.
    closePromptGallery();
    if (sendImmediately) {
      await handleUserSend(promptText);
    } else {
      // populate chat input if ChatWindow exposes a method via ref
      if (chatWindowRef.current && typeof chatWindowRef.current.setInput === "function") {
        chatWindowRef.current.setInput(promptText);
      }
    }
  };

  // === Main user-send handler ===
  const handleUserSend = async (text) => {
    pushMessage({ role: "user", content: text });

    // 1) If text is exactly a reaction name, list products
    const norm = normalize(text);
    const match = reactions.find((r) => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g, "_")));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        pushMessage({ role: "assistant", content: `Found ${prods.length} product${prods.length === 1 ? "" : "s"} — pick one below.` });
      } catch (e) {
        console.error("fetchProducts error:", e);
        pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
      }
      return;
    }

    // 2) If user has selected citations, query across them via /query
    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      setQueryLoading(true);
      // show temporary loading message (we'll add final message after)
      pushMessage({ role: "assistant", content: "Searching selected documents...", loading: true });
      try {
        const ids = selectedCitedDocs.map((d) => d.id);
        const res = await queryWithCitations(ids, text);
        const payload = res?.data ?? res;
        // remove the loading placeholder (the last message with loading:true)
        setMessages((prev) => {
          const idx = [...prev].reverse().findIndex((m) => m.loading);
          if (idx >= 0) {
            const realIdx = prev.length - 1 - idx;
            const copy = [...prev];
            copy.splice(realIdx, 1);
            return copy;
          }
          return prev;
        });
        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        const sources = payload?.sources || [];
        pushMessage({ role: "assistant", content: answer, sources });
      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: "assistant", content: "Error querying selected documents." });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    // 3) If no selected product, call backend /product/details WITHOUT product_id
    // backend will try to detect a product name in free-text; if short greeting -> generative LLM
    setQueryLoading(true);
    pushMessage({ role: "assistant", content: "Searching documents...", loading: true });
    try {
      const res = await fetchProductDetails(undefined, text); // backend handles detection/generative
      const payload = res?.data ?? res;

      // remove loading placeholder
      setMessages((prev) => {
        const idx = [...prev].reverse().findIndex((m) => m.loading);
        if (idx >= 0) {
          const realIdx = prev.length - 1 - idx;
          const copy = [...prev];
          copy.splice(realIdx, 1);
          return copy;
        }
        return prev;
      });

      // Handle different payload shapes:
      if (payload && payload.api_name) {
        // structured extraction result
        let summary = "";
        if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
        if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
        if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
        if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
        pushMessage({ role: "assistant", content: summary, tables: payload.tables || [] });
      } else if (payload && (payload.answer || payload.response || payload.response_text)) {
        // retrieval or generative response
        const answer = payload.answer || payload.response || payload.response_text;
        const sources = payload.sources || [];
        pushMessage({ role: "assistant", content: answer, sources });
      } else {
        // fallback
        pushMessage({ role: "assistant", content: payload?.response || payload?.answer || "No answer found." });
      }
    } catch (err) {
      console.error("fetchProductDetails (no product) error:", err);
      pushMessage({ role: "assistant", content: "Error querying documents." });
    } finally {
      setQueryLoading(false);
    }
  };

  // Reaction tile click -> fetch products
  const handleReactionClick = async (reactionName) => {
    setSelectedReaction(reactionName);
    try {
      const prods = await fetchProducts(reactionName);
      setProducts(prods || []);
      setProductListVisible(true);
      pushMessage({ role: "assistant", content: `Found ${prods.length} products for ${reactionName}` });
    } catch (e) {
      console.error("fetchProducts error:", e);
      pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
    }
  };

  // === UI: render ===
  return (
    <>
      <Navbar />

      <div className="min-h-screen bg-gradient-to-b from-bg to-white flex justify-center">
        <div className="w-full max-w-7xl py-8 px-4">
          {/* Header */}
          <div className="flex items-center justify-between mb-6 gap-4">
            <div className="flex items-center gap-4">
              <img src={chem_logo} alt="logo" className="h-14 w-auto" />
              <div>
                <h1 className="text-2xl font-extrabold text-gray-900">Reaction Database AI</h1>
                <div className="text-sm text-gray-500">Search, extract and explore reaction documents</div>
              </div>
            </div>

            {/* intentionally removed top-right upload — file upload is inside chat bar as "+" */}
            <div className="text-sm text-gray-400">Signed in as Demo</div>
          </div>

          {/* Reaction tiles (visual, clickable) */}
          <div className="mb-6">
            <ReactionTiles reactions={reactions} onSelect={handleReactionClick} />
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Left and center: chat + prompt gallery */}
            <div className="lg:col-span-2">
              <ChatWindow
                ref={chatWindowRef}
                messages={messages}
                onSend={handleUserSend}
                centeredWidth="w-full"
                loading={queryLoading || loadingDetails}
                selectedSchemeUrl={selectedSchemeUrl}
                selectedProduct={selectedProduct}
                onUploadFile={handleUploadFile}       /* upload plus button inside chat */
                openPromptGallery={() => setPromptGalleryOpen(true)} /* opens gallery modal */
                selectedCitedDocs={selectedCitedDocs}
                removeCitation={removeCitation}
              />

              {/* NOTE: Prompt gallery button is also inside ChatWindow; we also show a modal here */}
              <PromptGallery
                open={promptGalleryOpen}
                onClose={() => setPromptGalleryOpen(false)}
                prompts={prompts}
                onPick={(p) => handlePromptPick(p.prompt || p)}
                // prompts are objects like {title,prompt} from /prompt-gallery
              />
            </div>

            {/* Right column: matched products and history */}
            <div className="lg:col-span-1 space-y-4">
              {productListVisible && (
                <div className="bg-white p-4 rounded-2xl shadow">
                  <h3 className="text-lg font-semibold mb-2">Matched Products</h3>
                  <ProductTabs
                    products={products}
                    onSelect={(id) => handleSelectProduct(id)}
                    onContext={(product) => handleToggleCite(product)} // right-click handler
                    citedIds={new Set(selectedCitedDocs.map((d) => d.id))}
                  />
                </div>
              )}

              <div className="bg-white p-4 rounded-2xl shadow">
                <h3 className="text-lg font-semibold mb-2">Recent & Saved</h3>
                <SidebarHistory
                  history={history}
                  onSelect={(h) => {
                    if (h && h.productId) handleSelectProduct(h.productId);
                  }}
                />
              </div>
            </div>
          </div>

          {/* Detail modal */}
          <ProductDetailModal
            open={detailModalOpen}
            onClose={() => setDetailModalOpen(false)}
            meta={selectedProduct}
            details={productDetails}
            loading={loadingDetails}
          />
        </div>
      </div>

      <Footer />
    </>
  );
}
