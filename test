// src/components/Chatbot.jsx

import React, { useState, useRef, useEffect } from 'react'
import axios from 'axios'
import './Chatbot.css'

export default function Chatbot({ apiBase }) {
  const [open, setOpen] = useState(false)
  const [tiles, setTiles] = useState({})
  const [selectedTile, setSelectedTile] = useState(null)
  const [messages, setMessages] = useState([])
  const [input, setInput] = useState('')
  const [recording, setRecording] = useState(false)
  const mediaRecorderRef = useRef(null)
  const audioChunksRef = useRef([])
  const messagesEndRef = useRef(null)

  // 1. Load sampleâ€‘prompt tiles
  useEffect(() => {
    axios.get(`${apiBase}/sample-tiles`)
      .then(res => setTiles(res.data))
      .catch(err => console.error("Failed to load tiles:", err))
  }, [apiBase])

  // 2. When opened, send greeting + list tile names
  useEffect(() => {
    if (open && messages.length === 0 && Object.keys(tiles).length > 0) {
      setMessages([
        { from: 'bot', text: 'Hi! How can I help?' },
        { from: 'bot', options: Object.keys(tiles) }
      ])
    }
  }, [open, tiles, messages.length])

  // 3. Autoâ€‘scroll on new message
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  // 4. Send a text query to /chat
  const sendText = async (text) => {
    setMessages(m => [...m, { from: 'user', text }])
    setInput('')
    try {
      const res = await axios.post(`${apiBase}/chat`, { message: text })
      setMessages(m => [...m, { from: 'bot', text: res.data.response }])
    } catch (err) {
      console.error("Chat error:", err)
      setMessages(m => [...m, { from: 'bot', text: 'Server error.' }])
    }
  }

  // 5. Handle tile name click
  const onTileClick = (tile) => {
    setSelectedTile(tile)
    setMessages(m => [...m, { from: 'user', text: tile }])
    setMessages(m => [...m, { from: 'bot', options: tiles[tile] }])
  }

  // 6. Handle option under a tile
  const onOptionClick = (opt) => {
    sendText(opt)
    setSelectedTile(null)
  }

  // 7. Start voice recording
  const startRecording = async () => {
    setRecording(true)
    audioChunksRef.current = []
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const mr = new MediaRecorder(stream)
      mediaRecorderRef.current = mr
      mr.ondataavailable = e => audioChunksRef.current.push(e.data)
      mr.start()
    } catch (err) {
      console.error("Microphone access error:", err)
      setRecording(false)
    }
  }

  // 8. Stop recording and upload for STT
  const stopRecording = () => {
    if (!mediaRecorderRef.current) return
    mediaRecorderRef.current.stop()
    mediaRecorderRef.current.onstop = async () => {
      setRecording(false)
      const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' })
      const form = new FormData()
      form.append('file', blob, 'voice.webm')
      try {
        const sttRes = await axios.post(
          `${apiBase}/speech-to-text`,
          form,
          { headers: { 'Content-Type': 'multipart/form-data' } }
        )
        const text = sttRes.data.text
        sendText(text)
      } catch (err) {
        console.error("STT error:", err)
        setMessages(m => [...m, { from: 'bot', text: 'Voiceâ€‘toâ€‘text failed.' }])
      }
    }
  }

  // 9. Play TTS for bot messages
  const playAudio = async (text) => {
    try {
      const audioRes = await axios.get(
        `${apiBase}/text-to-speech`,
        { params: { text }, responseType: 'blob' }
      )
      const url = URL.createObjectURL(audioRes.data)
      new Audio(url).play()
    } catch (err) {
      console.error("TTS error:", err)
    }
  }

  return (
    <div
      className={`chatbot-widget ${open ? 'open' : ''}`}
      style={{ backgroundImage: `url('/chat-widget-bg.png')` }}
    >
      <div className="chat-header" onClick={() => setOpen(o => !o)}>
        {open ? 'â€“â€“' : 'ğŸ’¬'}
      </div>

      {open && (
        <div className="chat-body">
          <div className="messages">
            {messages.map((m, i) => (
              m.options
                ? (
                  <div key={i} className="bot-options">
                    {m.options.map((opt, j) => (
                      <button key={j} onClick={() => onOptionClick(opt)}>
                        {opt}
                      </button>
                    ))}
                  </div>
                )
                : (
                  <div key={i} className={m.from}>
                    {m.text}
                    {m.from === 'bot' && (
                      <button
                        className="read-button"
                        onClick={() => playAudio(m.text)}
                      >ğŸ”Š</button>
                    )}
                  </div>
                )
            ))}
            <div ref={messagesEndRef} />
          </div>

          <div className="chat-input">
            <button
              className={`mic-button ${recording ? 'recording' : ''}`}
              onMouseDown={startRecording}
              onMouseUp={stopRecording}
            >ğŸ™ï¸</button>

            <input
              type="text"
              value={input}
              onChange={e => setInput(e.target.value)}
              onKeyDown={e => {
                if (e.key === 'Enter' && input.trim()) {
                  sendText(input)
                }
              }}
              placeholder="Type your questionâ€¦"
            />

            <button
              disabled={!input.trim()}
              onClick={() => sendText(input)}
            >Send</button>
          </div>
        </div>
      )}
    </div>
  )
}
