import fitz
import pytesseract
from PIL import Image
import numpy as np
import cv2
from docx import Document
from docx.shared import Cm
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx2pdf import convert
from tqdm import tqdm
from pathlib import Path
import os
import logging


class RobustDocumentConverter:
    def __init__(self, input_path, output_path, output_format='docx', dpi=300):
        self.input_path = input_path
        self.output_path = output_path
        self.output_format = output_format.lower()
        self.dpi = dpi
        self.doc = Document()
        self.setup_logging()
        self.setup_document()

    def setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('conversion.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def setup_document(self):
        """Initialize document settings"""
        style = self.doc.styles['Normal']
        style.font.name = 'Yu Gothic'
        style._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')
        sections = self.doc.sections
        for section in sections:
            section.left_margin = Cm(2.54)
            section.right_margin = Cm(2.54)
            section.top_margin = Cm(2.54)
            section.bottom_margin = Cm(2.54)

    def detect_tables(self, image):
        """Improved table detection using OpenCV"""
        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)

        # Detect horizontal and vertical lines
        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40, 1))
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 40))

        horizontal_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel)
        vertical_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel)

        # Combine lines to detect tables
        combined_mask = cv2.addWeighted(horizontal_lines, 1, vertical_lines, 1, 0)
        contours, _ = cv2.findContours(combined_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        table_coordinates = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            if w > 50 and h > 50:  # Filter small detections
                table_coordinates.append((y, y + h, x, x + w))

        return sorted(table_coordinates, key=lambda coord: coord[0])  # Sort by y-coordinate

    def process_table(self, image, table_coords):
        """Advanced table processing with improved cell extraction"""
        try:
            y1, y2, x1, x2 = table_coords
            table_image = image[y1:y2, x1:x2]
            gray = cv2.cvtColor(table_image, cv2.COLOR_RGB2GRAY)
            thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)

            # Detect grid lines
            horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40, 1))
            vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 40))

            horizontal_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel)
            vertical_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel)

            # Combine and find intersections
            grid = cv2.addWeighted(horizontal_lines, 1, vertical_lines, 1, 0)
            contours, _ = cv2.findContours(grid, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)

            row_positions = sorted(set(y for _, y, _, _ in contours))
            col_positions = sorted(set(x for x, _, _, _ in contours))

            # Create table in Word
            if len(row_positions) > 1 and len(col_positions) > 1:
                num_rows = len(row_positions) - 1
                num_cols = len(col_positions) - 1
                table = self.doc.add_table(rows=num_rows, cols=num_cols)
                table.style = 'Table Grid'

                for i in range(num_rows):
                    for j in range(num_cols):
                        y_start, y_end = row_positions[i], row_positions[i + 1]
                        x_start, x_end = col_positions[j], col_positions[j + 1]
                        cell_image = table_image[y_start:y_end, x_start:x_end]

                        # Extract cell text with OCR
                        cell_text = pytesseract.image_to_string(
                            cell_image, lang='jpn+eng', config='--psm 6'
                        ).strip()
                        cell_text = ' '.join(cell_text.split())

                        cell = table.cell(i, j)
                        cell.text = cell_text

                        # Format cell text
                        paragraph = cell.paragraphs[0]
                        run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
                        run.font.name = 'Yu Gothic'
                        run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')

            return y2
        except Exception as e:
            self.logger.error(f"Table processing error: {str(e)}")
            return table_coords[1]

    def convert(self):
        """Main conversion process"""
        try:
            pdf_document = fitz.open(self.input_path)
            total_pages = pdf_document.page_count

            with tqdm(total=total_pages, desc="Converting PDF") as pbar:
                for page_num in range(total_pages):
                    try:
                        page = pdf_document[page_num]
                        pix = page.get_pixmap(matrix=fitz.Matrix(self.dpi / 72, self.dpi / 72))
                        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                        img_np = np.array(img)

                        tables = self.detect_tables(img_np)
                        last_y = 0

                        for table_coords in tables:
                            if table_coords[0] > last_y:
                                text_region = img_np[last_y:table_coords[0], :]
                                text = pytesseract.image_to_string(text_region, lang='jpn+eng')
                                if text.strip():
                                    p = self.doc.add_paragraph(text.strip())
                                    for run in p.runs:
                                        run.font.name = 'Yu Gothic'
                                        run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')
                            last_y = self.process_table(img_np, table_coords)

                        if last_y < img_np.shape[0]:
                            text_region = img_np[last_y:, :]
                            text = pytesseract.image_to_string(text_region, lang='jpn+eng')
                            if text.strip():
                                p = self.doc.add_paragraph(text.strip())
                                for run in p.runs:
                                    run.font.name = 'Yu Gothic'
                                    run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')

                        if page_num < total_pages - 1:
                            self.doc.add_page_break()

                        pbar.update(1)

                    except Exception as e:
                        self.logger.error(f"Error processing page {page_num + 1}: {str(e)}")
                        continue

            output_dir = os.path.dirname(self.output_path)
            os.makedirs(output_dir, exist_ok=True)

            temp_docx = self.output_path
            if self.output_format == 'pdf':
                temp_docx = str(Path(self.output_path).with_suffix('.docx'))

            self.doc.save(temp_docx)

            if self.output_format == 'pdf':
                convert(temp_docx, self.output_path)
                os.remove(temp_docx)

            self.logger.info(f"Document successfully saved as {self.output_path}")

        except Exception as e:
            self.logger.error(f"Conversion error: {str(e)}")
        finally:
            if 'pdf_document' in locals():
                pdf_document.close()


def main():
    print("Robust Document Converter")
    print("-" * 30)

    input_path = input("Enter input PDF path: ")
    output_format = input("Enter desired output format (docx/pdf): ").lower()
    while output_format not in ['docx', 'pdf']:
        output_format = input("Please enter either 'docx' or 'pdf': ").lower()

    try:
        dpi = int(input("Enter DPI (300-600, press Enter for default 300): ") or 300)
        dpi = max(300, min(600, dpi))
    except ValueError:
        dpi = 300

    output_path = str(Path(input_path).with_suffix(f'.{output_format}'))

    converter = RobustDocumentConverter(input_path, output_path, output_format, dpi)
    converter.convert()


if __name__ == "__main__":
    main()
