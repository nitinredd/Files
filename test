import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from scipy.optimize import curve_fit
from scipy.integrate import solve_ivp
from sklearn.metrics import r2_score, mean_absolute_error
from bayes_opt import BayesianOptimization
from deap import base, creator, tools, algorithms
import shap
from xgboost import XGBRegressor
from pyswarm import pso
import warnings

# Suppress warnings and configure SHAP
warnings.filterwarnings("ignore", category=UserWarning)
shap.initjs()

# Initialize session state
if 'params' not in st.session_state:
    st.session_state.params = {'D': 0.1, 'R': 0.5, 'Sw': 2.0, 'k': 0.1, 'n': 0.5}

# ---------------------- Drug Release Models ----------------------
MODELS = {
    "Fickian Diffusion": {
        "function": lambda t, D, R: 1 - (6/np.pi**2) * np.sum(
            [np.exp(-D*(n**2)*np.pi**2*t/R**2)/n**2 for n in range(1, 50)], axis=0),
        "params": ["D", "R"]
    },
    "Erosion-Controlled": {"function": lambda t, k: 1 - np.exp(-k * t), "params": ["k"]},
    "Swelling-Controlled": {"function": lambda t, D, Sw: 1 - np.exp(-D * t / Sw), "params": ["D", "Sw"]},
    "Higuchi Model": {"function": lambda t, k: k * np.sqrt(t), "params": ["k"]},
    "Korsmeyer-Peppas": {"function": lambda t, k, n: k * t**n, "params": ["k", "n"]}
}

# ---------------------- AI Optimization Framework ----------------------
class AIOptimizer:
    def __init__(self, method='bayesian'):
        self.method = method
        
    def optimize(self, objective_func, param_space):
        if self.method == 'bayesian':
            return self._bayesian_optimization(objective_func, param_space)
        elif self.method == 'genetic':
            return self._genetic_algorithm(objective_func, param_space)
        elif self.method == 'pso':
            return self._particle_swarm(objective_func, param_space)
            
    def _bayesian_optimization(self, objective_func, param_space):
        optimizer = BayesianOptimization(f=objective_func, pbounds=param_space)
        optimizer.maximize(init_points=5, n_iter=20)
        return optimizer.max
    
    def _genetic_algorithm(self, objective_func, param_space):
        creator.create("FitnessMax", base.Fitness, weights=(1.0,))
        creator.create("Individual", list, fitness=creator.FitnessMax)
        toolbox = base.Toolbox()
        param_bounds = list(param_space.values())
        
        toolbox.register("attr_float", np.random.uniform, param_bounds[0][0], param_bounds[0][1])
        toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=len(param_space))
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

        def eval_individual(individual):
            params = dict(zip(param_space.keys(), individual))
            return (objective_func(**params),)
            
        toolbox.register("evaluate", eval_individual)
        toolbox.register("mate", tools.cxBlend, alpha=0.5)
        toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
        toolbox.register("select", tools.selTournament, tournsize=3)

        population = toolbox.population(n=50)
        algorithms.eaSimple(population, toolbox, cxpb=0.5, mutpb=0.2, ngen=30, verbose=False)
        best_individual = tools.selBest(population, k=1)[0]
        return {'params': dict(zip(param_space.keys(), best_individual)), 'target': best_individual.fitness.values[0]}
    
    def _particle_swarm(self, objective_func, param_space):
        lb = [v[0] for v in param_space.values()]
        ub = [v[1] for v in param_space.values()]
        
        def wrapped_obj(x):
            return -objective_func(**dict(zip(param_space.keys(), x)))
            
        xopt, fopt = pso(wrapped_obj, lb, ub, swarmsize=50, maxiter=100)
        return {'params': dict(zip(param_space.keys(), xopt)), 'target': -fopt}

# ---------------------- CFD-Based Drug Transport Simulation ----------------------
def cfd_drug_transport(t, y, D, k):
    dydt = [-D * (y[0] - k)]
    return dydt

def simulate_cfd_diffusion(D, k, time_points):
    y0 = [1.0]  # Initial drug concentration
    sol = solve_ivp(cfd_drug_transport, [0, max(time_points)], y0, args=(D, k), t_eval=time_points)
    return sol.t, sol.y[0]

# ---------------------- Streamlit UI ----------------------
st.set_page_config(page_title="PharmaAI: Drug Release", layout="wide")
st.sidebar.title("‚öôÔ∏è Simulation Controls")

with st.sidebar.expander("üî¨ Model Selection"):
    model_choice = st.selectbox("Choose Release Model", list(MODELS.keys()))
    use_cfd = st.checkbox("Enable CFD for Tissue Transport")

time_range = st.slider("Simulation Time (hours)", 0.1, 24.0, 10.0)
num_points = st.slider("Data Points", 50, 1000, 200)

model_config = MODELS[model_choice]
for param in model_config["params"]:
    st.session_state.params[param] = st.sidebar.number_input(param, 0.01, 10.0, st.session_state.params[param])

t = np.linspace(0, time_range, num_points)
Mt = model_config["function"](t, *[st.session_state.params[p] for p in model_config["params"]])
Mt = np.clip(Mt, 0, 1)

fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(t, Mt, 'b-', linewidth=2)
ax.set_xlabel("Time (hours)")
ax.set_ylabel("Fractional Release")
ax.set_title(f"{model_choice} Release Profile")
ax.grid(True, alpha=0.3)
st.pyplot(fig)

if use_cfd:
    t_cfd, Mt_cfd = simulate_cfd_diffusion(st.session_state.params["D"], st.session_state.params["k"], t)
    fig_cfd, ax_cfd = plt.subplots(figsize=(10, 6))
    ax_cfd.plot(t_cfd, Mt_cfd, 'r--', linewidth=2)
    ax_cfd.set_xlabel("Time (hours)")
    ax_cfd.set_ylabel("Tissue Drug Concentration")
    ax_cfd.set_title("CFD-Based Drug Transport")
    ax_cfd.grid(True, alpha=0.3)
    st.pyplot(fig_cfd)
