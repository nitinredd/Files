// src/App.jsx
import React, { useEffect, useState } from "react";
import axios from "axios";

/*
  Updated App.jsx for the "reverse" workflow:
  1) Upload LHS via /upload_lhs (multipart)
  2) Configure run & start watcher via /start_watch (JSON)
     - creates objective columns and sets expected_files
  3) Upload HPLC files one-by-one via /upload_hplc (multipart) OR drop files in watched folder
     - server fills objective columns row-wise and runs optimization after each file
  4) Poll /results to show live LHS + optimization outputs

  NOTE: Uses relative endpoints (e.g. "/upload_lhs"). If you don't have Vite proxy set up,
  set API_BASE = "http://localhost:8000" and prepend to paths below.
*/

const API_BASE = ""; // leave empty for proxy; set to "http://localhost:8000" if not using proxy

export default function App() {
  const [lhs, setLhs] = useState(null);
  const [opt, setOpt] = useState(null);
  const [hplcResponses, setHplcResponses] = useState({});
  const [lhsFile, setLhsFile] = useState(null);
  const [hplcFile, setHplcFile] = useState(null);

  const [watchPath, setWatchPath] = useState("");
  const [objectivesText, setObjectivesText] = useState("Yield:Maximize,Purity:Minimize");
  const [sorIter, setSorIter] = useState(3);

  const [watchStatus, setWatchStatus] = useState(null);
  const [polling, setPolling] = useState(true);

  // HPLC parsing params (exposed minimally)
  const [YminRT, setYminRT] = useState(2.0);
  const [YmaxRT, setYmaxRT] = useState(4.0);
  const [IminRT_list, setIminRT_list] = useState("0.7"); // comma separated
  const [ImaxRT_list, setImaxRT_list] = useState("1.3");
  const [minRTISO, setMinRTISO] = useState(10.0);
  const [maxRTISO, setMaxRTISO] = useState(12.0);

  // ===== helpers =====
  const parseObjectivesText = (text) => {
    return text.split(",").map(p => p.trim()).filter(Boolean).map(entry => {
      const [nameRaw, modeRaw] = entry.split(":").map(x => x && x.trim());
      const name = nameRaw || "Objective";
      const maximize = (modeRaw || "Maximize").toLowerCase().startsWith("max");
      return { name, maximize };
    });
  };

  // Poll server results
  const pollResults = async () => {
    try {
      const url = `${API_BASE}/results`;
      const res = await axios.get(url);
      if (res.data) {
        if (res.data.lhs_table) setLhs(res.data.lhs_table);
        if (res.data.optimization_result) setOpt(res.data.optimization_result);
        if (res.data.hplc_responses) setHplcResponses(res.data.hplc_responses);
        setWatchStatus({ watching: res.data.watching, watch_path: res.data.watch_path, expected_files: res.data.expected_files, next_row: res.data.next_row, objectives: res.data.objectives });
      }
    } catch (err) {
      // console.warn("Poll error", err.message);
    }
  };

  useEffect(() => {
    let id = null;
    if (polling) {
      pollResults(); // immediate
      id = setInterval(() => pollResults(), 2500);
    }
    return () => clearInterval(id);
  }, [polling]);

  // ===== LHS upload =====
  async function uploadLHS() {
    if (!lhsFile) {
      alert("Select an LHS Excel (.xlsx/.xls) file first.");
      return;
    }
    try {
      const form = new FormData();
      form.append("file", lhsFile);
      const url = `${API_BASE}/upload_lhs`;
      const res = await axios.post(url, form, { headers: { "Content-Type": "multipart/form-data" } });
      if (res.data && res.data.status === "ok") {
        alert(`LHS uploaded: ${res.data.n} rows. Columns: ${res.data.columns.join(", ")}`);
        await pollResults();
      } else {
        alert("Upload LHS error: " + JSON.stringify(res.data));
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Upload LHS failed: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // ===== Start watch & configure run =====
  async function startWatch() {
    // build objectives
    const objectives = parseObjectivesText(objectivesText);
    if (!watchPath) {
      alert("Enter absolute server folder path to watch (server filesystem).");
      return;
    }
    if (objectives.length === 0) {
      alert("Enter at least one objective, e.g. Yield:Maximize");
      return;
    }
    try {
      const payload = {
        path: watchPath,
        objectives: objectives,
        sor_iterations: Number(sorIter) || 1,
        YminRT: Number(YminRT),
        YmaxRT: Number(YmaxRT),
        IminRT_list: IminRT_list.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
        ImaxRT_list: ImaxRT_list.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
        minRTISO: Number(minRTISO),
        maxRTISO: Number(maxRTISO)
      };
      const url = `${API_BASE}/start_watch`;
      const res = await axios.post(url, payload, { headers: { "Content-Type": "application/json" } });
      if (res.data && res.data.status === "watching") {
        alert("Watcher started: " + JSON.stringify(res.data));
        setWatchStatus(res.data);
        await pollResults();
      } else {
        alert("Start watch response: " + JSON.stringify(res.data));
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Start watch error: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  async function stopWatch() {
    try {
      const url = `${API_BASE}/stop_watch`;
      const res = await axios.post(url);
      if (res.data) {
        alert("Watcher stopped");
        setWatchStatus(null);
        await pollResults();
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Stop watch error: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // ===== Upload single HPLC CSV (processes and fills next row) =====
  async function uploadHplc() {
    if (!hplcFile) {
      alert("Select an HPLC CSV file first.");
      return;
    }
    try {
      const form = new FormData();
      form.append("file", hplcFile);
      // pass HPLC parsing params as query params via axios 'params'
      const params = {
        YminRT: Number(YminRT),
        YmaxRT: Number(YmaxRT),
        IminRT_list: IminRT_list.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
        ImaxRT_list: ImaxRT_list.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
        minRTISO: Number(minRTISO),
        maxRTISO: Number(maxRTISO)
      };
      const url = `${API_BASE}/upload_hplc`;
      const res = await axios.post(url, form, { params, headers: { "Content-Type": "multipart/form-data" } });
      if (res.data && res.data.status === "ok") {
        alert(`HPLC processed: ${res.data.filename}. Response: ${JSON.stringify(res.data.response)} Next_row: ${res.data.next_row}`);
        await pollResults();
      } else {
        alert("Upload HPLC response: " + JSON.stringify(res.data));
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Upload HPLC error: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // ===== Manual trigger optimize (runs optimization on current LHS) =====
  async function runOptimizeManually() {
    // need objectives and nobj length for OptimizeRequest
    const objectives = parseObjectivesText(objectivesText);
    try {
      const payload = { objectives: objectives.map(o => ({ name: o.name, maximize: o.maximize })), sor_iterations: Number(sorIter), nobj: Math.max(1, objectives.length) };
      const url = `${API_BASE}/optimize`;
      const res = await axios.post(url, payload, { headers: { "Content-Type": "application/json" } });
      if (res.data && res.data.status === "ok") {
        alert("Manual optimize finished (result in UI).");
        await pollResults();
      } else {
        alert("Optimize response: " + JSON.stringify(res.data));
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Optimize error: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // ===== UI =====
  return (
    <div style={{ padding: 20, fontFamily: "Inter, Arial, sans-serif", maxWidth: 1100, margin: "0 auto" }}>
      <h1>SOR AI — LHS → HPLC → Optimization</h1>

      <section style={cardStyle}>
        <h3>1) Upload LHS Excel</h3>
        <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
          <input type="file" accept=".xlsx,.xls" onChange={e => setLhsFile(e.target.files?.[0] || null)} />
          <button onClick={uploadLHS}>Upload LHS</button>
        </div>
        <div style={{ marginTop: 8 }}>
          <small>Server will store the first sheet of your uploaded Excel as the LHS table.</small>
        </div>
      </section>

      <section style={cardStyle}>
        <h3>2) Configure objectives & start watcher</h3>
        <div style={{ display: "flex", gap: 12, alignItems: "center", flexWrap: "wrap" }}>
          <div style={{ minWidth: 420 }}>
            <label>Objectives (comma-separated, name:Maximize or Minimize):</label><br />
            <input style={inputStyle} value={objectivesText} onChange={e => setObjectivesText(e.target.value)} />
          </div>

          <div>
            <label>Server folder to watch (absolute path):</label><br />
            <input style={{ ...inputStyle, width: 360 }} value={watchPath} onChange={e => setWatchPath(e.target.value)} />
          </div>

          <div>
            <label>SOR iterations (files expected):</label><br />
            <input style={{ ...inputStyle, width: 100 }} type="number" value={sorIter} onChange={e => setSorIter(Number(e.target.value))} />
          </div>

          <div style={{ display: "flex", gap: 8 }}>
            <button onClick={startWatch}>Start Watch & Configure Run</button>
            <button onClick={stopWatch}>Stop Watch</button>
            <button onClick={runOptimizeManually}>Run Optimize (manual)</button>
          </div>
        </div>

        <div style={{ marginTop: 8 }}>
          <strong>Watcher status:</strong> <pre style={{ whiteSpace: "pre-wrap" }}>{JSON.stringify(watchStatus, null, 2)}</pre>
        </div>
      </section>

      <section style={cardStyle}>
        <h3>3) Upload HPLC CSV (processes next row)</h3>
        <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
          <input type="file" accept=".csv" onChange={e => setHplcFile(e.target.files?.[0] || null)} />
          <button onClick={uploadHplc}>Upload HPLC (fills next row)</button>
        </div>

        <div style={{ marginTop: 8 }}>
          <label>HPLC RT params (optional):</label>
          <div style={{ display: "flex", gap: 8, alignItems: "center", marginTop: 6 }}>
            <div>
              <small>YminRT</small><br />
              <input style={smallInput} value={YminRT} onChange={e => setYminRT(Number(e.target.value))} />
            </div>
            <div>
              <small>YmaxRT</small><br />
              <input style={smallInput} value={YmaxRT} onChange={e => setYmaxRT(Number(e.target.value))} />
            </div>
            <div>
              <small>IminRT list</small><br />
              <input style={smallInput} value={IminRT_list} onChange={e => setIminRT_list(e.target.value)} />
            </div>
            <div>
              <small>ImaxRT list</small><br />
              <input style={smallInput} value={ImaxRT_list} onChange={e => setImaxRT_list(e.target.value)} />
            </div>
            <div>
              <small>ISO min</small><br />
              <input style={smallInput} value={minRTISO} onChange={e => setMinRTISO(Number(e.target.value))} />
            </div>
            <div>
              <small>ISO max</small><br />
              <input style={smallInput} value={maxRTISO} onChange={e => setMaxRTISO(Number(e.target.value))} />
            </div>
          </div>
        </div>
      </section>

      <section style={cardStyle}>
        <h3>Live LHS (server-stored)</h3>
        {lhs ? (
          <div style={{ maxHeight: 360, overflow: "auto", border: "1px solid #eee", padding: 8 }}>
            <table style={{ width: "100%", borderCollapse: "collapse" }}>
              <thead>
                <tr>
                  {Object.keys(lhs[0]).map((k) => <th key={k} style={{ textAlign: "left", padding: 6, borderBottom: "1px solid #eee" }}>{k}</th>)}
                </tr>
              </thead>
              <tbody>
                {lhs.map((row, i) => (
                  <tr key={i}>
                    {Object.keys(lhs[0]).map(k => <td key={k} style={{ padding: 6, borderBottom: "1px solid #fafafa" }}>{String(row[k] ?? "").slice(0, 20)}</td>)}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : <div>No LHS stored on server yet.</div>}
      </section>

      <section style={cardStyle}>
        <h3>Optimization result</h3>
        <div style={{ maxHeight: 300, overflow: "auto", background: "#0b1220", color: "#cff", padding: 8, borderRadius: 6 }}>
          <pre>{opt ? JSON.stringify(opt, null, 2) : "No optimization result yet."}</pre>
        </div>
      </section>

      <footer style={{ marginTop: 12, color: "#666" }}>
        <label><input type="checkbox" checked={polling} onChange={e => setPolling(e.target.checked)} /> Poll server every 2.5s</label>
      </footer>
    </div>
  );
}

// ===== simple styles =====
const cardStyle = {
  background: "#fff",
  padding: 12,
  borderRadius: 8,
  boxShadow: "0 6px 18px rgba(15,20,50,0.06)",
  marginBottom: 12
};
const inputStyle = { width: "100%", padding: 8, borderRadius: 6, border: "1px solid #ddd" };
const smallInput = { width: 84, padding: 6, borderRadius: 6, border: "1px solid #ddd" };
