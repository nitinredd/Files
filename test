
import React, { useEffect, useState, useRef } from "react";
import { motion } from "framer-motion";

import ChatWindow from "./ChatWindow";
import ProductTabs from "./ProductTabs";
import ProductDetailModal from "./ProductDetailModal";
import SidebarHistory from "./SidebarHistory";
import ReactionTiles from "./ReactionTiles";
import PromptGallery from "./PromptGallery";

import {
  fetchReactions,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  fetchPrompts,
  queryWithCitations,
  uploadFile,
} from "./api";

import Navbar from "../Navbar/Navbar";
import Footer from "../Footer/Footer";

import Slider1 from "../../assets/Slider1.png";
import Slider2 from "../../assets/Slider2.png";
import Slider3 from "../../assets/Slider3.png";
import Slider4 from "../../assets/Slider4.png";
import Slider5 from "../../assets/Slider5.png";
import Slider6 from "../../assets/Slider6.png";

export default function App() {
  const [reactions, setReactions] = useState([]);
  const [prompts, setPrompts] = useState([]);

  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);

  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);

  const [detailModalOpen, setDetailModalOpen] = useState(false);

  const [messages, setMessages] = useState([]); // chat messages
  const [history, setHistory] = useState([]); // conversation history list

  // Loading state flags
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [queryLoading, setQueryLoading] = useState(false);

  // Selected citations (right-click / multi-select)
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);

  // For scheme preview in chat
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  // Prompt gallery UI
  const [promptGalleryOpen, setPromptGalleryOpen] = useState(false);

  // Expanded full-page view (when user clicks a reaction type)
  const [expandedViewOpen, setExpandedViewOpen] = useState(false);

  // Chat expansion state (when user sends a message)
  const [chatExpanded, setChatExpanded] = useState(false);

  // Slider
  const [slideIndex, setSlideIndex] = useState(0);
  const sliderIntervalRef = useRef(null);
  const SLIDE_COUNT = 6;

  const chatWindowRef = useRef(null);
  const uploadInputRef = useRef(null);

  useEffect(() => {
    fetchReactions()
      .then((r) => setReactions(r || []))
      .catch((e) => console.error("fetchReactions error:", e));

      fetchPrompts()
      .then((p) => {
        // some backends return {prompts: [...]}, accept both shapes
        setPrompts(p?.prompts || p || []);
      })
      .catch((e) => {
        console.warn("fetchPrompts failed:", e);
      });

    setMessages([
      {
        role: "assistant",
        content:
          "",
      },
    ]);
  }, []);

  // slider autoplay
  useEffect(() => {
    sliderIntervalRef.current = setInterval(() => {
      setSlideIndex((s) => (s + 1) % SLIDE_COUNT);
    }, 6000);
    return () => clearInterval(sliderIntervalRef.current);
  }, []);

  const pushMessage = (m) => setMessages((prev) => [...prev, m]);
  const normalize = (s) => (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");

  // handle upload using api.uploadFile (relative endpoint)
  const handleUploadFile = async (file, reaction_type = "User_Uploads") => {
    if (!file) return;
    pushMessage({ role: "assistant", content: "Uploading file...", loading: true });
    try {
      const res = await uploadFile(file, reaction_type);
      // remove loading placeholder
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      pushMessage({ role: "assistant", content: "Upload complete and indexed (if supported)." });
      // refresh product list for the reaction_type
      try {
        const prods = await fetchProducts(reaction_type);
        setProducts(prods || []);
        setProductListVisible(true);
      } catch {}
      return res;
    } catch (err) {
      console.error("handleUploadFile error:", err);
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      pushMessage({ role: "assistant", content: `Upload failed: ${err?.message || err}` });
      return null;
    }
  };

  const handleReactionClick = async (reactionName) => {
    setSelectedReaction(reactionName);
    try {
      const prods = await fetchProducts(reactionName);
      setProducts(prods || []);
      setProductListVisible(true);
      setExpandedViewOpen(true);
      pushMessage({ role: "assistant", content: `Found ${prods.length} products for ${reactionName}` });
    } catch (e) {
      console.error(e);
      pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
    }
  };

  const handlePromptPick = async (promptText) => {
    setPromptGalleryOpen(false);
    await handleUserSend(promptText);
  };

  const handleSelectProduct = async (productId) => {
    try {
      setLoadingDetails(true);
      const meta = await fetchProductMeta(productId);
      setSelectedProduct(meta);
      setProductDetails(null);
      setSelectedSchemeUrl(null);
      setDetailModalOpen(true);

      try {
        const schemeUrl = await fetchSchemeImageUrl(productId);
        setSelectedSchemeUrl(schemeUrl);
      } catch {}

      try {
        const res = await fetchProductDetails(productId);
        const payload = (res && res.data) ? res.data : res;
        setProductDetails(payload);
        setHistory((h) => [
          { title: meta.name, content: payload.procedure ? payload.procedure.slice(0, 120) : "", productId: meta.id },
          ...h,
        ]);
      } catch (e) {
        console.error("fetchProductDetails error (select product):", e);
        pushMessage({ role: "assistant", content: "Failed to load product details." });
      }
    } catch (err) {
      console.error("handleSelectProduct error:", err);
      pushMessage({ role: "assistant", content: "Failed to load product metadata." });
    } finally {
      setLoadingDetails(false);
    }
  };

  const handleToggleCite = (product) => {
    const exists = selectedCitedDocs.find((p) => p.id === product.id);
    if (exists) {
      setSelectedCitedDocs((prev) => prev.filter((p) => p.id !== product.id));
      pushMessage({ role: "assistant", content: `Removed citation: ${product.name}` });
    } else {
      setSelectedCitedDocs((prev) => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: "assistant", content: `Added citation: ${product.name}` });
    }
  };

  const removeCitation = (id) => {
    const found = selectedCitedDocs.find((d) => d.id === id);
    setSelectedCitedDocs((prev) => prev.filter((d) => d.id !== id));
    if (found) pushMessage({ role: "assistant", content: `Removed citation: ${found.name}` });
  };

  // main send handler (same logic as earlier working version)
  const handleUserSend = async (text) => {
    pushMessage({ role: "user", content: text });

    // Expand chat window with animation on first user message
    if (!chatExpanded && !expandedViewOpen) {
      setChatExpanded(true);
    }

    const norm = normalize(text);
    const match = reactions.find((r) => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g, "_")));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        setExpandedViewOpen(true);
        pushMessage({ role: "assistant", content: `Found ${prods.length} product${prods.length === 1 ? "" : "s"} ‚Äî opened expanded view.` });
      } catch (e) {
        console.error(e);
        pushMessage({ role: "assistant", content: "Error loading products for that reaction."});
      }
      return;
    }

    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      setQueryLoading(true);
      pushMessage({ role: "assistant", content: "Searching selected documents...", loading: true });
      try {
        const ids = selectedCitedDocs.map((d) => d.id);
        const res = await queryWithCitations(ids, text);
        const payload = (res && res.data) ? res.data : res;
        setMessages((prev) => {
          const idx = prev.map((m) => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = [...prev];
            copy.splice(idx, 1);
            return copy;
          }
          return prev;
        });
        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        const sources = (payload?.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: "assistant", content: "Error querying selected documents."});
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    if (!selectedProduct) {
      setQueryLoading(true);
      pushMessage({ role: "assistant", content: "Searching documents...", loading: true });
      try {
        const res = await fetchProductDetails(undefined, text);
        const payload = (res && res.data) ? res.data : res;
        setMessages((prev) => {
          const idx = prev.map((m) => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = [...prev];
            copy.splice(idx, 1);
            return copy;
          }
          return prev;
        });
        if (payload && payload.api_name) {
          let summary = "";
          if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
          if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
          if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
          if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
          pushMessage({ role: "assistant", content: summary, tables: (payload.tables || []) });
        } else if (payload && (payload.answer || payload.response)) {
          const answer = payload.answer || payload.response || "No answer.";
          const sources = (payload.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
          pushMessage({ role: "assistant", content: answer, sources });
        } else {
          pushMessage({ role: "assistant", content: "No structured data found. Try selecting a product or ask for specific extraction." });
        }
      } catch (err) {
        console.error("fetchProductDetails error (no product):", err);
        pushMessage({ role: "assistant", content: "Error querying documents." });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    setQueryLoading(true);
    pushMessage({ role: "assistant", content: "Fetching answer from selected document...", loading: true });
    try {
      const res = await fetchProductDetails(selectedProduct.id, text);
      const payload = (res && res.data) ? res.data : res;
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      if (payload && payload.api_name) {
        let summary = "";
        if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
        if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
        if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
        if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
        pushMessage({ role: "assistant", content: summary, tables: (payload.tables || []) });
        setProductDetails(payload);
        setDetailModalOpen(true);
        setHistory((h) => [{ title: selectedProduct.name, content: payload.procedure ? payload.procedure.slice(0,120) : '', productId: selectedProduct.id }, ...h]);
      } else if (payload && (payload.answer || payload.response)) {
        const answer = payload.answer || payload.response || "No answer.";
        const sources = (payload.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } else {
        pushMessage({ role: "assistant", content: "No answer found from document." });
      }
    } catch (err) {
      console.error("fetchProductDetails (selected) error:", err);
      pushMessage({ role: "assistant", content: "Error querying backend." });
    } finally {
      setQueryLoading(false);
    }
  };

  // slides
  const slides = [
    {
      id: 0,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider1} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
    {
      id: 1,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider2} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
    {
      id: 2,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider3} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
    {
      id: 3,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider4} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
    {
      id: 4,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider5} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
    {
      id: 5,
      content: (
        <div className="w-full h-full flex items-center justify-center">
          <img src={Slider6} alt="banner" className="w-full h-full object-contain" />
        </div>
      ),
    },
  ];

  const closeExpandedView = () => setExpandedViewOpen(false);

  // file input trigger
  const onPlusClick = () => {
    if (uploadInputRef.current) uploadInputRef.current.click();
  };

  const onFileInputChange = async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    // default reaction_type 'Miscellaneous' ‚Äî you could surface a small select later
    await handleUploadFile(f, "Miscellaneous");
    e.target.value = "";
  };

  return (
    <>
      <Navbar />

      <div className="min-h-screen bg-white flex justify-center items-start overflow-x-hidden">
        <div className="w-full max-w-7xl py-8 px-4">
          {/* Carousel */}
          <div className="mb-6">
          <div className="relative overflow-hidden rounded-2xl shadow-lg" style={{ height: '410px' }}>
            <div
              className="flex transition-transform duration-700 ease-in-out h-full"
              style={{
                width: `${SLIDE_COUNT * 100}%`,
                transform: `translateX(-${slideIndex * (100 / SLIDE_COUNT)}%)`
              }}
            >
              {slides.map((s) => (
                <div
                  key={s.id}
                  className="w-full h-full flex-shrink-0 bg-gradient-to-br from-purple-50 via-white to-indigo-50"
                  style={{ width: `${100 / SLIDE_COUNT}%` }}
                >
                  {s.content}
                </div>
              ))}
            </div>
            <div className="absolute bottom-3 left-1/2 transform -translate-x-1/2 flex gap-2">
              {slides.map((_, i) => (
                <button
                  key={i}
                  onClick={() => setSlideIndex(i)}
                  className={`w-2 h-2 rounded-full ${
                    i === slideIndex ? "bg-gray-700" : "bg-gray-300"
                  }`}
                />
              ))}
            </div>
          </div>
          </div>

          {/* Reaction tiles */}
          <div className="mb-6">
            <ReactionTiles reactions={reactions} onSelect={handleReactionClick} />
          </div>

          {!chatExpanded && !expandedViewOpen && (
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {/* Center: chat */}
              <div className="lg:col-span-2 flex justify-center">
                <div className="w-full max-w-2xl relative">
                  <input ref={uploadInputRef} type="file" accept=".pdf,.docx,.pptx,.xlsx,.png,.jpg,.jpeg" className="hidden" onChange={onFileInputChange} />

                  <ChatWindow
                    ref={chatWindowRef}
                    messages={messages}
                    onSend={handleUserSend}
                    centeredWidth="w-full"
                    loading={queryLoading || loadingDetails}
                    selectedCitedDocs={selectedCitedDocs}
                    removeCitation={removeCitation}
                    onUploadFile={handleUploadFile}
                    openPromptGallery={() => setPromptGalleryOpen(true)}
                  />
                </div>
              </div>

              <div className="lg:col-span-1">
                <SidebarHistory history={history} onSelect={(h) => { if (h && h.productId) handleSelectProduct(h.productId); }} />
              </div>
            </div>
          )}

          {/* Expanded Chat View */}
          {chatExpanded && !expandedViewOpen && (
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, ease: "easeOut" }}
              className="fixed inset-0 z-40 bg-gradient-to-br from-purple-50 via-white to-indigo-50"
            >
              <div className="h-full flex flex-col">
                {/* Header */}
                <div className="bg-white/80 backdrop-blur-md border-b px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                  <h2 className="text-xl font-semibold bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">
                    ChemIntel Chat
                  </h2>
                  <button
                    onClick={() => setChatExpanded(false)}
                    className="px-4 py-2 rounded-full bg-gradient-to-r from-purple-500 to-indigo-500 text-white shadow-lg hover:shadow-xl transition-all"
                  >
                    Minimize
                  </button>
                </div>

                {/* Chat Content - Centered */}
                <div className="flex-1 overflow-auto px-6 py-8 flex items-center justify-center">
                  <div className="w-full max-w-4xl">
                    {/* Beautiful loading animation when generating */}
                    {queryLoading && (
                      <motion.div
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        className="mb-6 flex flex-col items-center justify-center space-y-4 py-8"
                      >
                        <div className="relative">
                          <motion.div
                            animate={{ rotate: 360 }}
                            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                            className="w-16 h-16 border-4 border-purple-200 border-t-purple-600 rounded-full"
                          />
                          <motion.div
                            animate={{ rotate: -360 }}
                            transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
                            className="absolute inset-0 w-16 h-16 border-4 border-transparent border-b-indigo-600 rounded-full"
                          />
                        </div>
                        <motion.p
                          animate={{ opacity: [0.5, 1, 0.5] }}
                          transition={{ duration: 2, repeat: Infinity }}
                          className="text-lg font-medium bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent"
                        >
                          Generating response...
                        </motion.p>
                        <div className="flex gap-2">
                          {[0, 1, 2].map((i) => (
                            <motion.div
                              key={i}
                              animate={{ y: [0, -10, 0] }}
                              transition={{ duration: 0.6, repeat: Infinity, delay: i * 0.2 }}
                              className="w-3 h-3 rounded-full bg-gradient-to-r from-purple-500 to-indigo-500"
                            />
                          ))}
                        </div>
                      </motion.div>
                    )}

                    <ChatWindow
                      ref={chatWindowRef}
                      messages={messages}
                      onSend={handleUserSend}
                      centeredWidth="w-full"
                      loading={queryLoading || loadingDetails}
                      selectedCitedDocs={selectedCitedDocs}
                      removeCitation={removeCitation}
                      onUploadFile={handleUploadFile}
                      openPromptGallery={() => setPromptGalleryOpen(true)}
                    />
                  </div>
                </div>
              </div>
            </motion.div>
          )}

          <PromptGallery
            open={promptGalleryOpen}
            onClose={() => setPromptGalleryOpen(false)}
            prompts={prompts}
            onPick={handlePromptPick}
          />

          {expandedViewOpen && (
            <motion.div
              initial={{ opacity: 0, scale: 0.95 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ duration: 0.4, ease: "easeOut" }}
              className="fixed inset-0 z-50 bg-gradient-to-br from-indigo-50 via-white to-purple-50 overflow-auto"
            >
              <div className="h-full flex flex-col">
                {/* Header */}
                <div className="bg-white/80 backdrop-blur-md border-b px-6 py-4 flex items-center justify-between sticky top-0 z-10">
                  <div className="flex items-center gap-4">
                    <button
                      onClick={closeExpandedView}
                      className="px-4 py-2 rounded-full bg-gradient-to-r from-gray-100 to-gray-200 hover:from-gray-200 hover:to-gray-300 shadow transition-all"
                    >
                      ‚Üê Back
                    </button>
                    <h2 className="text-2xl font-bold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
                      {selectedReaction ? selectedReaction.replace(/_/g, " ") : "Explore Products"}
                    </h2>
                    <span className="px-3 py-1 rounded-full bg-gradient-to-r from-indigo-500 to-purple-500 text-white text-sm font-semibold">
                      {products.length} Products
                    </span>
                  </div>
                </div>

                {/* Content */}
                <div className="flex-1 overflow-auto">
                  <div className="max-w-[1600px] mx-auto p-6 space-y-6">
                    {/* Products Grid - Full width */}
                    <div className="bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg p-6">
                      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-gradient-to-r from-indigo-500 to-purple-500"></span>
                        Product Library
                      </h3>
                      {productListVisible && products && products.length > 0 ? (
                        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-4">
                          {products.map((product) => {
                            const isCited = selectedCitedDocs.some((d) => d.id === product.id);
                            return (
                              <motion.button
                                key={product.id}
                                whileHover={{ y: -8, scale: 1.02 }}
                                whileTap={{ scale: 0.98 }}
                                onClick={() => handleSelectProduct(product.id)}
                                onContextMenu={(e) => {
                                  e.preventDefault();
                                  handleToggleCite(product);
                                }}
                                className={`bg-white rounded-xl p-4 shadow-md hover:shadow-2xl transition-all text-left border-2 ${
                                  isCited ? "border-purple-500 ring-2 ring-purple-200" : "border-transparent"
                                }`}
                              >
                                <div className="flex items-start justify-between gap-2 mb-2">
                                  <div className="flex-1 min-w-0">
                                    <div className="text-sm font-semibold text-gray-900 truncate" title={product.name}>
                                      {product.name}
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">
                                      {(product.reaction_type || "").replace(/_/g, " ")}
                                    </div>
                                  </div>
                                  {isCited && (
                                    <div className="flex-shrink-0 px-2 py-1 rounded-full bg-gradient-to-r from-purple-500 to-indigo-500 text-white text-xs font-bold">
                                      ‚úì
                                    </div>
                                  )}
                                </div>
                                <div className="text-xs text-gray-400 mt-2 flex items-center gap-1">
                                  <span>üìÑ</span>
                                  <span className="truncate">
                                    {product.pdf_path ? product.pdf_path.split(/[\\/]/).pop() : "PDF"}
                                  </span>
                                </div>
                              </motion.button>
                            );
                          })}
                        </div>
                      ) : (
                        <div className="text-center text-gray-500 py-12">
                          No products loaded for this reaction type.
                        </div>
                      )}
                    </div>

                    {/* Chat Section - Full width below products */}
                    <div className="bg-white/50 backdrop-blur-sm rounded-2xl shadow-lg p-6">
                      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-gradient-to-r from-green-500 to-emerald-500"></span>
                        Ask Questions About These Products
                      </h3>
                      <div className="max-w-4xl mx-auto">
                        <ChatWindow
                          messages={messages}
                          onSend={handleUserSend}
                          centeredWidth="w-full"
                          loading={queryLoading || loadingDetails}
                          selectedCitedDocs={selectedCitedDocs}
                          removeCitation={removeCitation}
                          onUploadFile={handleUploadFile}
                          openPromptGallery={() => setPromptGalleryOpen(true)}
                        />
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </motion.div>
          )}

          <ProductDetailModal
            open={detailModalOpen}
            onClose={() => setDetailModalOpen(false)}
            meta={selectedProduct}
            details={productDetails}
            loading={loadingDetails}
          />
        </div>
      </div>

      <Footer />
    </>
  );
}
####################################
// src/components/ChatWindow.jsx
import React, { useRef, useEffect, useState } from "react";
import { motion } from "framer-motion";
import { FiSend, FiPlus, FiDownload, FiX } from "react-icons/fi";
import MicrophoneButton from "./MicrophoneButton";
import { searchProducts } from "./api";
import { marked } from "marked";

/**
 * ChatWindow (centered pill / professional UI)
 *
 * Props:
 *  - messages: array of chat messages
 *  - onSend(text)
 *  - loading: boolean
 *  - centeredWidth: tailwind class (max width of the bar container)
 *  - selectedCitedDocs, removeCitation
 *  - onUploadFile(file): function to handle uploads
 *  - openPromptGallery(): opens the prompt gallery modal
 */
export default function ChatWindow({
  messages = [],
  onSend,
  loading = false,
  centeredWidth = "max-w-2xl",
  selectedCitedDocs = [],
  removeCitation = () => {},
  onUploadFile = null,
  openPromptGallery = null,
}) {
  const [text, setText] = useState("");
  const textareaRef = useRef();
  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);
  const debounceRef = useRef(null);
  const containerRef = useRef(null);
  const fileInputRef = useRef(null);

  // small preview of last messages above bar (keeps UI compact)
  const PREVIEW_COUNT = 5;

  useEffect(() => {
    // autosize textarea
    if (textareaRef.current) {
      textareaRef.current.style.height = "auto";
      textareaRef.current.style.height = textareaRef.current.scrollHeight + "px";
    }
  }, [text, messages]);

  // hide suggestions on outside click
  useEffect(() => {
    const onDocClick = (e) => {
      if (!containerRef.current) return;
      if (!containerRef.current.contains(e.target)) {
        setShowSuggestions(false);
        setActiveIndex(-1);
      }
    };
    document.addEventListener("mousedown", onDocClick);
    return () => document.removeEventListener("mousedown", onDocClick);
  }, []);

  // Debounced product search suggestions (typeahead)
  useEffect(() => {
    const q = (text || "").trim();
    if (q.length < 2) {
      setSuggestions([]);
      setShowSuggestions(false);
      setActiveIndex(-1);
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
        debounceRef.current = null;
      }
      return;
    }
    if (debounceRef.current) clearTimeout(debounceRef.current);
    debounceRef.current = setTimeout(async () => {
      try {
        const res = await searchProducts(q, 8);
        const payload = res && res.data ? res.data : res;
        setSuggestions(payload || []);
        setShowSuggestions(Array.isArray(payload) && payload.length > 0);
        setActiveIndex(-1);
      } catch (err) {
        console.error("searchProducts error:", err);
        setSuggestions([]);
        setShowSuggestions(false);
      }
    }, 220);
    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
        debounceRef.current = null;
      }
    };
  }, [text]);

  // keyboard handling for suggestion nav + submit
  const onKeyDown = (e) => {
    if (showSuggestions && suggestions.length > 0) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        setActiveIndex((i) => Math.min(i + 1, suggestions.length - 1));
        return;
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        setActiveIndex((i) => Math.max(i - 1, 0));
        return;
      } else if (e.key === "Enter" && activeIndex >= 0) {
        e.preventDefault();
        chooseSuggestion(suggestions[activeIndex]);
        return;
      } else if (e.key === "Escape") {
        setShowSuggestions(false);
        setActiveIndex(-1);
        return;
      }
    }

    if (e.key === "Enter" && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      submit();
    }
  };

  // Choose suggestion: replace partial token with product name for natural typing UX
  const chooseSuggestion = (s) => {
    if (!s) return;
    try {
      const el = textareaRef.current;
      if (el) {
        const cursor = el.selectionStart || text.length;
        let left = text.slice(0, cursor);
        let right = text.slice(cursor);
        const lastWs = left.lastIndexOf(" ");
        const prefix = lastWs === -1 ? "" : left.slice(0, lastWs + 1);
        const newText = prefix + s.name + (right && !right.startsWith(" ") ? " " + right : right);
        setText(newText);
      } else {
        setText((t) => (t ? t + " " + s.name : s.name));
      }
    } catch (e) {
      setText((t) => (t ? t + " " + s.name : s.name));
    }
    setShowSuggestions(false);
    setActiveIndex(-1);
    setTimeout(() => textareaRef.current && textareaRef.current.focus(), 0);
  };

  const submit = () => {
    const t = text.trim();
    if (!t) return;
    onSend(t);
    setText("");
    setSuggestions([]);
    setShowSuggestions(false);
    setActiveIndex(-1);
  };

  // File upload: trigger file input and call callback
  const triggerFileInput = () => fileInputRef.current && fileInputRef.current.click();

  const handleFileChange = async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    if (onUploadFile) {
      try {
        await onUploadFile(f);
      } catch (err) {
        console.error("onUploadFile error:", err);
      }
    }
    e.target.value = null;
  };

  // Renders extracted markdown-style tables (from backend structured extraction)
  const parseMarkdownTable = (markdown) => {
    // Split the markdown into lines and filter out empty lines
    const lines = markdown
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.length > 0);
  
    if (lines.length < 2) return null; // Ensure we have header and rows
  
    // Extract headers from the first line
    const headers = lines[0]
      .split("|")
      .map((header) => header.trim())
      .filter((header) => header.length > 0);
  
    // Ignore the second line (which is typically dashes "---")
    const rows = lines.slice(2).map((line) =>
      line
        .split("|")
        .map((cell) => cell.trim())
        .filter((cell) => cell.length > 0)
    );
  
    return { headers, rows };
  };
  
  const renderTable = (tbl, index) => {
    let headers = [];
    let rows = [];
  
    // Check if the input is a raw markdown table string
    if (typeof tbl === "string") {
      const parsedTable = parseMarkdownTable(tbl);
      if (parsedTable) {
        headers = parsedTable.headers;
        rows = parsedTable.rows;
      }
    } else if (tbl.headers && tbl.rows) {
      // Structured data (headers/rows already provided)
      headers = Array.isArray(tbl.headers) ? tbl.headers : [];
      rows = Array.isArray(tbl.rows) ? tbl.rows : [];
    }
  
    // If no headers or rows are provided, return fallback
    if (headers.length === 0 && rows.length === 0) {
      return (
        <div
          key={`tbl-${index}`}
          className="mt-3 mb-4 text-center text-sm text-gray-500"
        >
          No data available for the table.
        </div>
      );
    }
  
    return (
      <div
        key={`tbl-${index}`}
        className="mt-3 mb-4 overflow-auto border rounded-lg"
      >
        <table className="min-w-full table-auto text-sm">
          {/* Table Header */}
          <thead className="bg-gray-50">
            <tr>
              {headers.map((header, hi) => (
                <th
                  key={hi}
                  className="px-3 py-2 text-left font-medium text-gray-700"
                >
                  {header}
                </th>
              ))}
            </tr>
          </thead>
          {/* Table Body */}
          <tbody>
            {rows.map((row, ri) => (
              <tr
                key={ri}
                className={ri % 2 === 0 ? "bg-white" : "bg-gray-50"}
              >
                {row.map((cell, ci) => (
                  <td
                    key={ci}
                    className="px-3 py-2 align-top whitespace-pre-wrap text-gray-800"
                  >
                    {cell}
                  </td>
                ))}
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    );
  };
  // Renders sources as modern cards with download CTA
  const renderSources = (sources = []) => {
    if (!Array.isArray(sources) || sources.length === 0) return null;
    return (
      <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
        {sources.map((s, i) => (
          <div key={s.product_id || i} className="bg-white border rounded-xl p-3 shadow-sm hover:shadow-lg transition">
            <div className="flex items-start justify-between gap-3">
              <div className="min-w-0">
                <div className="text-sm font-semibold text-gray-900 truncate">{s.product_name}</div>
                <div className="text-xs text-gray-400 mt-1">{s.product_id}</div>
              </div>
              <div className="flex items-center gap-2">
                <a
                  href={`/product/${encodeURIComponent(s.product_id)}/pdf`}
                  target="_blank"
                  rel="noreferrer"
                  className="inline-flex items-center gap-2 px-3 py-2 bg-indigo-600 text-white rounded-md text-xs shadow"
                >
                  <FiDownload />
                  Download
                </a>
              </div>
            </div>
            {s.excerpt && <div className="mt-2 text-xs text-gray-700 whitespace-pre-wrap">{s.excerpt}</div>}
          </div>
        ))}
      </div>
    );
  };

  // Extract markdown tables from content
  const extractTablesFromContent = (content) => {
    if (!content || typeof content !== 'string') return { cleanContent: content, tables: [] };

    // Regex to match markdown tables (lines with pipes)
    const tableRegex = /(\|.+\|[\r\n]+\|[-:\s|]+\|[\r\n]+(?:\|.+\|[\r\n]*)+)/g;
    const tables = [];
    let match;

    while ((match = tableRegex.exec(content)) !== null) {
      tables.push(match[1].trim());
    }

    // Remove tables from content
    const cleanContent = content.replace(tableRegex, '\n[TABLE]\n').trim();

    return { cleanContent, tables };
  };

  // Renders single chat message (compact preview)
  const renderMessage = (m, idx) => {
    const isUser = m.role === "user";

    // Extract tables from content if not already provided
    let messageTables = m.tables || [];
    let messageContent = m.content;

    if (!isUser && !messageTables.length && messageContent) {
      const { cleanContent, tables } = extractTablesFromContent(messageContent);
      messageContent = cleanContent;
      messageTables = tables;
    }

    return (
      <motion.div
        key={idx}
        initial={{ opacity: 0, y: 6 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.22, delay: idx * 0.01 }}
        className={`mb-2 ${isUser ? "flex justify-end" : "flex justify-start"}`}
      >
        <div
          className={`px-3 py-2 rounded-2xl max-w-[85%] whitespace-pre-wrap break-words text-sm ${isUser ? "bg-gradient-to-br from-indigo-600 to-purple-600 text-white" : "bg-white border text-gray-800"}`}
          style={{ boxShadow: isUser ? "0 6px 18px rgba(99,102,241,0.12)" : "none" }}
        >
          <div style={{ whiteSpace: "pre-wrap" }}>{messageContent}</div>

          {/* tables */}
          {Array.isArray(messageTables) && messageTables.length > 0 && (
            <div className="mt-3">{messageTables.map((t, i) => renderTable(t, i))}</div>
          )}

          {/* sources */}
          {Array.isArray(m.sources) && m.sources.length > 0 && (
            <div className="mt-3">{renderSources(m.sources)}</div>
          )}

          {/* loading indicator inline */}
          {m.loading && (
            <div className="mt-3 flex items-center gap-2 text-xs text-gray-500">
              <svg className="animate-spin h-4 w-4 text-gray-500" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="3" strokeDasharray="60" strokeLinecap="round" fill="none"></circle>
              </svg>
              Generating response...
            </div>
          )}
        </div>
      </motion.div>
    );
  };

  return (
    <div className="w-full flex justify-center px-4" ref={containerRef}>
      <div className={`w-full ${centeredWidth} mx-auto`}>

        {/* preview messages (keeps the UI as a minimal bar with helpful context) */}
        <div className="mb-4">
          {messages.slice(-PREVIEW_COUNT).map((m, idx) => (
            <div key={`preview-${idx}`}>
              {renderMessage(m, messages.length - PREVIEW_COUNT + idx >= 0 ? messages.length - PREVIEW_COUNT + idx : idx)}
            </div>
          ))}
        </div>

        {/* central pill input */}
        <div className="relative">
          <div
            className="flex items-center gap-3 px-3 py-2 rounded-full shadow-md bg-white border border-gray-100"
          >
            {/* Upload plus button */}
            <button
              onClick={triggerFileInput}
              title="Upload file"
              aria-label="Upload file"
              className="flex-none inline-flex items-center justify-center h-11 w-11 rounded-full bg-gradient-to-br from-pink-500 to-amber-500 text-white shadow-md hover:scale-105 transition-transform"
            >
              <FiPlus className="h-70 w-70" />
            </button>
            <input ref={fileInputRef} type="file" className="hidden" onChange={handleFileChange} />

            {/* Microphone */}
            <div className="flex-none">
              <MicrophoneButton onText={(t) => setText(t)} />
            </div>

            {/* Text area */}
            <textarea
              ref={textareaRef}
              value={text}
              onChange={(e) => setText(e.target.value)}
              rows={1}
              placeholder="Ask anything ‚Äî type a product name or say 'hi'..."
              onKeyDown={onKeyDown}
              onFocus={() => { if (suggestions && suggestions.length > 0) setShowSuggestions(true); }}
              className="flex-1 px-4 py-2 bg-white text-black placeholder-gray-400 text-sm resize-none outline-none"
              style={{ minHeight: 40 }}
            />

            {/* Send button */}
            <button
              onClick={submit}
              title="Send"
              className="flex-none inline-flex items-center justify-center h-11 w-11 rounded-full bg-indigo-600 text-white shadow hover:scale-95 transition"
            >
              {loading ? (
                <svg className="animate-spin h-5 w-5 text-white" viewBox="0 0 24 24">
                  <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="3" strokeDasharray="60" strokeLinecap="round" fill="none"></circle>
                </svg>
              ) : (
                <FiSend className="h-70 w-70" />
              )}
            </button>
          </div>

          {/* prompt gallery button centered below */}
          <div className="mt-3 flex justify-center">
            {typeof openPromptGallery === "function" && (
              <button
                onClick={() => openPromptGallery()}
                className="px-4 py-1.5 rounded-full bg-white border border-gray-100 shadow-sm hover:shadow-md text-sm font-medium"
              >
                Prompt gallery
              </button>
            )}
          </div>

          {/* suggestions dropdown */}
          {showSuggestions && suggestions && suggestions.length > 0 && (
            <div className="absolute left-0 right-0 z-40 mt-3 rounded-xl bg-white border shadow-lg overflow-hidden">
              <ul className="max-h-56 overflow-auto">
                {suggestions.map((s, i) => (
                  <li key={s.id}>
                    <button
                      className={`w-full text-left px-4 py-3 hover:bg-gray-50 flex justify-between items-center ${i === activeIndex ? "bg-gray-100" : ""}`}
                      onMouseDown={(e) => { e.preventDefault(); chooseSuggestion(s); }}
                      onMouseEnter={() => setActiveIndex(i)}
                    >
                      <div className="min-w-0">
                        <div className="font-medium text-sm text-gray-900 truncate">{s.name}</div>
                        <div className="text-xs text-gray-400 mt-1">{(s.reaction_type || "").replace(/_/g, " ")}</div>
                      </div>
                      <div className="text-xs text-gray-400 ml-4">Select</div>
                    </button>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>

      </div>
    </div>
  );
}
