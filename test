import os
import streamlit as st
import tempfile
import logging
from io import BytesIO
import json
import time
import google.auth
from vertexai.preview.generative_models import GenerativeModel, Image as GeminiImage, Part, HarmCategory, HarmBlockThreshold,SafetySetting
import fitz  # PyMuPDF
from xhtml2pdf import pisa

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Set up Vertex AI
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()
multimodal_model = GenerativeModel("gemini-pro-vision")

# Configure the Model and Safety settings
multimodal_model = GenerativeModel("gemini-pro-vision")

safety_config = [
    SafetySetting(
        category=HarmCategory.HARM_CATEGORY_UNSPECIFIED,
        threshold=HarmBlockThreshold.BLOCK_NONE,
    ),
    SafetySetting(
        category=HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
        threshold=HarmBlockThreshold.BLOCK_NONE,
    ),
    SafetySetting(
        category=HarmCategory.HARM_CATEGORY_HARASSMENT,
        threshold=HarmBlockThreshold.BLOCK_NONE,
    ),
    SafetySetting(
        category=HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold=HarmBlockThreshold.BLOCK_NONE,
    ),
    SafetySetting(
        category=HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
        threshold=HarmBlockThreshold.BLOCK_NONE,
    ),
]

def get_safe_extraction_prompt():
    return """Please Extract and analyze the document content with precise attention to layout and structure.
    Tasks:
    1. Identify sections, tables its rows coloumns cells, and lists in the document
    2. For tables:
       - Please Preserve exact column and row structure
       - Maintain cell alignments and spacing
       - Keep header rows distinct
    3. Extract text content preserving all formatting intact
    
    Format as JSON:
    {
        "elements": [
            {
                "type": "section|table|list",
                "content": "text content",
                "level": "heading level number",
                "indent": "number of spaces",
                "table_data": {
                    "headers": ["col1", "col2", ...],
                    "rows": [
                        ["cell1", "cell2", ...],
                        ["cell1", "cell2", ...]
                    ],
                    "column_alignments": ["left|center|right", ...]
                }
            }
        ]
    }
    
   Please Focus on accurately representing tables and maintaining exact document structure."""

def safe_gemini_call(image, max_retries=3, delay=2):
    """Make API calls with retry logic and safety filter handling"""
    prompt = get_safe_extraction_prompt()
    
    for attempt in range(max_retries):
        try:
            response = multimodal_model.generate_content(
                [
                    prompt,
                    image
                ],
                safety_settings=safety_config
            )
            
            if hasattr(response, 'text') and response.text:
                return response
            
            # Check for blocked content indication
            if "blocked" in response or "Candidate text" in response:
                raise ValueError("Content blocked by safety filters.")
                
        except Exception as e:
            logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
            if attempt < max_retries - 1:
                time.sleep(delay)
                continue
            raise
    
    raise Exception("Failed to get valid response after maximum retries")

    
    raise Exception("Failed to get valid response after maximum retries")

def translate_text(text, language):
    if not text:
        return ""
    
    prompt = f"""Please Provide a professional, accurate and complete translation from {language} to English 'as-is' without exceeding to any other content other than the document provided.
    Original text: {text}
    Rules:
    - Maintain all formatting and layout
    - Preserve technical terms
    - Keep document structure
    - For tables, translate cell contents while preserving alignment and format"""
    
    try:
        responses = multimodal_model.generate_content([prompt])
        return responses.text if hasattr(responses, 'text') else ''.join([r.text for r in responses])
    except Exception as e:
        logger.error(f"Translation error: {str(e)}")
        return text

def translate_table_data(table_data, language):
    """Translate table contents while preserving structure"""
    if not table_data:
        return table_data
    
    translated_data = {
        "headers": [translate_text(header, language) for header in table_data.get("headers", [])],
        "rows": [
            [translate_text(cell, language) for cell in row]
            for row in table_data.get("rows", [])
        ],
        "column_alignments": table_data.get("column_alignments", [])
    }
    return translated_data

def extract_images_from_pdf(pdf_file):
    images = []
    temp_pdf_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_pdf:
            temp_pdf.write(pdf_file.getvalue())
            temp_pdf_path = temp_pdf.name
        
        doc = fitz.open(temp_pdf_path)
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            pix = page.get_pixmap(matrix=fitz.Matrix(3, 3), alpha=False)
            image_bytes = pix.tobytes("png")
            images.append(image_bytes)
            logger.info(f"Extracted image from page {page_num}")
        
        doc.close()
        return images
    finally:
        if temp_pdf_path and os.path.exists(temp_pdf_path):
            try:
                os.unlink(temp_pdf_path)
            except Exception as e:
                logger.error(f"Error deleting temporary PDF file: {str(e)}")

def parse_json_response(response_text):
    try:
        start = response_text.find('{')
        end = response_text.rfind('}') + 1
        
        if start >= 0 and end > start:
            json_str = response_text[start:end]
            return json.loads(json_str)
    except json.JSONDecodeError as e:
        logger.error(f"JSON decoding error: {e}")
    except Exception as e:
        logger.error(f"General error in parsing JSON response: {e}")

    return {}

def parse_response(response):
    try:
        if isinstance(response, str):
            text = response
        elif hasattr(response, 'text'):
            text = response.text
        else:
            text = ''.join([r.text for r in response])

        parsed_json = parse_json_response(text)

        # Validate table data
        for element in parsed_json.get('elements', []):
            if element.get('type') == 'table':
                table_data = element.get('table_data', {})
                headers = table_data.get('headers', [])
                rows = table_data.get('rows', [])

                if not headers or not rows:
                    logger.warning(f"Skipping malformed table data: {table_data}")
                    parsed_json['elements'].remove(element)

        return parsed_json

    except Exception as e:
        logger.error(f"Error parsing response: {str(e)}")
    
    return {
        "elements": [
            {
                "type": "section",
                "content": str(text),
                "level": 1,
                "indent": 0
            }
        ]
    }



def create_table_html(table_data):
    """Generate HTML for table with proper styling"""
    headers = table_data.get("headers", [])
    rows = table_data.get("rows", [])

    # Check for empty headers or rows
    if not headers or not rows:
        logger.warning("Empty table data detected, skipping table.")
        return ""

    html = """
    <table style="width:100%; border-collapse: collapse; margin: 10px 0; table-layout: fixed;">
        <thead>
            <tr>
    """

    # Add headers with alignment
    alignments = table_data.get("column_alignments", ["left"] * len(headers))
    for header, alignment in zip(headers, alignments):
        html += f'<th style="border: 1px solid #ddd; padding: 8px; text-align: {alignment}; word-wrap: break-word; max-width: 100%;">{header}</th>'

    html += "</tr></thead><tbody>"

    # Add rows with alignment
    for row in rows:
        html += "<tr>"
        for cell, alignment in zip(row, alignments):
            html += f'<td style="border: 1px solid #ddd; padding: 8px; text-align: {alignment}; word-wrap: break-word; max-width: 100%;">{cell}</td>'
        html += "</tr>"

    html += "</tbody></table>"
    return html


def convert_to_html(parsed_data):
    """Convert parsed elements to HTML"""
    html_content = """
    <html>
    <head>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                margin: 20px; 
                line-height: 1.6;
            }
            .section {
                margin: 10px 0;
                white-space: pre-wrap;
            }
            .level-1 { margin-left: 0px; font-weight: bold; font-size: 1.2em; }
            .level-2 { margin-left: 20px; font-weight: bold; }
            .level-3 { margin-left: 40px; }
            .level-4 { margin-left: 60px; }
            table {
                width: 100%;
                max-width: 100%;
                word-wrap: break-word;
                table-layout: fixed;
                border-collapse: collapse;
                margin: 10px 0;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
                word-wrap: break-word;
                max-width: 100%;
            }
            th {
                background-color: #f5f5f5;
            }
        </style>
    </head>
    <body>
    """
    
    for element in parsed_data.get('elements', []):
        element_type = element.get('type', 'section')
        indent = int(element.get('indent', 0))
        level = int(element.get('level', 1))
        
        if element_type == 'table':
            html_content += create_table_html(element.get('table_data', {}))
        else:
            content = element.get('content', '')
            html_content += f"""
            <div class="section level-{level}" style="margin-left: {indent * 10}px">
                {content}
            </div>
            """
    
    html_content += "</body></html>"
    return html_content

def create_pdf(html_content):
    pdf_buffer = BytesIO()
    pisa_status = pisa.CreatePDF(
        BytesIO(html_content.encode('utf-8')),
        dest=pdf_buffer,
        encoding='utf-8'
    )
    pdf_buffer.seek(0)

    if pisa_status.err:
        logger.error("Failed to create PDF file.")
        return None

    return pdf_buffer



def process_document(image_data, language):
    """Process document with enhanced table handling"""
    try:
        response = safe_gemini_call(image_data)
        parsed_data = parse_response(response)
        
        translated_data = {"elements": []}
        for element in parsed_data.get('elements', []):
            if element.get('type') == 'table':
                # Handle table translation
                translated_table_data = translate_table_data(element.get('table_data', {}), language)
                translated_data['elements'].append({
                    "type": "table",
                    "table_data": translated_table_data,
                    "level": element.get('level', 1),
                    "indent": element.get('indent', 0)
                })
            else:
                # Handle regular content translation
                translated_content = translate_text(element.get('content', ''), language)
                translated_data['elements'].append({
                    "type": element.get('type', 'section'),
                    "content": translated_content,
                    "level": element.get('level', 1),
                    "indent": element.get('indent', 0)
                })
        
        return translated_data
    except Exception as e:
        logger.error(f"Document processing error: {str(e)}")
        raise

def main():
    st.title("Document Translator - Chinese & Japanese to English")
    
    option = st.selectbox("Select document type:", ["PDF", "Image"])
    
    if option == "PDF":
        uploaded_file = st.file_uploader("Upload PDF document", type="pdf")
    else:
        uploaded_file = st.file_uploader("Upload image", type=["png", "jpg", "jpeg"])
    
    language = st.selectbox("Source language:", ["Chinese", "Japanese"])
    
    if st.button("Translate"):
        if uploaded_file:
            try:
                with st.spinner('Processing document...'):
                    if option == "PDF":
                        images = extract_images_from_pdf(uploaded_file)
                        if not images:
                            st.error("Could not extract images from PDF.")
                            return
                        
                        combined_data = {"elements": []}
                        progress = st.progress(0)
                        
                        for idx, img_data in enumerate(images):
                            image = GeminiImage.from_bytes(img_data)
                            page_data = process_document(image, language)
                            combined_data['elements'].extend(page_data['elements'])
                            progress.progress((idx + 1) / len(images))
                        
                        html_content = convert_to_html(combined_data)
                        pdf_buffer = create_pdf(html_content)
                        
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                    
                    else:  # Single image
                        st.image(uploaded_file, caption='Original Document', use_column_width=True)
                        image = GeminiImage.from_bytes(uploaded_file.getvalue())
                        
                        translated_data = process_document(image, language)
                        
                        st.subheader("Translation Preview")
                        html_content = convert_to_html(translated_data)
                        st.markdown(html_content, unsafe_allow_html=True)
                        
                        pdf_buffer = create_pdf(html_content)
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                
            except Exception as e:
                st.error(f"An error occurred: {str(e)}")
                logger.exception("Processing error")
        else:
            st.error("Please upload a document to translate.")

if __name__ == "__main__":
    main()
