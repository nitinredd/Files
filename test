# ====================== START OF NEW ADDITION ======================
# Add this at the END of your existing code, RIGHT BEFORE the R_Regulation calls

import itertools
import math

def generate_all_time_combinations(times):
    """Generate all combinations from 3 to N time points"""
    n = len(times)
    if n < 3:
        return []
    
    all_combos = []
    for r in range(3, n+1):
        all_combos.extend(itertools.combinations(times, r))
    
    return [sorted(list(map(int, combo))) for combo in all_combos]

def calculate_combo_f2(ref_sub, test_sub):
    """Calculate f2 for a combination subset"""
    p = len(ref_sub)
    diff = test_sub.mean(axis=1) - ref_sub.mean(axis=1)
    sum_sq = (diff ** 2).sum()
    return 100 - 25 * np.log10(1 + (1/p) * sum_sq)

def regulatory_compliance(combo, regulation, ref_means, test_means):
    """Check regulation compliance for combination"""
    # Common requirement
    if len(combo) < 3:
        return False
    
    # FDA: Truncate when either reaches 85%
    if regulation == "FDA":
        ref_trunc = next((t for t in combo if ref_means[t] >= 85), None)
        test_trunc = next((t for t in combo if test_means[t] >= 85), None)
        trunc_point = min(ref_trunc or max(combo), test_trunc or max(combo))
        return combo[-1] <= trunc_point
    
    # EMA: Maintain <85% for both
    elif regulation in ["EMA", "ICH"]:
        return all(ref_means[t] < 85 for t in combo) and \
               all(test_means[t] < 85 for t in combo)
    
    # ANVISA: No restrictions
    elif regulation == "ANVISA":
        return True
    
    # China: Reference product only
    elif regulation == "China":
        return all(ref_means[t] < 85 for t in combo)
    
    # ASEAN: First 3 points under 85%
    elif regulation == "ASEAN":
        first_three = combo[:3] if len(combo)>=3 else combo
        return all(ref_means[t] < 85 for t in first_three) and \
               all(test_means[t] < 85 for t in first_three)
    
    return False

def full_combo_analysis(ref_df, test_df, regulation):
    """Complete combination analysis"""
    times = ref_df.iloc[:,0].tolist()
    ref_means = ref_df.iloc[:,1:].mean(axis=1)
    test_means = test_df.iloc[:,1:].mean(axis=1)
    
    # Generate all combinations
    all_combos = generate_all_time_combinations(times)
    total_combo = len(all_combos)
    print(f"\nAnalyzing {total_combo} time point combinations...")
    
    results = []
    for combo in all_combos:
        try:
            ref_sub = ref_df[ref_df.iloc[:,0].isin(combo)].sort_values(ref_df.columns[0])
            test_sub = test_df[test_df.iloc[:,0].isin(combo)].sort_values(test_df.columns[0])
            
            f2 = calculate_combo_f2(ref_sub, test_sub)
            compliant = regulatory_compliance(combo, regulation, ref_means, test_means)
            
            results.append({
                'times': combo,
                'f2': round(f2, 2),
                'points': len(combo),
                'compliant': compliant
            })
        except:
            continue
    
    return sorted(results, key=lambda x: (-x['f2'], x['points']))

def display_combo_analysis(results, regulation):
    """Display complete combination analysis"""
    print("\n" + "="*80)
    print(f" Complete Time Point Combination Analysis ({regulation})")
    print("="*80)
    print(f"Total Combinations Analyzed: {len(results)}")
    print("\nAll Combinations:")
    for res in results[:20]:  # Show top 20 for brevity
        status = "✅" if res['compliant'] else "❌"
        print(f"{res['times']} → f2: {res['f2']} ({status})")
    
    compliant_results = [r for r in results if r['compliant']]
    if compliant_results:
        best = max(compliant_results, key=lambda x: x['f2'])
        print(f"\nOptimal Compliant Combination:")
        print(f"Time Points: {best['times']}")
        print(f"f2 Score: {best['f2']}")
        print(f"Regulatory Rationale: {get_rationale(best, regulation)}")
    print("="*80 + "\n")

def get_rationale(combo, regulation):
    """Generate compliance explanation"""
    rationales = {
        "FDA": "Combination truncates when either product reaches 85% dissolution",
        "EMA": "All time points maintain <85% dissolution for both products",
        "ANVISA": "No dissolution limits applied",
        "China": "Reference product maintains <85% dissolution",
        "ASEAN": "First 3 time points under 85% dissolution"
    }
    return rationales.get(regulation, "Meets regulatory requirements")
# ====================== END OF NEW ADDITION ======================

# ====================== INTEGRATION POINTS ======================
# Add this in EACH regulation block (input1 cases) RIGHT AFTER original analysis

regulation_name_map = {
    1: "FDA",
    2: "EMA",
    3: "China",
    4: "ASEAN",
    5: "ANVISA"
}

if check_same_time_points(reference_df, test_df):
    combo_results = full_combo_analysis(reference_df, test_df, regulation_name_map[input1])
    display_combo_analysis(combo_results, regulation_name_map[input1])
else:
    print("\nTime point mismatch - Full combination analysis skipped")
