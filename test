import streamlit as st
st.set_page_config(page_title="PharmaAI: Advanced Drug Release Simulation", layout="wide")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve
from scipy.ndimage import gaussian_filter
import warnings
import shap
from xgboost import XGBRegressor

# Deep learning imports
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam

# Optimization libraries
from bayes_opt import BayesianOptimization
from deap import base, creator, tools, algorithms
from pyswarm import pso

warnings.filterwarnings("ignore")

# ---------------------- Custom Perlin-like Noise Function ----------------------
def simple_perlin(i, j, k, scale=10.0):
    """A simple Perlin-like noise using sine and cosine."""
    return np.sin(i/scale) * np.cos(j/scale) * np.sin(k/scale)

# ---------------------- Drug Release Models & Advanced PDE Solver ----------------------
def fickian_diffusion(t, D, R):
    """Fickian diffusion model using a series solution."""
    from math import pi
    terms = [np.exp(-D*(n**2)*pi**2*t/R**2)/n**2 for n in range(1, 50)]
    return 1 - (6/(pi**2)) * np.sum(terms, axis=0)

def erosion_controlled(t, k):
    """Erosion-controlled release: first-order kinetics."""
    return 1 - np.exp(-k*t)

def swelling_controlled(t, D, Sw):
    """Swelling-controlled release: simplified exponential behavior."""
    return 1 - np.exp(-D*t/Sw)

def higuchi_model(t, k):
    """Higuchi model: release proportional to sqrt(t)."""
    return k * np.sqrt(t)

def korsmeyer_peppas(t, k, n):
    """Korsmeyer-Peppas model: power law release."""
    return k * (t**n)

def advanced_fickian_pde_variable(D0, R0, k_degr, k_swelling, autocat_factor, gamma, time_points, MW=None, pH_input=None, num_nodes=200):
    # Parameter validation
    if R0 <= 0 or k_swelling < 0:
        raise ValueError("Invalid parameters: R0 must be >0, k_swelling >=0")
    
    MW_ref = 1e5  # Reference molecular weight (g/mol)
    D_eff_initial = D0 * (R0 ** gamma)
    if MW is not None and MW > 0:
        D_eff_initial *= (MW_ref / MW)
    
    # Time grid with adaptive time stepping
    t_eval = np.linspace(time_points[0], time_points[-1], 500)  # Increased resolution
    
    # Spatial grid (normalized coordinates)
    r = np.linspace(0, 1, num_nodes)
    dr = r[1] - r[0]
    
    # Initialize concentration profile
    C = np.ones(num_nodes)
    Mt = []
    
    for j in range(len(t_eval)):
        t_current = t_eval[j]
        
        # Calculate current parameters
        R_t = R0 * (1 + k_swelling * t_current)
        current_pH = pH_input if pH_input is not None else 7.4 - 2.0*(1 - np.exp(-0.1*t_current))
        k_degr_eff = k_degr * (1 + autocat_factor*(7.4 - current_pH))
        D_t = D_eff_initial * np.exp(k_degr_eff * t_current)
        
        # CFL condition check
        dt = t_eval[j] - t_eval[j-1] if j > 0 else 0
        alpha = D_t * dt / (dr**2)
        if alpha > 0.5:
            raise ValueError(f"Unstable simulation at t={t_current:.2f}. Reduce time step.")
        
        # Construct matrix
        main_diag = np.ones(num_nodes) * (1 + 2*alpha)
        lower_diag = -alpha * np.ones(num_nodes-1)
        upper_diag = -alpha * np.ones(num_nodes-1)
        
        # Boundary conditions
        # Symmetry at center (r=0)
        main_diag[0] = 1 + 2*alpha*(1 + dr/(2*R_t))
        upper_diag[0] = -2*alpha
        
        # Perfect sink at surface (r=R_t)
        main_diag[-1] = 1
        upper_diag[-1] = 0
        lower_diag[-1] = 0
        
        A = diags([lower_diag, main_diag, upper_diag], offsets=[-1, 0, 1], format='csr')
        C = spsolve(A, C)
        C = np.clip(C, 0, 1)  # Ensure physical solution
        
        # Calculate released fraction
        integral = np.trapz(C * (r**2), r)
        Mt.append(1 - 3*integral)
    
    return np.interp(time_points, t_eval, Mt)

# ---------------------- Enhanced 3D CFD Simulation Module ----------------------
def simulate_cfd_tissue_3d_enhanced(domain_size=30, dx=1.0, dt=0.1, total_time=10.0, 
                                    D_tissue=1e-6, advection=(0.0, 0.0, 0.0), 
                                    source_strength=100.0, turbulence=0.02):
    """
    Enhanced 3D CFD simulation using an explicit finite difference scheme.
    Uses custom simple_perlin noise for turbulence.
    Variable diffusion coefficient: D_field = D_tissue * (1 + 0.2 * noise).
    Returns the final 3D concentration field after total_time.
    """
    nx = ny = nz = domain_size
    nt = int(total_time / dt)
    C = np.zeros((nx, ny, nz))
    cx, cy, cz = nx//2, ny//2, nz//2
    C[cx-2:cx+3, cy-2:cy+3, cz-2:cz+3] = source_strength
    vx = np.zeros((nx, ny, nz))
    vy = np.zeros((nx, ny, nz))
    vz = np.zeros((nx, ny, nz))
    scale = 10.0
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                n_val = simple_perlin(i, j, k, scale)
                vx[i,j,k] = advection[0] * (1 + turbulence * n_val)
                vy[i,j,k] = advection[1] * (1 + turbulence * n_val)
                vz[i,j,k] = advection[2] * (1 + turbulence * n_val)
    D_field = np.zeros((nx, ny, nz))
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                n_val = simple_perlin(i, j, k, scale)
                D_field[i,j,k] = D_tissue * (1 + 0.2 * n_val)
    for t_step in range(nt):
        C_new = C.copy()
        for i in range(1, nx-1):
            for j in range(1, ny-1):
                for k in range(1, nz-1):
                    laplacian = (C[i+1,j,k] + C[i-1,j,k] +
                                 C[i,j+1,k] + C[i,j-1,k] +
                                 C[i,j,k+1] + C[i,j,k-1] - 6 * C[i,j,k]) / (dx**2)
                    ip = int(i - vx[i,j,k]*dt/dx)
                    jp = int(j - vy[i,j,k]*dt/dx)
                    kp = int(k - vz[i,j,k]*dt/dx)
                    ip = max(1, min(nx-2, ip))
                    jp = max(1, min(ny-2, jp))
                    kp = max(1, min(nz-2, kp))
                    C_new[i,j,k] = C[ip,jp,kp] + D_field[i,j,k] * laplacian * dt
        C_new = gaussian_filter(C_new, sigma=0.8)
        C = np.clip(C_new, 0, source_strength)
        C[0,:,:] = C[-1,:,:] = 0
        C[:,0,:] = C[:,-1,:] = 0
        C[:,:,0] = C[:,:,-1] = 0
    return C

# ---------------------- Monte Carlo Simulation Module ----------------------
def simulate_monte_carlo(num_simulations=50, time_range=10, num_points=100, param_bounds=None):
    if param_bounds is None:
        param_bounds = {
            'D0': (1e-16, 1e-8),
            'R0': (0.1, 5.0),
            'k_degr': (0.001, 1.0),
            'k_swelling': (0.0, 1.0),
            'autocat_factor': (0.0, 5.0),
            'gamma': (0.0, 3.0)
        }
    t = np.linspace(0, time_range, num_points)
    releases = []
    for _ in range(num_simulations):
        params_sample = {key: np.random.uniform(v[0], v[1]) for key, v in param_bounds.items()}
        Mt = advanced_fickian_pde_variable(
            params_sample['D0'],
            params_sample['R0'],
            params_sample['k_degr'],
            params_sample['k_swelling'],
            params_sample['autocat_factor'],
            params_sample['gamma'],
            t
        )
        releases.append(Mt)
    releases = np.array(releases)
    mean_release = np.mean(releases, axis=0)
    std_release = np.std(releases, axis=0)
    return {'time': t, 'mean_release': mean_release, 'std_release': std_release}

# ---------------------- MODELS Dictionary ----------------------
MODELS = {
    "Fickian Diffusion": {
        "function": lambda t, **params: fickian_diffusion(t, params['D0'], params['R0']),
        "params": ["D0", "R0"]
    },
    "Erosion-Controlled": {
        "function": lambda t, **params: erosion_controlled(t, params['k']),
        "params": ["k"]
    },
    "Swelling-Controlled": {
        "function": lambda t, **params: swelling_controlled(t, params['D0'], params['Sw']),
        "params": ["D0", "Sw"]
    },
    "Higuchi Model": {
        "function": lambda t, **params: higuchi_model(t, params['k']),
        "params": ["k"]
    },
    "Korsmeyer-Peppas": {
        "function": lambda t, **params: korsmeyer_peppas(t, params['k'], params['n']),
        "params": ["k", "n"]
    },
    "Advanced Fickian PDE (Variable D & Autocat)": {
        "function": lambda t, **params: advanced_fickian_pde_variable(
            params['D0'], params['R0'], params['k_degr'], params['k_swelling'],
            params['autocat_factor'], params['gamma'], t, MW=params['MW'], pH_input=params['pH']
        ),
        "params": ["D0", "R0", "k_degr", "k_swelling", "autocat_factor", "gamma", "MW", "pH"]
    }
}

# ---------------------- AI Optimization & Deep Learning (LSTM) & SHAP Analysis Module ----------------------
class AIOptimizer:
    def __init__(self, method='bayesian'):
        self.method = method
        
    def optimize(self, objective_func, param_space):
        if self.method == 'bayesian':
            return self._bayesian_optimization(objective_func, param_space)
        elif self.method == 'genetic':
            return self._genetic_algorithm(objective_func, param_space)
        elif self.method == 'pso':
            return self._particle_swarm(objective_func, param_space)
        
    def _bayesian_optimization(self, objective_func, param_space):
        optimizer = BayesianOptimization(f=objective_func, pbounds=param_space, verbose=2)
        optimizer.maximize(init_points=5, n_iter=20)
        return optimizer.max
    
    def _genetic_algorithm(self, objective_func, param_space):
        try:
            creator.create("FitnessMax", base.Fitness, weights=(1.0,))
        except Exception:
            pass
        try:
            creator.create("Individual", list, fitness=creator.FitnessMax)
        except Exception:
            pass
        toolbox = base.Toolbox()
        bounds = list(param_space.values())
        toolbox.register("attr_float", np.random.uniform, bounds[0][0], bounds[0][1])
        toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=len(param_space))
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        def eval_individual(individual):
            params = dict(zip(param_space.keys(), individual))
            return (objective_func(**params),)
        toolbox.register("evaluate", eval_individual)
        toolbox.register("mate", tools.cxBlend, alpha=0.5)
        toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
        toolbox.register("select", tools.selTournament, tournsize=3)
        population = toolbox.population(n=50)
        algorithms.eaSimple(population, toolbox, cxpb=0.5, mutpb=0.2, ngen=30, verbose=False)
        best_ind = tools.selBest(population, k=1)[0]
        return {'params': dict(zip(param_space.keys(), best_ind)), 'target': best_ind.fitness.values[0]}
    
    def _particle_swarm(self, objective_func, param_space):
        lb = [v[0] for v in param_space.values()]
        ub = [v[1] for v in param_space.values()]
        def wrapped_obj(x):
            return -objective_func(**dict(zip(param_space.keys(), x)))
        xopt, fopt = pso(wrapped_obj, lb, ub, swarmsize=50, maxiter=100)
        return {'params': dict(zip(param_space.keys(), xopt)), 'target': -fopt}

def generate_synthetic_release_data(num_samples=100, time_range=10, num_points=100):
    t = np.linspace(0, time_range, num_points)
    X_data = []
    y_data = []
    for _ in range(num_samples):
        params = {
            'D0': np.random.uniform(1e-16, 1e-8),
            'R0': np.random.uniform(0.3, 1.0),
            'k_degr': np.random.uniform(0.05, 0.2),
            'k_swelling': np.random.uniform(0.01, 0.1),
            'autocat_factor': np.random.uniform(0.5, 2.0),
            'gamma': np.random.uniform(1.5, 2.5),
            'MW': np.random.uniform(1e4, 1e6),
            'pH': np.random.uniform(6.5, 7.4)
        }
        release_curve = advanced_fickian_pde_variable(
            params['D0'], params['R0'], params['k_degr'], params['k_swelling'],
            params['autocat_factor'], params['gamma'], t, MW=params['MW'], pH_input=params['pH']
        )
        X_data.append(t.reshape(-1, 1))
        y_data.append(release_curve.reshape(-1, 1))
    X_data = np.array(X_data)
    y_data = np.array(y_data)
    return X_data, y_data

def train_lstm_release_curve(X_train, y_train, epochs=10, batch_size=16, learning_rate=0.001, dropout_rate=0.2):
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)),
        Dropout(dropout_rate),
        LSTM(25, return_sequences=True),
        Dense(1)
    ])
    optimizer = Adam(learning_rate=learning_rate)
    model.compile(optimizer=optimizer, loss='mse')
    model.fit(X_train, y_train, epochs=epochs, batch_size=batch_size, verbose=0)
    return model

# ---------------------- Sidebar Parameter Inputs ----------------------
if 'params' not in st.session_state:
    st.session_state.params = {
        'D0': 1e-8,
        'R0': 0.5,
        'k_degr': 0.1,
        'k_swelling': 0.05,
        'Sw': 2.0,
        'k': 0.1,
        'n': 0.5,
        'autocat_factor': 1.0,
        'gamma': 1.887,
        'MW': 1e5,
        'pH': 7.4
    }

with st.sidebar.expander("Core Parameters", expanded=True):
    input_method = st.radio("Input Method", ["Direct Input", "Calculate D (Stokes-Einstein)"], key="input_method")
    if input_method == "Direct Input":
        st.session_state.params['D0'] = st.number_input(
            "Initial Diffusion Coefficient D0 (cm¬≤/s)",
            min_value=1e-16, max_value=1e-8, value=st.session_state.params['D0'], format="%.1e", key="D0_input"
        )
    else:
        st.markdown("**Stokes-Einstein Calculator**")
        T = st.number_input("Temperature (K)", 273.0, 373.0, 298.0, key="T_input")
        r_particle = st.number_input("Particle Radius (m)", 1e-9, 1e-5, 1e-6, format="%.1e", key="r_particle")
        eta = st.number_input("Viscosity (Pa¬∑s)", 0.001, 10.0, 0.001, key="eta_input")
        k_B = 1.380649e-23
        if st.button("Calculate D0", key="calc_D0"):
            D_m2s = (k_B * T) / (6 * np.pi * eta * r_particle)
            st.session_state.params['D0'] = D_m2s * 1e4
            st.success(f"Calculated D0: {st.session_state.params['D0']:.2e} cm¬≤/s")
    st.session_state.params['R0'] = st.number_input("Initial Microsphere Radius R0 (cm)", 0.1, 5.0, st.session_state.params['R0'], step=0.1, key="R0_input")
    st.session_state.params['k_degr'] = st.number_input("Polymer Degradation Rate Constant k_degr (1/hr)", 0.001, 1.0, st.session_state.params['k_degr'], step=0.001, key="k_degr_input")
    st.session_state.params['k_swelling'] = st.number_input("Swelling Rate Constant k_swelling (1/hr)", 0.0, 1.0, st.session_state.params['k_swelling'], step=0.001, key="k_swelling_input")
    st.session_state.params['Sw'] = st.number_input("Swelling Factor (Sw)", 0.1, 10.0, st.session_state.params['Sw'], step=0.1, key="Sw_input")
    st.session_state.params['k'] = st.number_input("Release Constant k", 0.001, 2.0, st.session_state.params['k'], step=0.001, key="k_input")
    st.session_state.params['n'] = st.number_input("Release Exponent n", 0.1, 1.0, st.session_state.params['n'], step=0.01, key="n_input")
    st.session_state.params['autocat_factor'] = st.number_input("Autocatalysis Factor", 0.0, 5.0, st.session_state.params['autocat_factor'], step=0.1, key="autocat_factor_input")
    st.session_state.params['gamma'] = st.number_input("Size-Dependence Exponent (Œ≥)", 0.0, 3.0, st.session_state.params['gamma'], step=0.01, key="gamma_input")
    st.session_state.params['MW'] = st.number_input("Molecular Weight (g/mol)", value=st.session_state.params['MW'], key="MW_input")
    st.session_state.params['pH'] = st.number_input("pH Value", min_value=0.0, max_value=14.0, value=st.session_state.params['pH'], step=0.1, key="pH_input")

time_range = st.sidebar.slider("Simulation Time (hours)", 0.1, 48.0, 10.0, key="time_range")
num_points = st.sidebar.slider("Data Points", 50, 1000, 200, key="num_points")

# ---------------------- Main Interface with Tabs ----------------------
tab1, tab2, tab3, tab4 = st.tabs(["Drug Release", "3D Simulation", "Monte Carlo Simulation", "AI & SHAP Analysis"])

# ----- Tab 1: Drug Release Simulation -----
with tab1:
    st.header("üìà Drug Release Profile")
    t = np.linspace(0, time_range, num_points)
    try:
        # Use the model choice from sidebar (with a unique key)
        model_choice = st.sidebar.selectbox("Select Release Model", list(MODELS.keys()), key="release_model")
        model_config = MODELS[model_choice]
        params = { key: st.session_state.params[key] for key in model_config["params"] }
        Mt = model_config["function"](t, **params)
        Mt = np.clip(Mt, 0, 1)
        release_rate = np.gradient(Mt, t)
        
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(t, Mt, 'b-', linewidth=2, label="Fraction Released")
        ax.set_xlabel("Time (hours)")
        ax.set_ylabel("Fraction Released")
        ax.set_title(f"{model_choice} Release Profile")
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)
        
        fig_rate, ax_rate = plt.subplots(figsize=(10, 4))
        ax_rate.plot(t, release_rate, 'r--', linewidth=2, label="Release Rate")
        ax_rate.set_xlabel("Time (hours)")
        ax_rate.set_ylabel("Release Rate (1/hour)")
        ax_rate.set_title("Instantaneous Release Rate")
        ax_rate.grid(True, alpha=0.3)
        st.pyplot(fig_rate)
        
        df = pd.DataFrame({"Time (hours)": t, "Fraction Released": Mt, "Release Rate": release_rate})
        st.download_button("üì• Export CSV", data=df.to_csv(index=False), file_name="drug_release_data.csv", mime="text/csv")
    except Exception as e:
        st.error(f"Simulation error: {str(e)}")

# ----- Tab 2: 3D Simulation (CFD) -----
with tab2:
    st.header("üåê 3D Simulation of Drug Transport")
    st.markdown("This simulation models drug transport in a 3D tissue domain using an explicit finite difference scheme with variable diffusion and refined turbulence (via a custom Perlin-like noise function).")
    domain_size = st.number_input("Domain Size (grid points per side)", 20, 100, 30, key="domain_size_tab2")
    dx = st.number_input("Spatial Resolution (mm)", 0.1, 10.0, 1.0, key="dx_tab2")
    dt_cfd = st.number_input("Time Step (s)", 0.001, 1.0, 0.1, key="dt_cfd_tab2")
    total_time = st.number_input("Total Simulation Time (s)", 1, 100, 10, key="total_time_tab2")
    D_tissue = st.number_input("Tissue Diffusion Coefficient (mm¬≤/s)", 1e-6, 1e-2, 1e-3, format="%.1e", key="D_tissue_tab2")
    advect_x = st.number_input("Advection Speed in X (mm/s)", -1.0, 1.0, 0.0, step=0.1, key="advect_x_tab2")
    advect_y = st.number_input("Advection Speed in Y (mm/s)", -1.0, 1.0, 0.0, step=0.1, key="advect_y_tab2")
    advect_z = st.number_input("Advection Speed in Z (mm/s)", -1.0, 1.0, 0.0, step=0.1, key="advect_z_tab2")
    try:
        C_3d = simulate_cfd_tissue_3d_enhanced(domain_size, dx, dt_cfd, total_time, D_tissue, 
                                               advection=(advect_x, advect_y, advect_z))
        grid = np.linspace(0, domain_size-1, domain_size)
        X, Y, Z = np.meshgrid(grid, grid, grid)
        fig_cfd = go.Figure(data=go.Isosurface(
            x=X.flatten(), y=Y.flatten(), z=Z.flatten(),
            value=C_3d.flatten(),
            isomin=0,
            isomax=C_3d.max(),
            surface_count=25,
            colorscale='jet',
            caps=dict(x_show=False, y_show=False, z_show=False),
            opacity=0.6
        ))
        fig_cfd.update_layout(
            title="3D Tissue Drug Concentration Isosurface",
            scene=dict(
                xaxis_title="X (mm)",
                yaxis_title="Y (mm)",
                zaxis_title="Z (mm)"
            )
        )
        st.plotly_chart(fig_cfd, use_container_width=True)
    except Exception as e:
        st.error(f"3D CFD simulation error: {str(e)}")

# ----- Tab 3: Monte Carlo Simulation -----
with tab3:
    st.header("üé≤ Monte Carlo Simulation for Microparticle Heterogeneity")
    num_simulations = st.number_input("Number of Monte Carlo Simulations", 10, 200, 50, key="mc_num_tab3")
    try:
        mc_results = simulate_monte_carlo(num_simulations, time_range, num_points)
        fig_mc, ax_mc = plt.subplots(figsize=(10, 6))
        ax_mc.plot(mc_results['time'], mc_results['mean_release'], 'b-', label="Mean Release")
        ax_mc.fill_between(mc_results['time'], mc_results['mean_release'] - mc_results['std_release'],
                           mc_results['mean_release'] + mc_results['std_release'], color='blue', alpha=0.3, label="Std Dev")
        ax_mc.set_xlabel("Time (hours)")
        ax_mc.set_ylabel("Fraction Released")
        ax_mc.set_title("Monte Carlo Simulation of Drug Release (Heterogeneity)")
        ax_mc.legend()
        st.pyplot(fig_mc)
    except Exception as e:
        st.error(f"Monte Carlo simulation error: {str(e)}")

# ----- Tab 4: AI Optimization, LSTM, & SHAP Analysis -----
with tab4:
    st.header("ü§ñ AI Optimization & Deep Learning for Release Curve Prediction")
    method_choice = st.radio("Select Prediction Method", ["Traditional AI Optimization", "Deep Learning (LSTM)"], key="pred_method_tab4")
    
    param_space = {
        'D0': (1e-16, 1e-8),
        'R0': (0.1, 5.0),
        'k_degr': (0.001, 1.0),
        'k_swelling': (0.0, 1.0),
        'autocat_factor': (0.0, 5.0),
        'gamma': (0.0, 3.0),
        'k': (0.001, 2.0),
        'n': (0.1, 1.0)
    }
    def objective(**params):
        t = np.linspace(0, 10, 100)
        release1 = fickian_diffusion(t, params['D0'], params['R0'])
        release2 = korsmeyer_peppas(t, params['k'], params['n'])
        return np.mean(release1 + release2)
    
    if method_choice == "Traditional AI Optimization":
        opt_method = st.selectbox("Select Optimization Algorithm", ["bayesian", "genetic", "pso"], key="opt_algo_tab4")
        if st.button("Run AI Optimization", key="run_opt_tab4"):
            try:
                optimizer = AIOptimizer(opt_method)
                result = optimizer.optimize(objective, param_space)
                st.success(f"Optimized Release Efficiency: {result['target']*100:.2f}%")
                st.write("Optimized Parameters:", result['params'])
                st.session_state.params.update(result['params'])
            except Exception as e:
                st.error(f"Optimization failed: {str(e)}")
    else:
        st.subheader("Deep Learning (LSTM) Prediction")
        st.markdown("Configure LSTM training parameters:")
        lstm_epochs = st.number_input("LSTM Training Epochs", min_value=1, value=10, step=1, key="lstm_epochs_tab4")
        lstm_batch_size = st.number_input("LSTM Batch Size", min_value=1, value=16, step=1, key="lstm_batch_tab4")
        lstm_learning_rate = st.number_input("LSTM Learning Rate", min_value=1e-6, value=0.001, format="%.6f", key="lstm_lr_tab4")
        lstm_dropout = st.number_input("LSTM Dropout Rate", min_value=0.0, max_value=1.0, value=0.2, step=0.05, key="lstm_dropout_tab4")
        st.markdown("Generating synthetic release data for LSTM training...")
        X_synth, y_synth = generate_synthetic_release_data(num_samples=100, time_range=10, num_points=100)
        st.write("Training LSTM model...")
        lstm_model = train_lstm_release_curve(X_synth, y_synth, epochs=lstm_epochs, batch_size=lstm_batch_size, learning_rate=lstm_learning_rate, dropout_rate=lstm_dropout)
        st.success("LSTM model trained.")
        test_idx = np.random.randint(0, X_synth.shape[0])
        X_test = X_synth[test_idx:test_idx+1]
        y_true = y_synth[test_idx:test_idx+1]
        y_pred = lstm_model.predict(X_test)
        fig_lstm, ax_lstm = plt.subplots(figsize=(10, 6))
        t = np.linspace(0, 10, 100)
        ax_lstm.plot(t, y_true.flatten(), 'b-', label="True Release Curve")
        ax_lstm.plot(t, y_pred.flatten(), 'r--', label="LSTM Predicted")
        ax_lstm.set_xlabel("Time (hours)")
        ax_lstm.set_ylabel("Fraction Released")
        ax_lstm.set_title("LSTM Release Curve Prediction")
        ax_lstm.legend()
        st.pyplot(fig_lstm)
    
    st.markdown("### SHAP Analysis")
    if st.button("Run SHAP Analysis", key="run_shap_tab4"):
        try:
            X = np.random.rand(100, len(param_space))
            y = np.array([objective(**dict(zip(param_space.keys(), x))) for x in X])
            model = XGBRegressor(n_estimators=100, max_depth=3)
            model.fit(X, y)
            explainer = shap.Explainer(model)
            shap_values = explainer(X[:50])
            st.subheader("Feature Importance (SHAP Summary)")
            fig_shap, ax_shap = plt.subplots()
            shap.summary_plot(shap_values, X[:50], feature_names=list(param_space.keys()), show=False)
            st.pyplot(fig_shap)
        except Exception as e:
            st.error(f"SHAP analysis failed: {str(e)}")
