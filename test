import numpy as np
import math
import pandas as pd

def calculate_mean_profile(df):
    """Calculate validated mean profile with precision control"""
    times = df.iloc[:, 0].astype(float).values.round(2)
    values = df.iloc[:, 1:].astype(float)
    return pd.DataFrame({
        'Time': times,
        'Mean': values.mean(axis=1).round(2)
    })

def create_optimized_profile(times, means, step=0.25, window_max=12):
    """Create precision-controlled monotonic profile"""
    grid = np.round(np.arange(0, window_max + step, step), 2)
    profile = np.interp(grid, times, means, left=0.0, right=means[-1])
    return np.maximum.accumulate(profile), grid

def select_f2_optimized_points(ref, test, grid, brackets):
    """Select points maximizing F2 potential while meeting criteria"""
    candidates = []
    for i, (r, t) in enumerate(zip(ref, test)):
        if i == 0:  # Always include 0 point
            candidates.append((i, r, t))
            continue
            
        diff = abs(r - ref[i-1])
        if diff >= 7 and r < 85 and t < 85:
            candidates.append((i, r, t))
    
    # Select best F2 candidates per bracket
    selected = [0]
    current_bracket = 0
    last_r = 0
    
    for bracket in brackets:
        bracket_candidates = [
            (i, r, t) for i, r, t in candidates
            if bracket[0] <= r < bracket[1]
        ]
        
        # Select up to 2 best F2 candidates in bracket
        sorted_candidates = sorted(
            bracket_candidates,
            key=lambda x: -abs(x[2]-x[1])  # Prefer similar values
        )[:2]
        
        selected.extend([i for i, _, _ in sorted_candidates])
    
    return sorted(list(set(selected)))

def calculate_enhanced_f2(ref_vals, test_vals):
    """Enhanced F2 calculation with precision control"""
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    if diffs.size == 0:
        return 100.0  # Perfect score if no differences
    
    rsd = np.sqrt(np.mean(np.square(diffs)))
    if rsd < 1e-4:  # Prevent math domain error
        return 100.0
    
    return 50 * math.log10(100 / (1 + rsd))

def format_output_values(values):
    """Ensure native Python types and precision"""
    return [round(float(v), 2) for v in values]

def predictive_optimal_combinations_monotonic(reference_df, test_df,
                                            regulation, window_max=12,
                                            step_hours=0.25):
    # Calculate precision-controlled profiles
    ref_mean = calculate_mean_profile(reference_df)
    test_mean = calculate_mean_profile(test_df)

    # Create optimized profiles
    ref_prof, grid = create_optimized_profile(
        ref_mean.Time.values, 
        ref_mean.Mean.values,
        step_hours, 
        window_max
    )
    test_prof, _ = create_optimized_profile(
        test_mean.Time.values,
        test_mean.Mean.values,
        step_hours,
        window_max
    )

    # F2-optimized point selection
    brackets = [(0,30), (30,60), (60,80)]
    selected_indices = select_f2_optimized_points(ref_prof, test_prof, grid, brackets)
    
    # Regulation-specific 85% handling
    eighty_five_idx = None
    for i in range(len(grid)):
        if regulation in ("FDA", "ANVISA") and ref_prof[i] >= 85 and test_prof[i] >= 85:
            eighty_five_idx = i
            break
        elif regulation not in ("FDA", "ANVISA") and (ref_prof[i] >= 85 or test_prof[i] >= 85):
            eighty_five_idx = i
            break
    
    if eighty_five_idx is not None and eighty_five_idx not in selected_indices:
        selected_indices.append(eighty_five_idx)
    
    # Finalize time points
    selected_indices = sorted(np.unique(selected_indices))
    time_points = [grid[i].item() for i in selected_indices]  # Convert to native float
    
    # Convert to native Python types
    clean_times = []
    for t in time_points:
        if abs(t - round(t)) < 1e-4:
            clean_times.append(int(round(t)))
        else:
            clean_times.append(round(float(t), 2))
    
    # Final F2 calculation
    ref_values = format_output_values([ref_prof[i] for i in selected_indices])
    test_values = format_output_values([test_prof[i] for i in selected_indices])
    f2_score = calculate_enhanced_f2(ref_values, test_values)
    
    return [{
        'sequence': clean_times,
        'f2': round(f2_score, 2),
        'compliant': f2_score >= 50,
        'reasons': [],
        'ref_vals': ref_values,
        'test_vals': test_values
    }], None
