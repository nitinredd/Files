import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
from tqdm import tqdm
from scipy.interpolate import interp1d
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, WhiteKernel, ConstantKernel as C
import warnings
import csv

def plot_dissolution_curves(ref_df, test_df, best_sequence):
    """Plot dissolution curves with optimal time points"""
    plt.figure(figsize=(12, 6))
    
    # Plot reference data
    plt.plot(ref_df.iloc[:,0], ref_df.iloc[:,1:].mean(axis=1), 
             'bo-', label='Reference Mean')
    # Plot test data
    plt.plot(test_df.iloc[:,0], test_df.iloc[:,1:].mean(axis=1),
             'r^--', label='Test Mean')
    
    # Plot optimal time points
    for t in best_sequence:
        plt.axvline(x=t, color='g', linestyle=':', alpha=0.5, 
                   label=f'Optimal Point {t}min' if t == best_sequence[0] else "")
    
    plt.title(f'Optimal Dissolution Profile\nTime Points: {best_sequence}')
    plt.xlabel('Time (minutes)')
    plt.ylabel('Dissolution (%)')
    plt.legend()
    plt.grid(True)
    plt.savefig('optimal_dissolution_profile.png', dpi=300)
    plt.close()

def generate_time_points(window_min, window_max, max_diss):
    """Generate time points with 3+5 minute steps for dissolution ≤60%"""
    if max_diss <= 60:
        # Combine 3 and 5 minute steps
        times_3 = list(range(0, window_max+1, 3))
        times_5 = list(range(0, window_max+1, 5))
        valid_times = sorted(list(set(times_3 + times_5)))
    else:
        # Use only 5 minute steps
        valid_times = list(range(0, window_max+1, 5))
    
    return [t for t in valid_times if window_min <= t <= window_max]

def predictive_optimal_combinations(ref_df, test_df, regulation, 
                                   window_min, window_max, 
                                   num_samples=10000, top_n=500):
    """Robust version with proper type handling and segmentation"""
    # Initialization
    results = []
    window_min = int(window_min)
    window_max = int(window_max)
    
    # Convert to numpy arrays with integer conversion
    ref_times = ref_df.iloc[:,0].values.astype(int)
    ref_diss = ref_df.iloc[:,1].values.astype(float)
    test_times = test_df.iloc[:,0].values.astype(int)
    test_diss = test_df.iloc[:,1].values.astype(float)

    # Create interpolation functions
    ref_interp = interp1d(ref_times, ref_diss, 
                         bounds_error=False, fill_value="extrapolate")
    test_interp = interp1d(test_times, test_diss,
                          bounds_error=False, fill_value="extrapolate")

    # Generate time points
    time_grid = np.arange(window_min, window_max + 1)
    max_diss = max(np.nanmax(ref_interp(time_grid)), 
                np.nanmax(test_interp(time_grid)))
    valid_times = generate_time_points(window_min, window_max, max_diss)

    # Main processing
    start_time = time.time()
    top_results = []
    
    with tqdm(total=num_samples, desc="Generating combinations") as pbar:
        for _ in range(num_samples):
            try:
                # Generate sequence with proper integer handling
                seq_length = np.random.randint(3, 7)
                seq = sorted([0, window_max] + list(np.random.choice(
                    [t for t in valid_times if 0 < t < window_max],
                    size=seq_length-2,
                    replace=False
                )))
                
                # Convert to Python integers
                seq = [int(t) for t in seq]
                
                # Get dissolution values
                ref_vals = ref_interp(seq)
                test_vals = test_interp(seq)
                
                # Calculate F2
                diff = test_vals - ref_vals
                sum_sq = np.nansum(diff**2)
                p = len(seq)
                f2 = 100 - 25 * np.log10(1 + (sum_sq/p))
                
                # Check compliance
                compliant, reasons = check_regulatory_compliance(
                    seq, regulation,
                    dict(zip(seq, ref_vals)),
                    dict(zip(seq, test_vals))
                )
                
                # Store top results
                result = {
                    'sequence': seq,
                    'f2': round(f2, 2),
                    'compliant': compliant,
                    'reasons': reasons,
                    'dissolution_range': get_dissolution_range(seq, ref_interp, test_interp)
                }
                
                # Maintain top N results
                if len(top_results) < top_n:
                    top_results.append(result)
                else:
                    min_f2 = min(top_results, key=lambda x: x['f2'])['f2']
                    if f2 > min_f2:
                        top_results.append(result)
                        top_results.sort(key=lambda x: -x['f2'])
                        top_results = top_results[:top_n]
                
            except Exception as e:
                pass  # Skip invalid combinations
                
            pbar.update(1)

    # Process results
    top_results.sort(key=lambda x: -x['f2'])
    df = pd.DataFrame(top_results)
    
    # Generate reports
    generate_reports(df, regulation)
    
    print(f"\nProcessed {num_samples} combinations in {time.time()-start_time:.2f}s")
    return df

def get_dissolution_range(seq, ref_interp, test_interp):
    """Categorize sequence into dissolution ranges"""
    max_diss = max(np.nanmax(ref_interp(seq)), np.nanmax(test_interp(seq)))
    if max_diss <= 30:
        return "0-30%"
    elif max_diss <= 60:
        return "30-60%"
    else:
        return "60-100%"

def generate_reports(df, regulation):
    """Generate CSV and segmented reports"""
    # Save top results to CSV
    df.to_csv('top_combinations.csv', index=False)
    
    # Generate segmented reports
    with open('compliance_report.txt', 'w') as f:
        f.write(f"Regulatory Compliance Report ({regulation})\n")
        f.write("="*50 + "\n")
        
        for range_name in ["0-30%", "30-60%", "60-100%"]:
            subset = df[df['dissolution_range'] == range_name]
            f.write(f"\n{range_name} Dissolution Range:\n")
            f.write(f"Compliant Combinations: {len(subset[subset['compliant'])}\n")
            f.write(f"Non-compliant Combinations: {len(subset[~subset['compliant'])}\n")
            if not subset.empty:
                f.write("Top 5 Reasons for Non-compliance:\n")
                reasons = subset[~subset['compliant']]['reasons'].explode().value_counts().head(5)
                f.write(str(reasons) + "\n")

def check_regulatory_compliance(seq, regulation, ref_values, test_values):
    """Enhanced compliance checking with detailed reasons"""
    compliant = True
    reasons = []
    
    # Basic requirements
    if len(seq) < 3:
        compliant = False
        reasons.append("Minimum 3 time points required")
    if seq[0] != 0:
        compliant = False
        reasons.append("Missing initial time point (0)")
    
    # Regulation-specific checks
    if regulation == "FDA":
        last_point = seq[-1]
        if (ref_values.get(last_point, 0) < 85) and (test_values.get(last_point, 0) < 85):
            compliant = False
            reasons.append("Final dissolution <85% for both products")
    
    elif regulation == "EMA":
        if len(seq) < 4:
            compliant = False
            reasons.append("EMA requires ≥4 time points")
        if any(v >= 85 for v in ref_values.values()):
            compliant = False
            reasons.append("Reference dissolution ≥85%")
    
    return compliant, reasons

# In your main code after regulatory checks:
run_predictive = input("\nRun predictive combination analysis? (yes/no): ")
if run_predictive.lower() == 'yes':
    # Determine candidate window
    window_min, window_max = determine_candidate_window(
        reference_df, test_df, step=5, initial_threshold=10
    )
    
    # Run analysis
    top_combinations = predictive_optimal_combinations(
        reference_df, test_df, 
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        num_samples=10000,
        top_n=500
    )
    
    # Plot best combination
    if not top_combinations.empty:
        best_seq = top_combinations.iloc[0]['sequence']
        plot_dissolution_curves(reference_df, test_df, best_seq)
        print(f"\nOptimal sequence: {best_seq}")
        print(f"Saved visualization to optimal_dissolution_profile.png")
    else:
        print("\nNo valid combinations found")
