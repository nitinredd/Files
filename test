def predictive_optimal_combinations_greedy(ref_df, test_df, regulation,
                                            window_min, window_max,
                                            step_hours=0.25):
    """
    Greedy selection of candidate times to maximize f2.
    - Builds a fine grid from window_min to window_max (step_hours),
      *prepends* 0.0 h to the grid (with forced 0% dissolution).
    - Always includes 0.0 in the sequence (excluded from f2 calc).
    - Iteratively adds the time point that yields the largest incremental f2 gain
      until we have 7 points (non-FDA) or 8 points (FDA/ANVISA).
    """
    # 1) Build grid including t=0
    grid = np.arange(window_min, window_max + 1e-8, step_hours)
    valid_times   = np.concatenate(([0.0], grid))
    all_ref_pred  = np.array(interpolate_linear(ref_df,  valid_times), dtype=float)
    all_test_pred = np.array(interpolate_linear(test_df, valid_times), dtype=float)

    fixed_zero = 0.0
    target_n   = 8 if regulation in ("FDA", "ANVISA") else 7

    # 2) f2 calculator for any candidate sequence
    def compute_f2(seq):
        idxs = [int(np.where(valid_times == t)[0][0]) for t in seq]
        ref_vals  = all_ref_pred[idxs].copy()
        test_vals = all_test_pred[idxs].copy()
        # force 0% at t=0
        if seq[0] == fixed_zero:
            ref_vals[0] = test_vals[0] = 0.0
        diffs = test_vals[1:] - ref_vals[1:]
        mse   = np.mean(diffs ** 2)
        return 50 * math.log10(100 / (1 + math.sqrt(mse)))

    # 3) Start with t=0
    candidate = [fixed_zero]

    # 4) Greedily add best time until we reach target_n
    while len(candidate) < target_n:
        best_t, best_f2 = None, -np.inf
        for t in valid_times:
            if t in candidate:
                continue
            trial = sorted(candidate + [t])
            f2_try = compute_f2(trial)
            if f2_try > best_f2:
                best_f2, best_t = f2_try, t
        candidate.append(best_t)

    candidate = sorted(candidate)

    # 5) Final f2 & assemble output
    final_f2 = compute_f2(candidate)
    # get corresponding ref/test values at those times
    idxs = [int(np.where(valid_times == t)[0][0]) for t in candidate]
    ref_vals_seq  = [float(all_ref_pred[i])  for i in idxs]
    test_vals_seq = [float(all_test_pred[i]) for i in idxs]

    return [{
        'sequence':  candidate,
        'f2':        round(final_f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals_seq,
        'test_vals': test_vals_seq
    }], None
################################
if input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Criteria & CV
    both_85 = check_both_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:   ", both_85)

    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # (0) Drop t=0 rows
    reference_df = reference_df[reference_df.iloc[:,0] != 0].reset_index(drop=True)
    test_df      = test_df[test_df.iloc[:,0] != 0].reset_index(drop=True)

    # 2) Verify alignment
    if not check_same_time_points(reference_df, test_df):
        print("Error: Time points do not match. Cannot proceed.")
    else:
        try:
            # 3) FDA f2 & trimming
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)
            # [existing code to print & plot trimmed results]
        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA-rule f2 calculation.")

    # 4) Predictive analysis?
    run_predictive = input("\nDo you want to run predictive optimal combination analysis? (yes/no): ")
    if run_predictive.lower() == 'yes':
        window_min, window_max = determine_candidate_window(
            reference_mean_df, test_mean_df, step=5, initial_threshold=10
        )
        regulation_map     = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
        selected_regulation = regulation_map.get(input1, "FDA")
        print(f"\nCandidate window: {window_min} to {window_max}\n")

        # Try original; if it errors, go straight to greedy
        try:
            results, _ = predictive_optimal_combinations_advanced(
                reference_mean_df,
                test_mean_df,
                regulation         = selected_regulation,
                window_min         = window_min,
                window_max         = window_max,
                diff_threshold     = None,
                interp_method      = 'linear',
                points_per_stratum = None
            )
            print("✅ Used original integer‐grid function\n")
        except ValueError as e:
            print(f"⚠️ Original function failed: {e}")
            print("   Using greedy f2-maximizing selection...\n")
            results, _ = predictive_optimal_combinations_greedy(
                reference_mean_df,
                test_mean_df,
                selected_regulation,
                window_min,
                window_max,
                step_hours=0.25
            )

        # Normalize seq: ints stay ints, others float
        for cand in results:
            cand['sequence'] = [
                int(t) if float(t).is_integer() else t
                for t in cand['sequence']
            ]

        best = results[0]
        print("=== Optimal Predictive Combination ===")
        print(f"Time Points: {best['sequence']}")
        print(f"Predicted f2 Score: {best['f2']}")

        # Plot predicted dissolution
        import matplotlib.pyplot as plt
        from matplotlib.ticker import MaxNLocator

        seq = best['sequence']
        ref_diss  = interpolate_dissolution_curve(reference_mean_df, np.array(seq), method='linear')
        test_diss = interpolate_dissolution_curve(test_mean_df,      np.array(seq), method='linear')

        plt.figure(figsize=(12, 6))
        plt.plot(seq, ref_diss,  'bo-', label='Reference')
        plt.plot(seq, test_diss, 'r*--', label='Test')
        plt.title(f"Optimal Profile: Predicted Dissolution (f2 = {best['f2']})")
        plt.xlabel('Time (h)')
        plt.ylabel('Dissolution (%)')
        plt.grid(True)
        plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
        plt.legend()
        plt.show()

        # Display predicted percentages
        print("\nPredicted Reference Dissolution (%):")
        for t, d in zip(seq, ref_diss):
            print(f"  {t} h: {d:.2f}%")
        print("\nPredicted Test Dissolution (%):")
        for t, d in zip(seq, test_diss):
            print(f"  {t} h: {d:.2f}%")

        # List all candidates
        print("\n=== All Candidate Combinations ===")
        for i, cand in enumerate(results, 1):
            print(f"{i:2d}. Points: {cand['sequence']} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
