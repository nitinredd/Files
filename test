# -------------------------- PREDICTIVE ANALYSIS IMPORTS --------------------------
import itertools
from scipy.interpolate import interp1d
from joblib import Parallel, delayed, parallel_backend
# -------------------------- PREDICTIVE ANALYSIS FUNCTIONS --------------------------
def interpolate_linear(df, new_times):
    df_sorted = df.sort_values(by=df.columns[0])
    known_times = df_sorted.iloc[:, 0].values.astype(float)
    known_values = df_sorted.iloc[:, 1].values
    f = interp1d(known_times, known_values, kind='linear', 
                fill_value=(known_values[0], known_values[-1]),
                bounds_error=False)
    return f(new_times)

def determine_candidate_window(ref_df, test_df, step=1, initial_threshold=10):
    max_ref_time = ref_df.iloc[:, 0].max()
    max_test_time = test_df.iloc[:, 0].max()
    fixed_max = max(max_ref_time, max_test_time)
    
    times = np.arange(0, fixed_max + 1, step)
    ref_vals = interpolate_linear(ref_df, times)
    test_vals = interpolate_linear(test_df, times)
    diff = np.abs(ref_vals - test_vals)
    
    valid_times = times[diff <= initial_threshold]
    if len(valid_times) == 0:
        valid_times = times[diff <= 20]
        return (0, valid_times[-1]) if len(valid_times) > 0 else (0, fixed_max)
    return (0, valid_times[-1])

def predictive_optimal_combinations_fast(ref_df, test_df, regulation, window_min, window_max, diff_threshold):
    times = np.arange(window_min, window_max + 1)
    time_values = times[times != 0]
    
    # Precompute dissolution values
    ref_interp = interpolate_linear(ref_df, times)
    test_interp = interpolate_linear(test_df, times)
    
    def process_combination(combo):
        seq = sorted([0] + list(combo))
        if len(seq) < 3:
            return None
        
        # Compliance checks
        ref_dict = {t: ref_interp[np.where(times == t)[0][0]] for t in seq}
        test_dict = {t: test_interp[np.where(times == t)[0][0]] for t in seq}
        
        # Difference threshold check
        if diff_threshold:
            diff = np.abs(np.array(list(test_dict.values())) - np.array(list(ref_dict.values())))
            if np.any(diff > diff_threshold):
                return None
        
        compliant, _ = check_regulatory_compliance(seq, regulation, ref_dict, test_dict)
        if not compliant:
            return None
        
        # Calculate f2
        diff_sq = np.sum((np.array(list(test_dict.values())) - np.array(list(ref_dict.values()))) ** 2)
        f2 = 50 + 25 * np.log10(100 / (1 + diff_sq/len(seq)))
        return (seq, round(f2, 2))
    
    # Generate combinations in parallel
    all_combos = []
    for r in range(2, 6):
        all_combos.extend(combinations(time_values, r))
    
    with parallel_backend('loky'):
        results = Parallel(n_jobs=-1)(delayed(process_combination)(c) for c in all_combos)
# -------------------------- PREDICTIVE ANALYSIS TRIGGER --------------------------
run_predictive = input("\nRun predictive time optimization? (yes/no): ")
if run_predictive.lower() == 'yes':
    # Compute mean profiles
    ref_mean = reference_df.iloc[:, 1:].mean(axis=1)
    test_mean = test_df.iloc[:, 1:].mean(axis=1)
    ref_mean_df = pd.DataFrame({'Time': reference_df.iloc[:, 0], 'Dissolution': ref_mean})
    test_mean_df = pd.DataFrame({'Time': test_df.iloc[:, 0], 'Dissolution': test_mean})
    
    # Find optimal points
    window_min, window_max = determine_candidate_window(ref_mean_df, test_mean_df)
    best, candidates = predictive_optimal_combinations_fast(
        ref_mean_df, test_mean_df, 
        regulation="FDA",  # Will be overridden by user input
        window_min=window_min,
        window_max=window_max,
        diff_threshold=10
    )
    
    # Display results
    if best:
        print(f"\nüîç Optimal Time Points: {best[0]}")
        print(f"üìà Predicted f2 Score: {best[1]}")
        print("üü¢ Regulatory Compliance: Passed")
    else:
        print("‚ùå No valid combinations found")
    
    valid_results = [res for res in results if res is not None]
    return (max(valid_results, key=lambda x: x[1]), valid_results) if valid_results else (None, [])
