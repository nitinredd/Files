import numpy as np
import pandas as pd
import time
from tqdm import tqdm
from scipy.interpolate import interp1d
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, WhiteKernel, ConstantKernel as C
import warnings

def predictive_optimal_combinations_advanced(ref_df, test_df, regulation, 
                                            window_min, window_max, diff_threshold=None,
                                            interp_method='linear', num_samples=1000000):
    """Ultra-fast version processing 1M combinations in ~4s"""
    # Convert to numpy arrays immediately
    ref_times = ref_df.iloc[:, 0].values.astype(float)
    ref_diss = ref_df.iloc[:, 1].values.astype(float)
    test_times = test_df.iloc[:, 0].values.astype(float)
    test_diss = test_df.iloc[:, 1].values.astype(float)
    
    # ===== 1. Vectorized Interpolation Setup =====
    time_grid = np.linspace(window_min, window_max, 1000)
    
    if interp_method == 'gpr':
        kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=10.0) + WhiteKernel()
        ref_model = GaussianProcessRegressor(kernel=kernel).fit(ref_times.reshape(-1, 1), ref_diss)
        test_model = GaussianProcessRegressor(kernel=kernel).fit(test_times.reshape(-1, 1), test_diss)
        ref_curve = ref_model.predict(time_grid.reshape(-1, 1))
        test_curve = test_model.predict(time_grid.reshape(-1, 1))
    else:
        ref_curve = interp1d(ref_times, ref_diss, kind=interp_method, 
                           fill_value='extrapolate')(time_grid)
        test_curve = interp1d(test_times, test_diss, kind=interp_method,
                            fill_value='extrapolate')(time_grid)

    # ===== 2. Precompute All Valid Time Points =====
    max_diss = max(np.nanmax(ref_curve), np.nanmax(test_curve))
    if max_diss <= 60:
        time_options = np.unique(np.concatenate([
            np.arange(0, window_max+1, 3),
            np.arange(0, window_max+1, 5)
        ]))
    else:
        time_options = np.arange(0, window_max+1, 5)
    
    time_options = time_options[(time_options >= window_min) & (time_options <= window_max)]
    
    # ===== 3. Vectorized Combination Generation =====
    start_time = time.time()
    
    # Generate all sequences in one shot
    seq_lengths = np.random.randint(3, 7, num_samples)
    all_seqs = np.full((num_samples, 6), -1, dtype=int)
    
    # Matrix operations for speed
    mid_points = [np.random.choice(time_options[1:-1], size=sl-2, replace=False)
                 for sl in seq_lengths]
    all_seqs = np.array([np.sort(np.concatenate([[0], mp, [window_max]])) 
                        for mp in mid_points])
    
    # ===== 4. Vectorized F2 Calculation =====
    # Convert sequences to time grid indices
    seq_indices = ((all_seqs - window_min) / (window_max - window_min) * 999).astype(int)
    
    # Get dissolution values
    ref_values = ref_curve[seq_indices]
    test_values = test_curve[seq_indices]
    
    # Calculate F2 scores
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        valid = ~np.isnan(ref_values) & ~np.isnan(test_values)
        diffs = test_values - ref_values
        sum_sq = np.nansum(diffs**2, axis=1)
        lengths = np.sum(valid, axis=1)
        f2_scores = 100 - 25 * np.log10(1 + (sum_sq / lengths))
    
    # ===== 5. Compliance Check Optimization =====
    # Precompute regulatory thresholds
    last_time_idx = np.where(time_grid == window_max)[0][0]
    ref_last = ref_curve[last_time_idx]
    test_last = test_curve[last_time_idx]
    
    # Vectorized compliance check
    if regulation == "FDA":
        compliant_mask = ((ref_values[:, -1] >= 85) | (test_values[:, -1] >= 85)) & \
                        ((all_seqs[:, -1] == window_max))
    else:
        compliant_mask = np.ones(num_samples, dtype=bool)
    
    # ===== 6. Results Processing =====
    valid_scores = f2_scores[compliant_mask & ~np.isnan(f2_scores)]
    valid_seqs = all_seqs[compliant_mask & ~np.isnan(f2_scores)]
    
    # Get best result
    best_idx = np.nanargmax(valid_scores)
    best_result = {
        "sequence": valid_seqs[best_idx][valid_seqs[best_idx] != -1].tolist(),
        "f2": round(valid_scores[best_idx], 2),
        "compliant": True,
        "reasons": []
    }
    
    print(f"Processed {num_samples} combinations in {time.time()-start_time:.2f}s")
    return best_result, valid_seqs, valid_scores
