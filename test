import streamlit as st
import pytesseract
from pdf2image import convert_from_bytes
import numpy as np
import cv2
from PIL import Image, ImageDraw
import io
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import tempfile
import os
import platform
import warnings
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.table import _Cell, Table
from docx.shared import Cm

# Configure Tesseract path for Windows
if platform.system() == "Windows":
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

def enhance_image(image):
    """Enhanced image preprocessing for better OCR results"""
    img_array = np.array(image)
    
    # Convert to grayscale
    gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
    
    # Apply CLAHE (Contrast Limited Adaptive Histogram Equalization)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    gray = clahe.apply(gray)
    
    # Bilateral filtering to reduce noise while preserving edges
    denoised = cv2.bilateralFilter(gray, 9, 75, 75)
    
    # Adaptive thresholding with refined parameters
    binary = cv2.adaptiveThreshold(
        denoised, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 8
    )
    
    # Additional morphological operations to clean up the image
    kernel = np.ones((2,2), np.uint8)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
    
    return Image.fromarray(binary)

def detect_table_cells(image):
    """Advanced table cell detection"""
    img_array = np.array(image)
    if len(img_array.shape) == 3:
        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
    else:
        gray = img_array
    
    # Enhanced binary threshold
    binary = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2
    )
    
    # Detect lines with multiple scales
    def detect_lines(binary, min_length, max_gap):
        rho = 1
        theta = np.pi/180
        threshold = 50
        lines = cv2.HoughLinesP(binary, rho, theta, threshold, 
                               minLineLength=min_length, maxLineGap=max_gap)
        return lines if lines is not None else []

    # Detect horizontal and vertical lines at different scales
    scales = [(40, 1), (80, 1), (20, 1)]  # Multiple scales for horizontal lines
    horizontal_lines = np.zeros_like(binary)
    for scale in scales:
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, scale)
        temp = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
        horizontal_lines = cv2.add(horizontal_lines, temp)

    scales = [(1, 40), (1, 80), (1, 20)]  # Multiple scales for vertical lines
    vertical_lines = np.zeros_like(binary)
    for scale in scales:
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, scale)
        temp = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
        vertical_lines = cv2.add(vertical_lines, temp)

    # Combine lines
    table_structure = cv2.add(horizontal_lines, vertical_lines)
    
    # Find contours for cell detection
    contours, hierarchy = cv2.findContours(
        table_structure, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE
    )
    
    # Filter and sort cells
    cells = []
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        if w * h > 100:  # Filter out noise
            cells.append((x, y, w, h))
    
    # Sort cells by position (top to bottom, left to right)
    cells.sort(key=lambda x: (x[1], x[0]))
    
    return cells

def process_table_cells(image, cells):
    """Process individual table cells with enhanced OCR"""
    custom_config = r'--oem 3 --psm 6 -l jpn+jpn_vert --dpi 300'
    table_data = []
    current_row = []
    last_y = cells[0][1] if cells else 0
    
    for x, y, w, h in cells:
        # Check if we're starting a new row
        if y > last_y + 10:  # Threshold for new row detection
            if current_row:
                table_data.append(current_row)
                current_row = []
            last_y = y
        
        # Extract and process cell
        cell_img = image.crop((x, y, x+w, y+h))
        # Apply additional preprocessing for cell image
        enhanced_cell = enhance_image(cell_img)
        
        # Try both horizontal and vertical text recognition
        text_h = pytesseract.image_to_string(enhanced_cell, config=custom_config)
        text_v = pytesseract.image_to_string(enhanced_cell, config=custom_config + ' --psm 5')
        
        # Use the result with more characters
        cell_text = text_h if len(text_h) > len(text_v) else text_v
        cell_text = cell_text.strip()
        
        current_row.append(cell_text)
    
    if current_row:
        table_data.append(current_row)
    
    return table_data

def create_docx_with_tables(texts, tables_data):
    """Create Word document with enhanced table formatting"""
    doc = Document()
    
    # Set default font
    style = doc.styles['Normal']
    style.font.name = 'Arial'
    style.font.size = Pt(10)
    
    for page_num, (text, table_data) in enumerate(zip(texts, tables_data), 1):
        doc.add_heading(f'Page {page_num}', level=1)
        
        if table_data:
            # Create table with proper formatting
            if table_data:
                max_cols = max(len(row) for row in table_data)
                table = doc.add_table(rows=len(table_data), cols=max_cols)
                table.style = 'Table Grid'
                
                # Set column widths
                for cell in table.rows[0].cells:
                    cell.width = Cm(3)
                
                # Fill table data
                for i, row in enumerate(table_data):
                    for j, cell_text in enumerate(row):
                        try:
                            cell = table.cell(i, j)
                            cell.text = cell_text
                            # Apply cell formatting
                            paragraph = cell.paragraphs[0]
                            paragraph.alignment = WD_ALIGN_PARAGRAPH.LEFT
                            run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
                            run.font.size = Pt(9)
                        except IndexError:
                            continue
        
        if text:
            doc.add_paragraph(text)
        
        doc.add_page_break()
    
    return doc

def main():
    st.title("Enhanced Japanese Document OCR with Complex Table Detection")
    st.write("Upload a PDF document to extract text and complex tables")
    
    # File uploader with increased size limit
    uploaded_file = st.file_uploader("Choose a PDF file", type="pdf")
    
    if uploaded_file is not None:
        try:
            with st.spinner("Processing document..."):
                # Convert PDF to images with higher DPI
                pdf_bytes = uploaded_file.read()
                images = convert_from_bytes(pdf_bytes, dpi=300)
                
                processed_texts = []
                tables_data = []
                
                for i, image in enumerate(images):
                    progress_text = f"Processing page {i+1}/{len(images)}"
                    st.write(progress_text)
                    
                    # Enhanced image processing
                    enhanced_image = enhance_image(image)
                    
                    # Detect and process table cells
                    cells = detect_table_cells(enhanced_image)
                    if cells:
                        table_data = process_table_cells(image, cells)
                        tables_data.append(table_data)
                        
                        # Process non-table regions
                        mask = Image.new('L', image.size, 255)
                        draw = ImageDraw.Draw(mask)
                        for x, y, w, h in cells:
                            draw.rectangle([x, y, x+w, y+h], fill=0)
                        non_table_region = Image.composite(image, Image.new('RGB', image.size, 'white'), mask)
                        text = pytesseract.image_to_string(non_table_region, lang='jpn')
                    else:
                        table_data = []
                        text = pytesseract.image_to_string(enhanced_image, lang='jpn')
                    
                    processed_texts.append(text)
                    tables_data.append(table_data)
                
                # Create enhanced Word document
                doc = create_docx_with_tables(processed_texts, tables_data)
                
                # Save document
                docx_bytes = io.BytesIO()
                doc.save(docx_bytes)
                docx_bytes.seek(0)
                
                st.download_button(
                    label="Download DOCX file",
                    data=docx_bytes,
                    file_name="extracted_document.docx",
                    mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                )
                
                st.success("Document processed successfully!")
                
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")
            st.error("Please make sure Tesseract is installed and the PDF is readable")

if __name__ == "__main__":
    main()
