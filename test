import numpy as np
import pandas as pd
from itertools import combinations
from joblib import Parallel, delayed

def predictive_optimal_combinations_fast(ref_df, test_df, regulation, window_min, window_max, diff_threshold):
    # Generate actual time values (not indices)
    times = np.arange(window_min, window_max + 1)
    min_points = 3  # At least 3 time points (including 0)
    max_points = 6   # Cap sequence length to 6 points
    
    # Precompute dissolution values for ALL time points
    ref_interp_all = interpolate_dissolution_curve(ref_df, times, method='linear')
    test_interp_all = interpolate_dissolution_curve(test_df, times, method='linear')
    
    # Generate combinations of time VALUES (not indices), excluding 0
    time_values = times[times != 0]  # Exclude 0 since it's always included
    
    def process_combination(combo):
        # Convert combo (time values) to a sorted list with 0
        seq = sorted([0] + list(combo))
        if len(seq) < min_points:
            return None
        
        # Get indices of the selected times in the precomputed `times` array
        indices = [np.where(times == t)[0][0] for t in seq]
        
        # Check per-time difference threshold
        if diff_threshold is not None:
            diff = np.abs(test_interp_all[indices] - ref_interp_all[indices])
            if np.any(diff > diff_threshold):
                return None
        
        # Check regulatory compliance
        ref_dict = {t: ref_interp_all[i] for i, t in zip(indices, seq)}
        test_dict = {t: test_interp_all[i] for i, t in zip(indices, seq)}
        compliant, _ = check_regulatory_compliance(seq, regulation, ref_dict, test_dict)
        if not compliant:
            return None
        
        # Calculate f2
        diff_total = np.sum((test_interp_all[indices] - ref_interp_all[indices]) ** 2)
        p = len(seq)
        f2 = 100 - 25 * np.log10(1 + (diff_total / p))
        return (seq, f2)
    
    # Generate all combinations of time VALUES (not indices)
    all_combos = []
    for r in range(2, max_points):
        all_combos.extend(combinations(time_values, r))
    
    # Parallel processing
    results = Parallel(n_jobs=-1)(delayed(process_combination)(combo) for combo in all_combos)
    valid_results = [res for res in results if res is not None]
    
    # Return best result
    if valid_results:
        best_result = max(valid_results, key=lambda x: x[1])
        return best_result
    else:
        return None
