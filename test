# =============================================================================
# NEW OPTIMIZATION MODULE START
# =============================================================================
def generate_valid_combinations(reference_df, test_df, regulation):
    """Generate regulation-compliant time point combinations"""
    # Get common time points (assuming aligned after previous checks)
    times = reference_df.iloc[:, 0].tolist()
    
    # Regulation-specific truncation
    if regulation == "FDA":
        ref_trunc = next((i for i, val in enumerate(reference_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        test_trunc = next((i for i, val in enumerate(test_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        trunc_idx = min(ref_trunc, test_trunc)
    elif regulation in ["EMA", "ICH", "Canada"]:
        ref_trunc = next((i for i, val in enumerate(reference_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        trunc_idx = ref_trunc
    else:  # For ANVISA/others
        trunc_idx = len(times)
    
    valid_times = times[:trunc_idx+1]
    
    # Generate combinations with ≥3 points
    return [valid_times[:i+1] for i in range(2, len(valid_times)) if len(valid_times[:i+1]) >=3]

def calculate_all_f2_combinations(ref_df, test_df, combinations):
    """Calculate f2 for all time combinations"""
    results = []
    for combo in combinations:
        try:
            # Get indices for the time points
            ref_subset = ref_df[ref_df.iloc[:,0].isin(combo)]
            test_subset = test_df[test_df.iloc[:,0].isin(combo)]
            
            # Original f2 calculation
            p = len(combo)
            ref_means = ref_subset.iloc[:,1:].mean(axis=1)
            test_means = test_subset.iloc[:,1:].mean(axis=1)
            sum_sq_diff = ((test_means - ref_means)**2).sum()
            f2 = 100 - 25 * np.log10(1 + (1/p)*sum_sq_diff)
            
            results.append({
                'times': combo,
                'n_points': len(combo),
                'f2': round(f2, 2)
            })
        except:
            continue
    return results

def display_optimal_combinations(results):
    """Display optimization results"""
    if not results:
        print("No valid combinations found for optimization analysis")
        return
    
    print("\n\n=== Additional Time Point Optimization Analysis ===")
    print("All valid combinations and their f2 scores:")
    for res in sorted(results, key=lambda x: x['f2'], reverse=True):
        print(f"Time Points: {res['times']} ({res['n_points']} points) → f2: {res['f2']}")
    
    best = max(results, key=lambda x: x['f2'])
    print(f"\nOptimal combination: {best['times']} → f2: {best['f2']}")
# =============================================================================
# NEW OPTIMIZATION MODULE END
# =============================================================================

# ====================== NEW OPTIMIZATION FUNCTIONS START ======================
def generate_valid_combinations(ref_df, test_df, regulation):
    """Generate regulation-compliant time combinations"""
    times = ref_df.iloc[:, 0].tolist()
    
    # Regulation-specific truncation
    if regulation == "FDA":
        ref_idx = next((i for i, val in enumerate(ref_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        test_idx = next((i for i, val in enumerate(test_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        trunc = min(ref_idx, test_idx)
    elif regulation in ["EMA", "Canada", "ICH"]:
        ref_idx = next((i for i, val in enumerate(ref_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        test_idx = next((i for i, val in enumerate(test_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        trunc = min(ref_idx, test_idx)
    elif regulation == "ANVISA":
        trunc = len(times)
    elif regulation == "China":
        ref_idx = next((i for i, val in enumerate(ref_df.iloc[:,1:].mean(axis=1)) if val >= 85), len(times))
        trunc = ref_idx
    else:  # ASEAN
        trunc = len(times)
    
    valid_times = times[:trunc+1]
    return [valid_times[:i+1] for i in range(2, len(valid_times)) if len(valid_times[:i+1]) >=3]

def calculate_combination_f2(ref_sub, test_sub):
    """Calculate f2 for a time combination subset"""
    try:
        p = len(ref_sub)
        diff = test_sub.iloc[:,1:].mean(axis=1) - ref_sub.iloc[:,1:].mean(axis=1)
        sum_sq = (diff**2).sum()
        return 100 - 25 * np.log10(1 + (1/p)*sum_sq)
    except:
        return None

def display_optimization(results):
    """Display optimization analysis"""
    if not results:
        return
    
    print("\n" + "="*60)
    print(" Time Point Combination Analysis (Additional Feature)")
    print("="*60)
    
    # Display all valid combinations
    print("\nAll Valid Combinations:")
    for res in sorted(results, key=lambda x: x['f2'], reverse=True):
        print(f" - Times: {res['times']} ({len(res['times'])} pts) → f2: {res['f2']:.2f}")
    
    # Show best combination
    best = max(results, key=lambda x: x['f2'])
    print(f"\nOptimal Combination: {best['times']} → f2: {best['f2']:.2f}")
    print("="*60 + "\n")
# ====================== NEW OPTIMIZATION FUNCTIONS END ======================
Add this code block IMMEDIATELY AFTER each regulation's original analysis block:

For FDA (input1 == 1),
changed_data_either85_FDA_bca(reference_df, test_df)

        # Optimization analysis
        if check_same_time_points(reference_df, test_df):
            combos = generate_valid_combinations(reference_df, test_df, "FDA")
            results = []
            for combo in combos:
                ref_sub = reference_df[reference_df.iloc[:,0].isin(combo)]
                test_sub = test_df[test_df.iloc[:,0].isin(combo)]
                f2 = calculate_combination_f2(ref_sub, test_sub)
                if f2: 
                    results.append({'times': combo, 'f2': f2})
            display_optimization(results)
2

        # Optimization analysis
        if check_same_time_points(reference_df, test_df):
            combos = generate_valid_combinations(reference_df, test_df, "EMA")
            results = []
            for combo in combos:
                ref_sub = reference_df[reference_df.iloc[:,0].isin(combo)]
                test_sub = test_df[test_df.iloc[:,0].isin(combo)]
                f2 = calculate_combination_f2(ref_sub, test_sub)
                if f2: 
                    results.append({'times': combo, 'f2': f2})
            display_optimization(results)

3

        # Optimization analysis
        if check_same_time_points(reference_df, test_df):
            combos = generate_valid_combinations(reference_df, test_df, "China")
            results = []
            for combo in combos:
                ref_sub = reference_df[reference_df.iloc[:,0].isin(combo)]
                test_sub = test_df[test_df.iloc[:,0].isin(combo)]
                f2 = calculate_combination_f2(ref_sub, test_sub)
                if f2: 
                    results.append({'times': combo, 'f2': f2})
            display_optimization(results)

4

        # Optimization analysis
        if check_same_time_points(reference_df, test_df):
            combos = generate_valid_combinations(reference_df, test_df, "ASEAN")
            results = []
            for combo in combos:
                ref_sub = reference_df[reference_df.iloc[:,0].isin(combo)]
                test_sub = test_df[test_df.iloc[:,0].isin(combo)]
                f2 = calculate_combination_f2(ref_sub, test_sub)
                if f2: 
                    results.append({'times': combo, 'f2': f2})
            display_optimization(results)

5
        # Optimization analysis
        if check_same_time_points(reference_df, test_df):
            combos = generate_valid_combinations(reference_df, test_df, "ANVISA")
            results = []
            for combo in combos:
                ref_sub = reference_df[reference_df.iloc[:,0].isin(combo)]
                test_sub = test_df[test_df.iloc[:,0].isin(combo)]
                f2 = calculate_combination_f2(ref_sub, test_sub)
                if f2: 
                    results.append({'times': combo, 'f2': f2})
            display_optimization(results)




