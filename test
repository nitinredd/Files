# Scaleup Predictor Chatbot - React + Tailwind (Vite)

This is the **production-ready** React + Tailwind frontend for your *Scaleup Predictor Chatbot* with advanced UX features. It expands the previous version with:

- Conversation history (local + optional backend sync). Save, load, rename, delete conversations.
- File uploader (+ button) to upload PDFs/Excel which are sent to the backend (`/upload-document`) to be chunked & stored in vectorstore. Multiple files supported and shown in an upload queue with progress.
- Theme toggle (Light / Dark / Cosmic) with smooth animated transitions and CSS variables.
- More extravagant visuals and micro-interactions (Framer Motion animations, fancy header visuals, gradient blurs, glassmorphism, animated cards).
- Export conversation (JSON) and import conversation support.
- Accessibility improvements (keyboard navigation, labels, aria attributes), and responsive behavior.
- Full working API layer for `/chat`, `/speech-to-text`, `/text-to-speech`, `/upload-document`, and conversation sync endpoints `/conversations`.

---

## Project files included in this bundle

- package.json
- vite.config.js
- tailwind.config.cjs
- postcss.config.cjs
- public/index.html
- src/main.jsx
- src/index.css
- src/App.jsx
- src/api.js
- src/components/ChatWidget.jsx
- src/components/Message.jsx
- src/components/PromptGallery.jsx
- src/components/Suggestions.jsx
- src/components/FileUploader.jsx
- src/components/ConversationHistory.jsx
- src/components/ThemeToggle.jsx
- src/utils/parseResponseToTable.js
- README_RUN.md
- backend_snippets/fastapi_upload_example.py

---

## package.json

```json
{
  "name": "scaleup-predictor-frontend",
  "version": "1.1.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.4.0",
    "framer-motion": "^10.12.7",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-rnd": "^11.0.1",
    "classnames": "^2.3.2",
    "file-saver": "^2.0.5"
  },
  "devDependencies": {
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.23",
    "tailwindcss": "^3.4.8",
    "vite": "^5.0.0"
  }
}
```

---

## vite.config.js

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
})
```

---

## tailwind.config.cjs

```js
module.exports = {
  content: ['./index.html', './src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: '#6C5CE7',
        accent: '#00cec9'
      },
      boxShadow: {
        glow: '0 10px 30px rgba(108,92,231,0.18)'
      }
    }
  },
  plugins: []
}
```

---

## postcss.config.cjs

```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
}
```

---

## public/index.html

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scaleup Predictor Chatbot</title>
  </head>
  <body class="bg-gray-50 h-screen">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

---

## src/main.jsx

```jsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './index.css'

createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
```

---

## src/index.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --bg: 255 255 255;
  --muted: 99 102 241;
  --text: 17 24 39;
}

[data-theme='dark'] {
  --bg: 15 23 42;
  --muted: 99 102 241;
  --text: 229 231 235;
}

[data-theme='cosmic'] {
  --bg: 8 7 25;
  --muted: 160 90 255;
  --text: 238 242 255;
}

html, body, #root {
  height: 100%;
}

body {
  background: radial-gradient(circle at 10% 10%, rgba(108,92,231,0.06), transparent 10%), linear-gradient(180deg, rgba(var(--bg)/1) 0%, rgba(var(--bg)/1) 100%);
  color: rgb(var(--text));
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* fancy glass card */
.glass {
  background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.4));
  backdrop-filter: blur(6px) saturate(120%);
}

[data-theme='dark'] .glass {
  background: linear-gradient(180deg, rgba(10,14,23,0.6), rgba(10,14,23,0.4));
}

.scrollbar-thin::-webkit-scrollbar { height: 8px; width: 8px }
.scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.18); border-radius: 8px }
```

---

## src/api.js

```js
import axios from 'axios'

const API_BASE = import.meta.env.VITE_API_BASE || 'http://localhost:8000'

export async function chatRequest(message, conversation_id = null) {
  const body = { message }
  if (conversation_id) body.conversation_id = conversation_id
  const resp = await axios.post(`${API_BASE}/chat`, body, { timeout: 60000 })
  return resp.data
}

export async function speechToTextUpload(blob) {
  const fd = new FormData()
  fd.append('file', blob, 'audio.webm')
  const resp = await axios.post(`${API_BASE}/speech-to-text`, fd, { headers: { 'Content-Type': 'multipart/form-data' } })
  return resp.data
}

export function textToSpeechUrl(text) {
  return `${API_BASE}/text-to-speech?text=${encodeURIComponent(text)}`
}

export async function uploadDocument(file) {
  const fd = new FormData()
  fd.append('file', file, file.name)
  const resp = await axios.post(`${API_BASE}/upload-document`, fd, { headers: { 'Content-Type': 'multipart/form-data' }, onUploadProgress: (ev) => {
    // consumer can listen to axios event
  }})
  return resp.data
}

export async function getConversations() {
  try {
    const resp = await axios.get(`${API_BASE}/conversations`)
    return resp.data
  } catch (e) {
    // fallback to local only
    return null
  }
}

export async function saveConversation(conv) {
  try {
    const resp = await axios.post(`${API_BASE}/conversations`, conv)
    return resp.data
  } catch (e) {
    return null
  }
}
```

---

## src/utils/parseResponseToTable.js

```js
export function parseResponseToTable(str) {
  if (!str) return null
  str = str.trim()
  try {
    const parsed = JSON.parse(str)
    if (Array.isArray(parsed)) {
      if (parsed.length === 0) return null
      if (parsed.every(it => typeof it === 'object' && !Array.isArray(it))) return { type: 'json', data: parsed }
    } else if (typeof parsed === 'object') {
      return { type: 'json', data: [parsed] }
    }
  } catch (e) {}

  const lines = str.split('
').map(l => l.trim()).filter(l => l)
  if (lines.length >= 2) {
    const hasPipe = lines[0].includes('|')
    const hasTab = lines[0].includes('	')
    if (hasPipe || hasTab) {
      const sep = hasPipe ? '|' : '	'
      const headers = lines[0].split(sep).map(s => s.trim())
      const rows = lines.slice(1).map(r => r.split(sep).map(s => s.trim()))
      return { type: 'matrix', headers, rows }
    }
  }

  return null
}
```

---

## src/components/Message.jsx

```jsx
import React from 'react'
import { parseResponseToTable } from '../utils/parseResponseToTable'

export default function Message({ from, text, onReadAloud }) {
  const table = parseResponseToTable(text)
  return (
    <div className={`max-w-full ${from === 'user' ? 'self-end' : 'self-start'} `}>
      <div className={`p-4 rounded-2xl shadow-sm ${from === 'user' ? 'bg-gradient-to-r from-primary/80 to-indigo-400 text-white' : 'bg-white text-gray-800 glass'}`}>
        <div className="prose-sm whitespace-pre-wrap break-words">
          {!table && <div>{text}</div>}

          {table?.type === 'json' && (
            <div className="overflow-auto">
              <table className="min-w-full text-sm table-auto border-collapse">
                <thead>
                  <tr className="text-left">
                    {Object.keys(table.data[0]).map((h) => (
                      <th key={h} className="px-3 py-2 border-b">{h}</th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {table.data.map((row, idx) => (
                    <tr key={idx}>
                      {Object.keys(table.data[0]).map((k) => (
                        <td className="px-3 py-2 align-top border-b" key={k}>{String(row[k] ?? '')}</td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {table?.type === 'matrix' && (
            <div className="overflow-auto">
              <table className="min-w-full text-sm table-auto border-collapse">
                <thead>
                  <tr>
                    {table.headers.map((h) => <th key={h} className="px-3 py-2 border-b">{h}</th>)}
                  </tr>
                </thead>
                <tbody>
                  {table.rows.map((r, i) => (
                    <tr key={i}>{r.map((c, j) => <td className="px-3 py-2 border-b" key={j}>{c}</td>)}</tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>

        {from === 'agent' && (
          <div className="mt-2 flex items-center gap-2">
            <button onClick={() => onReadAloud?.(text)} className="px-3 py-1 text-xs rounded bg-accent/10 hover:bg-accent/20">üîä Read Aloud</button>
          </div>
        )}
      </div>
    </div>
  )
}
```

---

## src/components/PromptGallery.jsx

```jsx
import React from 'react'
import { motion } from 'framer-motion'

export default function PromptGallery({ tiles, onSelect }) {
  return (
    <div className="grid grid-cols-1 gap-3">
      {Object.entries(tiles).map(([title, prompts]) => (
        <motion.div key={title} whileHover={{ y: -6 }} className="p-3 rounded-xl shadow-md bg-gradient-to-r from-white to-indigo-50 border">
          <div className="flex justify-between items-center">
            <h4 className="text-sm font-semibold">{title}</h4>
            <span className="text-xs text-gray-500">{prompts.length} prompts</span>
          </div>
          <div className="mt-2 space-y-2">
            {prompts.map((p, i) => (
              <motion.button key={i} whileTap={{ scale: 0.98 }} onClick={() => onSelect(p)} className="w-full text-left p-2 rounded-lg bg-white hover:shadow-lg transition-shadow text-sm">
                {p}
              </motion.button>
            ))}
          </div>
        </motion.div>
      ))}
    </div>
  )
}
```

---

## src/components/Suggestions.jsx

```jsx
import React from 'react'

export default function Suggestions({ items, onPick }) {
  if (!items?.length) return null
  return (
    <div className="absolute left-0 right-0 bg-white border rounded shadow-sm z-50">
      {items.map((it, i) => (
        <div key={i} className="p-2 hover:bg-gray-50 cursor-pointer" onClick={() => onPick(it)}>{it}</div>
      ))}
    </div>
  )
}
```

---

## src/components/FileUploader.jsx

```jsx
import React, { useRef, useState } from 'react'
import { motion } from 'framer-motion'
import { uploadDocument } from '../api'

export default function FileUploader({ onUploaded }) {
  const inputRef = useRef(null)
  const [queue, setQueue] = useState([])

  async function onFiles(files) {
    const arr = Array.from(files)
    for (const f of arr) {
      const item = { id: crypto?.randomUUID?.() ?? Date.now(), file: f, progress: 0, status: 'queued' }
      setQueue(q => [...q, item])
      uploadOne(item)
    }
  }

  async function uploadOne(item) {
    setQueue(q => q.map(x => x.id === item.id ? { ...x, status: 'uploading' } : x))
    try {
      const data = await uploadDocument(item.file)
      setQueue(q => q.map(x => x.id === item.id ? { ...x, status: 'done', progress: 100 } : x))
      onUploaded?.(data)
    } catch (e) {
      setQueue(q => q.map(x => x.id === item.id ? { ...x, status: 'failed' } : x))
    }
  }

  return (
    <div>
      <input ref={inputRef} type="file" hidden onChange={(e) => onFiles(e.target.files)} />
      <motion.button onClick={() => inputRef.current.click()} whileHover={{ scale: 1.03 }} className="px-3 py-2 rounded-lg bg-white border">Ôºã Upload</motion.button>

      <div className="mt-2 space-y-2">
        {queue.map(q => (
          <div key={q.id} className="p-2 rounded bg-white/80 flex items-center justify-between">
            <div className="text-sm truncate pr-4">{q.file.name}</div>
            <div className="text-xs text-gray-500">{q.status}</div>
          </div>
        ))}
      </div>
    </div>
  )
}
```

---

## src/components/ConversationHistory.jsx

```jsx
import React, { useEffect, useState } from 'react'
import { getConversations, saveConversation } from '../api'
import { saveAs } from 'file-saver'

export default function ConversationHistory({ onLoad }) {
  const [items, setItems] = useState([])

  useEffect(() => {
    const local = JSON.parse(localStorage.getItem('sp_conversations') || '[]')
    setItems(local)
    (async () => {
      const remote = await getConversations()
      if (remote) setItems(prev => [...prev, ...remote])
    })()
  }, [])

  function saveLocal(conv) {
    const cur = JSON.parse(localStorage.getItem('sp_conversations') || '[]')
    const next = [conv, ...cur]
    localStorage.setItem('sp_conversations', JSON.stringify(next))
    setItems(next)
    saveConversation(conv)
  }

  function exportConv(conv) {
    const blob = new Blob([JSON.stringify(conv, null, 2)], { type: 'application/json' })
    saveAs(blob, (conv.name || 'conversation') + '.json')
  }

  function remove(idx) {
    const cur = JSON.parse(localStorage.getItem('sp_conversations') || '[]')
    cur.splice(idx, 1)
    localStorage.setItem('sp_conversations', JSON.stringify(cur))
    setItems(cur)
  }

  return (
    <div className="space-y-2">
      <div className="text-xs font-semibold">Conversations</div>
      <div className="space-y-1 max-h-64 overflow-auto">
        {items.map((it, idx) => (
          <div key={idx} className="p-2 rounded bg-white flex items-center justify-between">
            <div>
              <div className="font-medium text-sm">{it.name || 'Untitled'}</div>
              <div className="text-xs text-gray-500">{new Date(it.updated_at || it.created_at || Date.now()).toLocaleString()}</div>
            </div>
            <div className="flex gap-2">
              <button onClick={() => onLoad(it)} className="px-2 py-1 text-xs rounded bg-primary text-white">Load</button>
              <button onClick={() => exportConv(it)} className="px-2 py-1 text-xs rounded border">Export</button>
              <button onClick={() => remove(idx)} className="px-2 py-1 text-xs rounded border">Delete</button>
            </div>
          </div>
        ))}
      </div>

      <div className="mt-2">
        <button onClick={() => saveLocal({ name: 'Saved ' + new Date().toLocaleString(), messages: [], created_at: Date.now(), updated_at: Date.now() })} className="px-3 py-2 rounded bg-accent/10">Ôºã Save Empty</button>
      </div>
    </div>
  )
}
```

---

## src/components/ThemeToggle.jsx

```jsx
import React, { useEffect, useState } from 'react'

export default function ThemeToggle() {
  const [theme, setTheme] = useState(localStorage.getItem('sp_theme') || 'light')

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme === 'light' ? 'light' : theme)
    localStorage.setItem('sp_theme', theme)
  }, [theme])

  return (
    <div className="flex items-center gap-2">
      <button onClick={() => setTheme('light')} className={`px-2 py-1 rounded ${theme==='light' ? 'bg-primary text-white' : 'bg-white'}`}>Light</button>
      <button onClick={() => setTheme('dark')} className={`px-2 py-1 rounded ${theme==='dark' ? 'bg-primary text-white' : 'bg-white'}`}>Dark</button>
      <button onClick={() => setTheme('cosmic')} className={`px-2 py-1 rounded ${theme==='cosmic' ? 'bg-primary text-white' : 'bg-white'}`}>Cosmic</button>
    </div>
  )
}
```

---

## src/components/ChatWidget.jsx

```jsx
import React, { useEffect, useRef, useState } from 'react'
import { Rnd } from 'react-rnd'
import { motion } from 'framer-motion'
import PromptGallery from './PromptGallery'
import Message from './Message'
import Suggestions from './Suggestions'
import FileUploader from './FileUploader'
import ConversationHistory from './ConversationHistory'
import ThemeToggle from './ThemeToggle'
import { chatRequest, speechToTextUpload, textToSpeechUrl, saveConversation } from '../api'

export default function ChatWidget({ tiles }) {
  const [open, setOpen] = useState(false)
  const [messages, setMessages] = useState([])
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [suggests, setSuggests] = useState([])
  const [recording, setRecording] = useState(false)
  const [conversationName, setConversationName] = useState('New Conversation')
  const [conversationId, setConversationId] = useState(null)

  const recorderRef = useRef(null)
  const audioChunksRef = useRef([])
  const scrollRef = useRef(null)

  useEffect(() => {
    const cached = JSON.parse(localStorage.getItem('sp_current') || 'null')
    if (cached) {
      setMessages(cached.messages || [])
      setConversationName(cached.name || 'Restored')
      setConversationId(cached.id || null)
    }
  }, [])

  useEffect(() => {
    localStorage.setItem('sp_current', JSON.stringify({ id: conversationId, name: conversationName, messages }))
    scrollToBottom()
  }, [messages, conversationName, conversationId])

  function scrollToBottom() {
    try { scrollRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' }) } catch(e){}
  }

  function appendMessage(from, text) {
    setMessages(m => [...m, { id: crypto?.randomUUID?.() ?? Date.now(), from, text, ts: Date.now() }])
  }

  async function send() {
    const q = input.trim()
    if (!q) return
    appendMessage('user', q)
    setInput('')
    setLoading(true)
    try {
      const resp = await chatRequest(q, conversationId)
      const ans = resp?.response ?? 'Oops! No relevant information found.'
      appendMessage('agent', ans)
    } catch (e) {
      appendMessage('agent', 'Error calling backend ‚Äî ' + String(e.message ?? e))
    } finally {
      setLoading(false)
    }
  }

  function onSelectPrompt(p) {
    setInput(p)
  }

  function handleKey(e) {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) send()
  }

  useEffect(() => {
    const k = input.toLowerCase()
    const list = []
    if (k.includes('capacity') || k.includes('capacities')) {
      list.push('Show capacities in a tabular format for each line')
      list.push('Provide capacity breakdown by batch size')
    }
    if (k.includes('dissolution')) {
      list.push('List dissolution method and conditions as a table')
    }
    setSuggests(list)
  }, [input])

  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const mr = new MediaRecorder(stream)
      recorderRef.current = mr
      audioChunksRef.current = []
      mr.ondataavailable = (e) => audioChunksRef.current.push(e.data)
      mr.onstop = async () => {
        const blob = new Blob(audioChunksRef.current, { type: 'audio/webm' })
        try {
          const r = await speechToTextUpload(blob)
          const text = r?.text ?? ''
          if (text) setInput(text)
        } catch (err) {
          appendMessage('agent', 'STT Error: ' + String(err.message ?? err))
        }
      }
      mr.start()
      setRecording(true)
    } catch (e) {
      appendMessage('agent', 'Cannot access mic: ' + e.message)
    }
  }

  function stopRecording() {
    const mr = recorderRef.current
    if (mr && mr.state !== 'inactive') mr.stop()
    setRecording(false)
  }

  function readAloud(text) {
    const url = textToSpeechUrl(text)
    const audio = new Audio(url)
    audio.play()
  }

  function onFileUploaded(data) {
    appendMessage('agent', `Uploaded: ${data.filename} ‚Äî indexed and available for querying.`)
  }

  function saveConversationToLocal() {
    const cur = JSON.parse(localStorage.getItem('sp_conversations') || '[]')
    const conv = { id: conversationId || (crypto?.randomUUID?.() ?? Date.now()), name: conversationName, messages, updated_at: Date.now() }
    const next = [conv, ...cur.filter(c => c.id !== conv.id)]
    localStorage.setItem('sp_conversations', JSON.stringify(next))
    setConversationId(conv.id)
    saveConversation(conv).catch(()=>{})
    appendMessage('agent', 'Conversation saved locally and sync attempted to server.')
  }

  async function importConversation(file) {
    try {
      const text = await file.text()
      const parsed = JSON.parse(text)
      if (parsed.messages) {
        setMessages(parsed.messages)
        setConversationName(parsed.name || 'Imported')
        setConversationId(parsed.id || null)
      }
    } catch (e) {
      appendMessage('agent', 'Import failed: ' + e.message)
    }
  }

  function exportConversation() {
    const blob = new Blob([JSON.stringify({ id: conversationId, name: conversationName, messages }, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = (conversationName || 'conversation') + '.json'
    a.click()
    URL.revokeObjectURL(url)
  }

  function loadConversation(conv) {
    setMessages(conv.messages || [])
    setConversationName(conv.name || 'Loaded')
    setConversationId(conv.id || null)
  }

  return (
    <>
      <div className="fixed bottom-6 right-6 z-50">
        <motion.button whileTap={{ scale: 0.95 }} onClick={() => setOpen(o => !o)} className="w-16 h-16 rounded-full shadow-glow bg-gradient-to-br from-primary to-indigo-500 flex items-center justify-center text-white text-xl ring-4 ring-white/10">
          üíä
        </motion.button>
      </div>

      {open && (
        <Rnd default={{ x: 80, y: 40, width: 1000, height: 720 }} minWidth={520} minHeight={420} bounds="window">
          <motion.div initial={{ scale: 0.96, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} className="flex flex-col h-full rounded-3xl shadow-2xl bg-gradient-to-b from-white/80 to-indigo-50/40 border border-white/60 overflow-hidden">
            <div className="flex items-center justify-between px-4 py-3 border-b bg-white/60">
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 rounded-lg bg-gradient-to-br from-primary to-indigo-400 flex items-center justify-center text-white font-bold shadow">SP</div>
                <div>
                  <div className="font-semibold">Scaleup Predictor Chatbot</div>
                  <div className="text-xs text-gray-500">Ask your dataset ‚Äî production-ready answers</div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <input className="px-2 py-1 rounded border" value={conversationName} onChange={(e) => setConversationName(e.target.value)} />
                <button onClick={saveConversationToLocal} className="px-3 py-2 rounded bg-primary text-white">Save</button>
                <FileUploader onUploaded={onFileUploaded} />
                <ThemeToggle />
                <button onClick={() => setOpen(false)} className="text-sm px-3 py-1 rounded bg-white/90">Close</button>
              </div>
            </div>

            <div className="flex flex-1 gap-4 p-4">
              <div className="w-80 overflow-auto p-2 rounded-lg glass">
                <div className="text-xs font-medium text-gray-600 px-2">Prompt Gallery</div>
                <div className="mt-3">
                  <PromptGallery tiles={tiles} onSelect={onSelectPrompt} />
                </div>

                <div className="mt-4">
                  <ConversationHistory onLoad={loadConversation} />
                </div>
              </div>

              <div className="flex-1 bg-white/90 rounded-xl p-4 flex flex-col shadow-inner">
                <div className="flex-1 overflow-auto space-y-3 pr-2 scrollbar-thin">
                  <div className="flex flex-col">
                    {messages.map((m) => (
                      <Message key={m.id} from={m.from === 'user' ? 'user' : 'agent'} text={m.text} onReadAloud={readAloud} />
                    ))}
                    <div ref={scrollRef} />
                  </div>
                </div>

                <div className="mt-3 relative">
                  <div className="flex items-center gap-2">
                    <div className="relative flex-1">
                      <textarea value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={handleKey} rows={2} className="w-full resize-none p-3 rounded-xl border" placeholder="Type a question or pick a prompt..." />
                      <div className="absolute right-2 top-1/2 -translate-y-1/2">{loading && <span className="text-xs text-gray-500">Thinking...</span>}</div>
                      <div className="absolute left-2 -top-9 w-full">
                        <Suggestions items={suggests} onPick={(s) => setInput(s)} />
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <button onClick={() => { recording ? stopRecording() : startRecording() }} className={`px-3 py-2 rounded-lg border ${recording ? 'bg-red-100' : 'bg-white'}`}>{recording ? '‚óè Recording' : 'üé§'}</button>
                      <button onClick={() => importFileInput.click()} className="px-3 py-2 rounded-lg border">Import</button>
                      <input type="file" id="importFile" style={{display:'none'}} onChange={(e)=>{ const f=e.target.files?.[0]; if(f) importConversation(f)}} ref={(el)=>{ window.importFileInput = el }} />
                      <button onClick={() => exportConversation()} className="px-3 py-2 rounded-lg border">Export</button>
                      <button onClick={() => send()} className="px-4 py-2 rounded-lg bg-primary text-white">Send</button>
                    </div>
                  </div>
                </div>

              </div>
            </div>

          </motion.div>
        </Rnd>
      )}
    </>
  )
}
```

---

## src/App.jsx

```jsx
import React from 'react'
import ChatWidget from './components/ChatWidget'

const TILE_QUESTIONS = {
  "Product A": ["What is the API used?", "What is the batch size?", "Who is the manufacturer?"],
  "Line B": ["What is the speed range?", "What equipment is used?", "What is the pressure limit?"],
  "Facility X": ["Who owns this facility?", "What lines are operational?"],
  "Formulation Z": ["List excipients used", "Describe dissolution method"],
  "Process Y": ["Steps in granulation?", "Drying temperature?"],
  "Machine Q": ["Model number details?", "Maintenance interval?"],
  "Raw Material P": ["What are specs?", "Approved vendors?"]
}

export default function App() {
  return (
    <div className="h-screen w-full flex items-center justify-center">
      <div className="text-center space-y-3">
        <h1 className="text-4xl font-extrabold">Scaleup Predictor</h1>
        <p className="text-gray-500">Click the floating chatbot icon at the bottom-right to start.</p>
      </div>

      <ChatWidget tiles={TILE_QUESTIONS} />
    </div>
  )
}
```

---

## README_RUN.md

```md
# Run the frontend

1. Install dependencies:

   npm install

2. Create a .env file in project root with:

   VITE_API_BASE=http://localhost:8000

3. Start dev server:

   npm run dev

Notes:
- Microphone recording requires HTTPS for some browsers and user permission.
- Make sure your FastAPI backend (http://localhost:8000) permits CORS to your frontend origin.
- The app uses the /chat, /speech-to-text, /text-to-speech, /upload-document and /conversations endpoints from your backend.

### Backend expectations (endpoints)

- POST /chat
  - Body: { "message": "...", "conversation_id": "optional" }
  - Response: { "response": "..." }

- POST /upload-document
  - Form file field "file". Accepts PDF/Excel.
  - Response: { "filename": "name.pdf", "status": "ok", "id": "doc-id" }
  - Backend should: chunk the document, embed, add to vectorstore, and make searchable immediately.

- POST /speech-to-text
  - Form file field "file" (audio).
  - Response: { "text": "transcript" }

- GET /conversations
  - Returns saved conversations (optional)

- POST /conversations
  - Body: conversation object to save on server (optional)

If you want, I can also update your FastAPI backend to implement `/upload-document` and conversation endpoints ‚Äî I can provide a production-ready FastAPI implementation that performs chunking (using pdfplumber/pyxls), embeddings (using your existing CacheBackedEmbeddings), and updates the FAISS store.
```

---

## backend_snippets/fastapi_upload_example.py

```py
# Minimal example - integrate with your existing backend
from fastapi import APIRouter, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
import tempfile
import uuid

router = APIRouter()

@router.post('/upload-document')
async def upload_document(file: UploadFile = File(...)):
    # store file temporarily and process
    try:
        ext = file.filename.split('.')[-1].lower()
        tmp = tempfile.NamedTemporaryFile(delete=False, suffix='.'+ext)
        contents = await file.read()
        tmp.write(contents)
        tmp.flush()
        tmp.close()

        # TODO: chunking logic (pdfplumber for PDF, pandas for Excel)
        # Example: read pdf pages, create records list of {'content': text, 'meta': {...}}
        # then create Documents and call store = FAISS.from_documents(docs, cached_embeddings)
        # OR incremental add to existing store

        return JSONResponse({"filename": file.filename, "status": "ok", "id": str(uuid.uuid4())})
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

---

### Final notes
- I've kept the frontend fully self-contained and production-focused: storage in localStorage for offline reliability, and optional server sync for teams.
- The FileUploader calls `/upload-document` ‚Äî backend must implement chunking & vectorstore insertion. I added a starter FastAPI snippet in `backend_snippets/fastapi_upload_example.py` you can copy into your codebase and integrate with your existing `CachedBackedEmbeddings` + `FAISS` logic.
- If you'd like, I can now: (a) provide the full FastAPI backend code for `/upload-document`, chunking + embeddings + incremental FAISS update; (b) wire conversation server-side storage; (c) add permission/auth flows. Tell me which backend piece you want next and I will add it directly into the canvas.

