def determine_candidate_window(ref_df, test_df, step=1, initial_threshold=10):
    """
    Identify candidate window based on the actual time range in the data.
    """
    # Get the actual maximum time from the union of reference and test data
    max_ref_time = ref_df.iloc[:, 0].max()
    max_test_time = test_df.iloc[:, 0].max()
    fixed_max = max(max_ref_time, max_test_time)
    fixed_min = 0

    times = np.arange(fixed_min, fixed_max + 1, step)
    ref_vals = interpolate_linear(ref_df, times)
    test_vals = interpolate_linear(test_df, times)
    diff = np.abs(ref_vals - test_vals)
    
    valid_times = times[diff <= initial_threshold]
    if len(valid_times) == 0:
        print(f"No time points found within {initial_threshold}% difference; trying threshold=20.")
        valid_times = times[diff <= 20]
        if len(valid_times) == 0:
            print("No candidate window found even with 20% threshold. Using full range.")
            return fixed_min, fixed_max
        else:
            window_max = valid_times[-1]
            print(f"Candidate window determined (threshold 20): {fixed_min} to {window_max}")
            return fixed_min, window_max
    else:
        window_max = valid_times[-1]
        print(f"Candidate window determined (threshold {initial_threshold}): {fixed_min} to {window_max}")
        return fixed_min, window_max
#################
def interpolate_dissolution_curve(df, new_times, method='gpr'):
    """
    Predict dissolution values at new time points, clamping to observed time range.
    """
    df_sorted = df.sort_values(by=df.columns[0])
    known_times = df_sorted.iloc[:, 0].values.astype(float)
    known_values = df_sorted.iloc[:, 1].values
    
    # Clamp new_times to the observed range [min(known_times), max(known_times)]
    new_times_clamped = np.clip(new_times, known_times.min(), known_times.max())
    
    if method == 'gpr':
        # (Keep existing GPR code)
    else:
        if len(known_times) < 2:
            return np.full(len(new_times_clamped), known_values[0]) if len(known_values) > 0 else np.zeros(len(new_times_clamped))
        if method == 'cubic' and len(known_times) >= 4:
            f = interp1d(known_times, known_values, kind='cubic', fill_value='extrapolate')
        else:
            f = interp1d(known_times, known_values, kind='linear', fill_value=(known_values[0], known_values[-1]))
    return f(new_times_clamped)
