# Display final results
if overall_best:
    print("\n=== Optimal Predictive Combination ===")
    print(f"Condition: {overall_best.get('condition', 'N/A')}")
    print(f"Dissolution Range: {overall_best['diss_range']}")
    print(f"Time Points (3/5 min intervals): {overall_best['sequence']}")
    print(f"Length: {len(overall_best['sequence'])}")
    print(f"Predicted f2 Score: {overall_best['f2']}")

    # Compute predicted dissolution percentages for the optimal sequence
    optimal_sequence = overall_best['sequence']
    ref_diss_pred = interpolate_dissolution_curve(reference_mean_df, optimal_sequence, method='gpr')
    test_diss_pred = interpolate_dissolution_curve(test_mean_df, optimal_sequence, method='gpr')

    # If the predictions are in fraction, convert to percentage (0-100)
    ref_diss_pred_percent = ref_diss_pred * 100
    test_diss_pred_percent = test_diss_pred * 100

    # Ensure the dissolution at time zero is exactly 0
    if optimal_sequence[0] == 0:
        ref_diss_pred_percent[0] = 0.0
        test_diss_pred_percent[0] = 0.0

    # Print the predicted dissolution percentages alongside time points
    print("\nPredicted Reference Dissolution Percentages:")
    for t, d in zip(optimal_sequence, ref_diss_pred_percent):
        print(f"Time {t} min: {d:.2f}%")

    print("\nPredicted Test Dissolution Percentages:")
    for t, d in zip(optimal_sequence, test_diss_pred_percent):
        print(f"Time {t} min: {d:.2f}%")

    if overall_best['reasons']:
        print(f"\nCompliance Issues: {', '.join(overall_best['reasons'])}")
    else:
        print("\nRegulatory Compliance: Passed")
    
    # Print range statistics using unique candidates
    print_range_stats(unique_candidates)
    
    # Plot results (re-using the computed percentages)
    plt.figure(figsize=(12, 6))
    plt.plot(optimal_sequence, ref_diss_pred_percent, 'bo-', label='Reference')
    plt.plot(optimal_sequence, test_diss_pred_percent, 'r*--', label='Test')
    plt.title(f"Optimal Profile: {overall_best['diss_range']} Dissolution (f2 = {overall_best['f2']})")
    plt.xlabel('Time (min)')
    plt.ylabel('Dissolution (%)')
    plt.legend()
    plt.grid(True)
    plt.show()
else:
    print("‚ùå No valid combinations found across all dissolution ranges")
