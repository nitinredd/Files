import os
import streamlit as st
import pandas as pd
import numpy as np
from zipfile import ZipFile
from scipy.stats import skew, kurtosis, norm
import plotly.graph_objs as go

# ----------------------------------------
# Required Helper Functions
# ----------------------------------------

def prepare_data(reference_df, test_df):
    """Remove time zero if present and reset index"""
    if reference_df.shape[0] > 0 and (reference_df.iloc[0, 0] == 0 or reference_df.iloc[0, 0] == '0'):
        reference_df = reference_df.iloc[1:].reset_index(drop=True)
    if test_df.shape[0] > 0 and (test_df.iloc[0, 0] == 0 or test_df.iloc[0, 0] == '0'):
        test_df = test_df.iloc[1:].reset_index(drop=True)
    return reference_df, test_df

def conventional_f2(ref_means, test_means):
    """Calculate conventional f2 when passed mean series"""
    diff = test_means - ref_means
    sum_sq_diff = (diff ** 2).sum()
    p = len(ref_means)
    return 50 if p == 0 else 100 - 25 * np.log10(1 + (1/p) * sum_sq_diff)

def expected_f2(ref_df, test_df):
    """Calculate expected f2"""
    ref_means = ref_df.iloc[:, 1:].mean(axis=1)
    test_means = test_df.iloc[:, 1:].mean(axis=1)
    
    diff = test_means - ref_means
    sum_sq_diff = (diff ** 2).sum()
    
    ref_var = row_variance(ref_df)
    test_var = row_variance(test_df)
    sum_var = (ref_var + test_var).sum()
    
    n = ref_df.shape[1] - 1  # Number of units per time point
    p = len(ref_means)
    
    adjustment = (1/n) * sum_var if n > 0 else 0
    return 100 - 25 * np.log10(1 + (1/p) * (sum_sq_diff + adjustment))

def bias_corrected_f2(ref_df, test_df):
    """Calculate bias-corrected f2"""
    try:
        ref_means = ref_df.iloc[:, 1:].mean(axis=1)
        test_means = test_df.iloc[:, 1:].mean(axis=1)

        diff = test_means - ref_means
        sum_sq_diff = (diff ** 2).sum()

        ref_var = row_variance(ref_df)
        test_var = row_variance(test_df)
        sum_var = (ref_var + test_var).sum()

        n = ref_df.shape[1] - 1
        p = len(ref_means)

        if n <= 0 or p == 0:
            return None

        adjustment = (1 / n) * sum_var
        right_side = sum_sq_diff + p

        if adjustment < right_side:
            adjusted_diff = sum_sq_diff - adjustment
            if adjusted_diff > 0:
                return 100 - 25 * np.log10(1 + (1 / p) * adjusted_diff)
            else:
                return None
        else:
            return None

    except Exception:
        return None

def row_variance(df):
    """Calculate row-wise variance"""
    if df.shape[1] <= 1:
        return pd.Series(np.zeros(df.shape[0]))
    return df.iloc[:, 1:].var(axis=1, ddof=1)

def bootstrap_f2(ref_df, test_df, calc_func, n_iterations=10000):
    """
    Bootstrap f2 calculation (returns:
      original_f2, lower_bound, upper_bound, mean, median, skewness,
      kurtosis, f2_values (list)
    ).
    calc_func must accept (ref_df, test_df) and return numeric or None.
    """
    n_ref_units = max(ref_df.shape[1] - 1, 1)
    n_test_units = max(test_df.shape[1] - 1, 1)

    original_f2 = calc_func(ref_df, test_df)
    f2_values = []
    
    for _ in range(n_iterations):
        # sample columns (units) with replacement, keep time column (col 0)
        ref_sample_idx = np.random.choice(range(1, ref_df.shape[1]), n_ref_units, replace=True) if ref_df.shape[1] > 1 else []
        test_sample_idx = np.random.choice(range(1, test_df.shape[1]), n_test_units, replace=True) if test_df.shape[1] > 1 else []

        if len(ref_sample_idx) > 0:
            ref_sample = ref_df.iloc[:, [0] + list(ref_sample_idx)]
        else:
            ref_sample = ref_df.copy()
        if len(test_sample_idx) > 0:
            test_sample = test_df.iloc[:, [0] + list(test_sample_idx)]
        else:
            test_sample = test_df.copy()

        f2_val = calc_func(ref_sample, test_sample)

        if f2_val is not None and isinstance(f2_val, (int, float, np.floating)):
            f2_values.append(float(f2_val))
    
    if not f2_values:
        return original_f2, None, None, None, None, None, None, []
    
    f2_values = np.array(f2_values)
    mean_f2 = float(np.mean(f2_values))
    median_f2 = float(np.median(f2_values))
    skewness_f2 = float(skew(f2_values))
    kurtosis_f2 = float(kurtosis(f2_values))
    lower_bound = float(np.percentile(f2_values, 5))
    upper_bound = float(np.percentile(f2_values, 95))

    return float(original_f2) if original_f2 is not None else None, lower_bound, upper_bound, mean_f2, median_f2, skewness_f2, kurtosis_f2, f2_values.tolist()

# ----------------------------------------
# Batch Processing Functions (modified to keep bootstrap samples)
# ----------------------------------------

def load_batch_data(folder_path):
    """Load test and reference data from multiple Excel files in a folder."""
    workbook_data = {}
    
    for file_name in os.listdir(folder_path):
        if file_name.endswith(".xlsx") or file_name.endswith(".xls"):
            file_path = os.path.join(folder_path, file_name)
            try:
                reference_df = pd.read_excel(file_path, sheet_name=0)
                test_df = pd.read_excel(file_path, sheet_name=1)
                workbook_data[file_name] = (reference_df, test_df)
            except Exception as e:
                st.warning(f"Skipping file `{file_name}` due to error: {e}")
    
    return workbook_data

def process_batch(workbook_data, methods, n_iterations=10000):
    """
    Process multiple workbooks and calculate f2 metrics.
    Returns (summary_df, bootstrap_samples_map)
      - summary_df: DataFrame with summary values
      - bootstrap_samples_map: dict keyed by (file_name, method) -> list of bootstrap f2 values
    """
    all_results = []
    bootstrap_samples = {}  # (file_name, method) -> list
    
    for file_name, (reference_df, test_df) in workbook_data.items():
        try:
            ref_clean, test_clean = prepare_data(reference_df.copy(), test_df.copy())
            
            results = {"File Name": file_name}
            
            # Conventional Bootstrap (note: conventional_f2 expects means)
            if "Conventional Bootstrap" in methods:
                def conv_func(r, t):
                    ref_means = r.iloc[:, 1:].mean(axis=1)
                    test_means = t.iloc[:, 1:].mean(axis=1)
                    return conventional_f2(ref_means, test_means)
                orig, lower, upper, mean, median, skewness, kurt, vals = bootstrap_f2(
                    ref_clean, test_clean, conv_func, n_iterations)
                results["Conventional Bootstrap f2"] = orig
                results["Conventional Bootstrap CI"] = f"{lower:.2f} - {upper:.2f}" if lower is not None and upper is not None else None
                results["Conventional Bootstrap Mean"] = mean
                results["Conventional Bootstrap Median"] = median
                results["Conventional Bootstrap Skewness"] = skewness
                results["Conventional Bootstrap Kurtosis"] = kurt
                bootstrap_samples[(file_name, "Conventional Bootstrap")] = vals

            # Expected Bootstrap
            if "Expected Bootstrap" in methods:
                orig, lower, upper, mean, median, skewness, kurt, vals = bootstrap_f2(
                    ref_clean, test_clean, expected_f2, n_iterations)
                results["Expected Bootstrap f2"] = orig
                results["Expected Bootstrap CI"] = f"{lower:.2f} - {upper:.2f}" if lower is not None and upper is not None else None
                results["Expected Bootstrap Mean"] = mean
                results["Expected Bootstrap Median"] = median
                results["Expected Bootstrap Skewness"] = skewness
                results["Expected Bootstrap Kurtosis"] = kurt
                bootstrap_samples[(file_name, "Expected Bootstrap")] = vals

            # Bias Corrected Bootstrap
            if "Bias Corrected Bootstrap" in methods:
                def bc_func(r, t):
                    bc = bias_corrected_f2(r, t)
                    return float(bc) if isinstance(bc, (float, np.floating)) else None
                orig, lower, upper, mean, median, skewness, kurt, vals = bootstrap_f2(
                    ref_clean, test_clean, bc_func, n_iterations)
                results["Bias Corrected Bootstrap f2"] = orig
                results["Bias Corrected Bootstrap CI"] = f"{lower:.2f} - {upper:.2f}" if lower is not None and upper is not None else None
                results["Bias Corrected Bootstrap Mean"] = mean
                results["Bias Corrected Bootstrap Median"] = median
                results["Bias Corrected Bootstrap Skewness"] = skewness
                results["Bias Corrected Bootstrap Kurtosis"] = kurt
                bootstrap_samples[(file_name, "Bias Corrected Bootstrap")] = vals
            
            all_results.append(results)
        
        except Exception as e:
            st.warning(f"Error processing file `{file_name}`: {e}")
    
    summary_df = pd.DataFrame(all_results)
    return summary_df, bootstrap_samples

def create_zip_report(report_df):
    """Create a ZIP file containing the report CSV."""
    report_file = "f2_similarities_report.csv"
    zip_file = "f2_similarities_report.zip"
    
    report_df.to_csv(report_file, index=False)
    
    with ZipFile(zip_file, "w") as zipf:
        zipf.write(report_file)
    
    return zip_file

# ----------------------------------------
# Visualization: Robust JMP-style Q-Q Plot (Plotly)
# ----------------------------------------

def make_jmp_style_qq_plot(f2_values, title="Q-Q Plot (JMP-style)", envelope_sims=1000):
    """
    Robust JMP-styled Q-Q plot:
    - convert theoretical quantiles into f2 units (so both axes are f2)
    - handle NaN/inf, require at least 3 samples
    - draw 95% simulated envelope
    """
    if f2_values is None:
        return None

    arr = np.asarray(f2_values, dtype=float)
    # drop NaN / inf
    arr = arr[np.isfinite(arr)]
    if arr.size < 3:
        return None

    vals = np.sort(arr)
    n = len(vals)
    probs = (np.arange(1, n+1) - 0.5) / n
    z_theor = norm.ppf(probs)

    sample_mean = float(vals.mean())
    sample_sd = float(vals.std(ddof=1)) if n > 1 else 0.0

    # Theoretical quantiles mapped to f2 units (so x axis is in f2)
    theor = sample_mean + sample_sd * z_theor

    # Envelope: simulate normal samples with sample_mean & sample_sd, compute sorted quantiles
    lower_env = upper_env = None
    if sample_sd > 0 and envelope_sims > 0:
        sims = np.random.normal(loc=sample_mean, scale=sample_sd, size=(envelope_sims, n))
        sims.sort(axis=1)
        lower_env = np.percentile(sims, 2.5, axis=0)
        upper_env = np.percentile(sims, 97.5, axis=0)

    # Build plotly figure
    fig = go.Figure()

    # Envelope (fill between upper and lower) â€” use x = theor (f2 units)
    if lower_env is not None and upper_env is not None:
        fig.add_trace(go.Scatter(
            x=theor,
            y=upper_env,
            mode='lines',
            line=dict(width=0),
            showlegend=False,
            hoverinfo='skip',
            name='95% upper'
        ))
        fig.add_trace(go.Scatter(
            x=theor,
            y=lower_env,
            mode='lines',
            fill='tonexty',
            fillcolor='rgba(200,200,200,0.3)',
            line=dict(width=0),
            showlegend=True,
            hoverinfo='skip',
            name='95% envelope'
        ))

    # Sample points (x = theor, y = sample quantiles)
    fig.add_trace(go.Scatter(
        x=theor,
        y=vals,
        mode='markers',
        marker=dict(size=7, symbol='circle', color='black', opacity=0.85, line=dict(width=0.5, color='rgba(0,0,0,0.2)')),
        name='Sample quantiles',
        hovertemplate='Theor (f2): %{x:.3f}<br>Sample f2: %{y:.3f}<extra></extra>'
    ))

    # 45-degree reference line in f2 units
    min_axis = min(theor.min(), vals.min())
    max_axis = max(theor.max(), vals.max())
    pad = 0.05 * (max_axis - min_axis) if (max_axis - min_axis) > 0 else 0.1
    x_line = np.linspace(min_axis - pad, max_axis + pad, 2)
    y_line = x_line
    fig.add_trace(go.Scatter(
        x=x_line,
        y=y_line,
        mode='lines',
        line=dict(color='red', width=2),
        name='Reference line (y=x)'
    ))

    fig.update_layout(
        title=dict(text=title, x=0.01, xanchor='left', font=dict(size=16, family='Arial')),
        xaxis=dict(
            title='Theoretical Quantiles (mapped to f2 units)',
            showgrid=True,
            gridcolor='rgba(200,200,200,0.25)',
            zeroline=False,
            mirror=True,
            showline=True,
            linecolor='black',
            ticks='outside'
        ),
        yaxis=dict(
            title='Sample Quantiles (f2)',
            showgrid=True,
            gridcolor='rgba(200,200,200,0.25)',
            zeroline=False,
            mirror=True,
            showline=True,
            linecolor='black',
            ticks='outside'
        ),
        plot_bgcolor='white',
        legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1),
        margin=dict(l=60, r=20, t=80, b=60),
        hovermode='closest',
        height=520,
    )

    return fig, {"count": n, "mean": sample_mean, "sd": sample_sd, "min": float(vals.min()), "max": float(vals.max())}

# ----------------------------------------
# Streamlit App Code
# ----------------------------------------

def main():
    st.set_page_config(page_title="Batch Similarity Analyzer with JMP-style QQ", layout="wide")
    st.title("Batch Similarity Analyzer â€” JMP-style Interactive Bootstrap Qâ€“Q")
    st.markdown("""
    Upload a folder with Excel workbooks (sheet 0 = reference, sheet 1 = test).  
    Select bootstrap methods to compute and then inspect JMP-style Qâ€“Q plots of the bootstrap f2 values.
    """)

    # Left column: inputs
    with st.sidebar:
        st.header("Inputs / Settings")
        folder_path = st.text_input("Enter path to folder containing Excel files:", "")
        options = ["Conventional", "Expected", "Bias Corrected",
                   "Conventional Bootstrap", "Expected Bootstrap", "Bias Corrected Bootstrap"]
        selected_methods = st.multiselect("Select calculation methods:", options, default=["Conventional Bootstrap", "Expected Bootstrap"])
        n_iterations = st.slider("Bootstrap iterations (per file & per method):", 100, 20000, 2000, step=100)
        envelope_sims = st.slider("Envelope simulation count (for QQ envelope):", 100, 2000, 1000, step=100)
        run_button = st.button("Calculate and Generate Report")

    # Placeholder for results and interactive area
    results_area = st.container()
    plot_area = st.container()

    if run_button:
        if not os.path.isdir(folder_path):
            st.error("Invalid folder path. Please check the path and try again.")
            return

        with st.spinner("Processing files... this may take a while depending on bootstrap iterations..."):
            workbook_data = load_batch_data(folder_path)
            if not workbook_data:
                st.warning("No valid Excel files found in selected folder.")
                return

            methods_to_run = []
            for m in selected_methods:
                if "Bootstrap" in m:
                    methods_to_run.append(m)

            summary_df, bootstrap_samples = process_batch(workbook_data, methods_to_run, n_iterations=n_iterations)

        with results_area:
            st.subheader("ðŸ“Š Results Summary")
            if not summary_df.empty:
                st.dataframe(summary_df)
                zip_file_path = create_zip_report(summary_df)
                with open(zip_file_path, "rb") as f:
                    st.download_button(
                        label="Download Summary Report (ZIP)",
                        data=f,
                        file_name="f2_similarities_report.zip",
                        mime="application/zip"
                    )
            else:
                st.info("No summary data produced. Make sure you selected at least one Bootstrap method.")

        # Interactive plotting area
        with plot_area:
            st.subheader("ðŸ“ˆ Interactive JMP-style Qâ€“Q Plot for Bootstrap Samples")
            files_available = sorted({k[0] for k in bootstrap_samples.keys()})
            if not files_available:
                st.info("No bootstrap samples available to plot. Make sure you selected bootstrap methods and data files contain both sheets.")
                return

            file_choice = st.selectbox("Select file to inspect:", files_available)
            methods_available = [k[1] for k in bootstrap_samples.keys() if k[0] == file_choice]
            method_choice = st.selectbox("Select bootstrap method:", sorted(set(methods_available)))

            # Retrieve f2 samples for selection
            f2_vals = bootstrap_samples.get((file_choice, method_choice), [])
            if not f2_vals:
                st.warning("No bootstrap f2 values for this selection (maybe bias-corrected failed for this dataset).")
            else:
                qq_title = f"Qâ€“Q Plot (JMP-style) â€” {file_choice} â€” {method_choice}"
                res = make_jmp_style_qq_plot(f2_vals, title=qq_title, envelope_sims=envelope_sims)
                if res is None:
                    st.warning("Unable to generate Qâ€“Q plot (not enough finite bootstrap values).")
                else:
                    fig, stats = res
                    # Debug small card
                    st.markdown("**Bootstrap sample stats**")
                    st.write(f"Count: {stats['count']}  â€¢  Mean: {stats['mean']:.3f}  â€¢  SD: {stats['sd']:.3f}  â€¢  Min: {stats['min']:.3f}  â€¢  Max: {stats['max']:.3f}")
                    st.plotly_chart(fig, use_container_width=True)

                    # Optional histogram below the QQ
                    st.markdown("**Bootstrap f2 distribution**")
                    hist = go.Figure()
                    hist.add_trace(go.Histogram(x=np.array(f2_vals), nbinsx=40, marker=dict(line=dict(width=0.1))))
                    hist.update_layout(
                        title="Bootstrap f2 distribution",
                        xaxis_title="f2 value",
                        yaxis_title="Count",
                        plot_bgcolor='white',
                        margin=dict(l=40, r=20, t=40, b=40),
                        height=300
                    )
                    st.plotly_chart(hist, use_container_width=True)

    else:
        st.info("Set the folder path and options in the left sidebar then click **Calculate and Generate Report**.")

if __name__ == "__main__":
    main()
