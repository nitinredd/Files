# ======================== STAGE 2: Helper & Predictive Analysis Functions ========================
def generate_all_time_combinations(min_time, max_time, step=1):
    """
    Generate all possible time point sequences within the interval [min_time, max_time],
    ensuring that 0 is fixed at the start and that there are at least 3 points.
    """
    # MODIFIED: Always generate both 3 and 5 minute intervals
    times = list(np.unique(np.concatenate([
        np.arange(min_time, max_time + 1, 3),
        np.arange(min_time, max_time + 1, 5)
    ]))
    if 0 not in times:
        times.insert(0, 0)
    all_combinations = []
    for r in range(2, len(times)):
        for combo in itertools.combinations(times[1:], r):
            seq = [0] + list(combo)
            all_combinations.append(sorted(seq))
    return list(all_combinations)
###################################################
# Inside predictive_optimal_combinations_advanced function
# After interpolation (around line 1220 in original code):

# Add dissolution range calculation
max_ref = np.nanmax(ref_vals)
max_test = np.nanmax(test_vals)
max_diss = max(max_ref, max_test)

if max_diss <= 30:
    diss_range = "0-30%"
elif 30 < max_diss <= 60:
    diss_range = "30-60%"
elif 60 < max_diss <= 90:
    diss_range = "60-90%"
else:
    diss_range = "90-100%"

# Update results storage
results.append({
    'sequence': seq,
    'f2': round(f2, 2),
    'compliant': compliance_status[i],
    'reasons': compliance_reasons[i],
    'length': len(seq),
    'diss_range': diss_range  # New field
})
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
def print_range_stats(results):
    """New function to print dissolution range statistics"""
    range_stats = {
        "0-30%": {"total": 0, "compliant": 0},
        "30-60%": {"total": 0, "compliant": 0},
        "60-90%": {"total": 0, "compliant": 0},
        "90-100%": {"total": 0, "compliant": 0}
    }
    
    for res in results:
        rng = res['diss_range']
        range_stats[rng]['total'] += 1
        if res['compliant']:
            range_stats[rng]['compliant'] += 1
            
    print("\n=== Dissolution Range Statistics ===")
    for rng, stats in range_stats.items():
        print(f"{rng}:")
        print(f"  Total combinations: {stats['total']}")
        print(f"  Compliant combinations: {stats['compliant']}")
        if stats['total'] > 0:
            compliance_rate = stats['compliant']/stats['total']*100
            print(f"  Compliance rate: {compliance_rate:.1f}%")
        print()
###############################################################################
# Replace existing print statement with:
print(f"{idx+1:3d}. Range: {cand['diss_range']} | Length: {cand['length']} | f2: {cand['f2']} | Compliant: {comp} | Reasons: {reasons}")

# Add after sorting results
print_range_stats(all_candidates_sorted)
