import itertools
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm
from sklearn.utils import resample

# -------------------------- PERMUTATION ANALYSIS FUNCTIONS --------------------------

def generate_time_permutations_fixed_zero(times):
    """
    Generate all order-sensitive permutations of time points for lengths
    between 3 and len(times) (inclusive) with 0 fixed as the first element.
    Assumes that the input 'times' is a list of numeric time points.
    """
    try:
        # Ensure times are integers and sorted so that 0 is first if present
        times = sorted([int(t) for t in times])
        # Ensure 0 is present
        if 0 not in times:
            times.insert(0, 0)
        # Separate 0 from the other time points
        nonzero = [t for t in times if t != 0]
        all_perms = []
        total = len(times)  # total including 0
        # For sequence lengths from 3 up to total
        for r in range(3, total + 1):
            # We choose (r-1) time points from nonzero values in all possible orders
            for perm in itertools.permutations(nonzero, r - 1):
                seq = [0] + list(perm)  # Prepend 0 as fixed starting point
                all_perms.append(seq)
        print(f"Generated {len(all_perms)} permutations with 0 fixed at start")
        return all_perms
    except Exception as e:
        print(f"Permutation generation error: {str(e)}")
        return []

def permutation_compliance_check(perm, regulation, ref_means, test_means):
    """
    Check compliance for a given time sequence (with 0 fixed at the start) 
    based on regulatory rules.
    """
    reasons = []
    compliant = True

    # FDA: If an 85% (or higher) dissolution is observed, it must be at the last point.
    if regulation == "FDA":
        found_85 = False
        for i, t in enumerate(perm):
            if ref_means.get(t, 0) >= 85 or test_means.get(t, 0) >= 85:
                if i < len(perm) - 1:  # Must be the final measurement
                    reasons.append(f"Early 85% at position {i+1} ({t} min)")
                    compliant = False
                found_85 = True
                break
        if not found_85 and 0 not in perm:
            reasons.append("Missing zero time point")
            compliant = False

    # EMA: All time points must have dissolution <85% and at least 4 time points are required.
    elif regulation == "EMA":
        over_points = [t for t in perm if ref_means.get(t, 0) >= 85 or test_means.get(t, 0) >= 85]
        if over_points:
            reasons.append(f"85%+ dissolution at: {over_points}")
            compliant = False
        if len(perm) < 4:
            reasons.append("Requires ≥4 time points")
            compliant = False

    # China: Only the reference product is considered; no time point should have ≥85% dissolution.
    elif regulation == "China":
        over_ref = [t for t in perm if ref_means.get(t, 0) >= 85]
        if over_ref:
            reasons.append(f"Reference ≥85% at: {over_ref}")
            compliant = False

    # ASEAN: The first 3 time points must be below 85% for both reference and test.
    elif regulation == "ASEAN":
        check_points = perm[:3] if len(perm) >= 3 else perm
        over_ref = [t for t in check_points if ref_means.get(t, 0) >= 85]
        over_test = [t for t in check_points if test_means.get(t, 0) >= 85]
        if over_ref:
            reasons.append(f"Reference ≥85% in first 3 points: {over_ref}")
            compliant = False
        if over_test:
            reasons.append(f"Test ≥85% in first 3 points: {over_test}")
            compliant = False

    # ANVISA: The 0 time point must be present and must be the first element.
    elif regulation == "ANVISA":
        if 0 not in perm:
            reasons.append("Missing zero time point")
            compliant = False
        elif perm[0] != 0:
            reasons.append("Zero not in first position")
            compliant = False

    return (compliant, " | ".join(reasons) if reasons else "Compliant")

def full_permutation_analysis(ref_df, test_df, regulation):
    """
    Perform a full permutation analysis:
      - Generate all sequences (with 0 fixed at start) for lengths from 3 to n.
      - Calculate f2 for each sequence.
      - Check regulatory compliance.
    """
    try:
        # Extract original time points from the first column of the reference DataFrame.
        times = ref_df.iloc[:, 0].tolist()
        # Ensure 0 is included
        if 0 not in times:
            times.insert(0, 0)
        
        # Calculate the mean dissolution values for each time point (row).
        ref_means = ref_df.set_index(ref_df.columns[0]).iloc[:, 1:].mean(axis=1).to_dict()
        test_means = test_df.set_index(test_df.columns[0]).iloc[:, 1:].mean(axis=1).to_dict()
        # If 0 was artificially inserted, assign its dissolution mean as 0.
        if 0 not in ref_means:
            ref_means[0] = 0
        if 0 not in test_means:
            test_means[0] = 0

        # Generate all order-sensitive permutations with 0 fixed at start.
        perms = generate_time_permutations_fixed_zero(times)
        print(f"Analyzing {len(perms)} permutations for {regulation}...")
        
        results = []
        for perm in perms:
            try:
                p = len(perm)
                # Use the permutation (0 is fixed at the beginning)
                time_order = perm
                
                # Retrieve the mean dissolution values for this sequence.
                ref_values = [ref_means.get(t, 0) for t in time_order]
                test_values = [test_means.get(t, 0) for t in time_order]
                
                # Calculate f2 using the formula.
                diff = np.array(test_values) - np.array(ref_values)
                sum_sq = (diff ** 2).sum()
                f2 = 100 - 25 * np.log10(1 + (sum_sq / p)) if p > 0 else 0
                
                # Check compliance based on the regulatory rule.
                compliant, reason = permutation_compliance_check(time_order, regulation, ref_means, test_means)
                
                results.append({
                    'permutation': time_order,
                    'f2': round(f2, 2),
                    'length': p,
                    'compliant': compliant,
                    'reason': reason
                })
            except Exception as e:
                print(f"Error processing {perm}: {str(e)}")
                continue
                
        return sorted(results, key=lambda x: (-x['f2'], x['length']))
    
    except Exception as e:
        print(f"Analysis failed: {str(e)}")
        return []

def display_permutation_results(results, regulation):
    """
    Display the permutation analysis results.
    """
    if not results:
        print("\nNo valid permutations found")
        return
    
    # Show all results on one page.
    page_size = len(results)
    
    print(f"\n{'='*120}")
    print(f" Complete Permutation Analysis ({regulation})")
    print(f"{'Time Sequence':<40} | {'Length':<6} | {'f2':<8} | {'Status':<8} | Compliance Details")
    print("-"*120)
    
    for res in results[:page_size]:
        status = "✅" if res['compliant'] else "❌"
        print(f"{str(res['permutation']):<40} | {res['length']:^6} | {res['f2']:^8.2f} | {status:^8} | {res['reason']}")
    
    print("="*120 + "\n")
    
    # Return the optimal (highest f2 among compliant) sequence if available.
    compliant_results = [r for r in results if r['compliant']]
    if compliant_results:
        best = max(compliant_results, key=lambda x: x['f2'])
        print(f"Optimal Compliant Combination:")
        print(f"Sequence: {best['permutation']}")
        print(f"f2 Score: {best['f2']:.2f}")
        print(f"Compliance: {best['reason']}")
        return best['permutation']
    else:
        return None

# -------------------------- PLOTTING FUNCTIONS --------------------------

def plot_dissolution_curves(ref_df, test_df, optimal_seq):
    """
    Generate two graphs:
      1. Full dissolution curves for the reference and test products, with vertical
         lines marking the optimal time points.
      2. Dissolution curves (points connected by lines) only for the optimal time points.
    """
    # Sort the DataFrames by time.
    ref_df_sorted = ref_df.sort_values(by=ref_df.columns[0])
    test_df_sorted = test_df.sort_values(by=test_df.columns[0])
    
    # Extract full time points and mean dissolution values.
    time_points_full = ref_df_sorted.iloc[:, 0].astype(float).tolist()
    ref_means_full = ref_df_sorted.iloc[:, 1:].mean(axis=1).tolist()
    test_means_full = test_df_sorted.iloc[:, 1:].mean(axis=1).tolist()
    
    # Retrieve mean dissolution values at the optimal time points.
    ref_means_opt = []
    test_means_opt = []
    for t in optimal_seq:
        # Find the corresponding row in the DataFrame.
        ref_row = ref_df[ref_df.iloc[:, 0] == t]
        test_row = test_df[test_df.iloc[:, 0] == t]
        if not ref_row.empty:
            ref_mean = ref_row.iloc[:, 1:].mean(axis=1).values[0]
        else:
            ref_mean = 0
        if not test_row.empty:
            test_mean = test_row.iloc[:, 1:].mean(axis=1).values[0]
        else:
            test_mean = 0
        ref_means_opt.append(ref_mean)
        test_means_opt.append(test_mean)
    
    # --------------------- Graph 1: Full Curves with Optimal Time Points ---------------------
    plt.figure(figsize=(10, 6))
    plt.plot(time_points_full, ref_means_full, marker='o', linestyle='-', color='blue', label='Reference Full')
    plt.plot(time_points_full, test_means_full, marker='o', linestyle='-', color='red', label='Test Full')
    for t in optimal_seq:
        plt.axvline(x=t, color='gray', linestyle='--', alpha=0.5)
    plt.title('Full Dissolution Curves with Optimal Time Points Indicated')
    plt.xlabel('Time')
    plt.ylabel('Dissolution Percentage')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    
    # --------------------- Graph 2: Optimal Time Points Only ---------------------
    plt.figure(figsize=(10, 6))
    plt.plot(optimal_seq, ref_means_opt, marker='o', linestyle='-', color='blue', label='Reference Optimal')
    plt.plot(optimal_seq, test_means_opt, marker='o', linestyle='-', color='red', label='Test Optimal')
    plt.title('Dissolution Curves at Optimal Time Points')
    plt.xlabel('Time')
    plt.ylabel('Dissolution Percentage')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# -------------------------- MAIN INTEGRATION --------------------------
# Assume that the following are defined:
# - reference_df: DataFrame with time in the first column and replicate dissolution data in other columns.
# - test_df: DataFrame with time in the first column and replicate dissolution data in other columns.
# - check_same_time_points: a function that validates that the time points match between dataframes.
# - input1: an integer key (1-5) to select the regulation.
# - regulation_map: a dictionary mapping keys to regulatory strings.

regulation_map = {
    1: "FDA",
    2: "EMA", 
    3: "China",
    4: "ASEAN",
    5: "ANVISA"
}

# Only proceed if the time points in the reference and test data match.
if check_same_time_points(reference_df, test_df):
    print("\nRunning advanced permutation analysis with 0 fixed at the start...")
    perm_results = full_permutation_analysis(
        reference_df.copy(),
        test_df.copy(),
        regulation_map[input1]
    )
    # Display all results and capture the optimal sequence.
    optimal_sequence = display_permutation_results(perm_results, regulation_map[input1])
    
    # If an optimal sequence was found, generate the two graphs.
    if optimal_sequence is not None:
        plot_dissolution_curves(reference_df, test_df, optimal_sequence)
    else:
        print("No compliant sequence found; no graphs will be generated.")
else:
    print("\nSkipping permutation analysis - Time points mismatch")
