import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d

def predictive_optimal_combinations_advanced(ref_df, test_df, regulation,
                                             window_min, window_max,
                                             grid_step=0.1):
    # 1) Fine grid
    times_fine = np.arange(window_min, window_max+1e-9, grid_step)

    # 2) Mean curves & interpolators
    raw_t      = ref_df.iloc[:, 0].astype(float).values
    ref_mean   = ref_df.iloc[:, 1:].mean(axis=1).values
    test_mean  = test_df.iloc[:, 1:].mean(axis=1).values

    ref_intp   = interp1d(raw_t, ref_mean,  kind='linear',
                          bounds_error=False, fill_value='extrapolate')
    test_intp  = interp1d(raw_t, test_mean, kind='linear',
                          bounds_error=False, fill_value='extrapolate')

    full_ref   = ref_intp(times_fine)
    full_test  = test_intp(times_fine)

    # 3) Conventional f2 (exclude t=0)
    nz = times_fine > window_min
    d_full = full_test[nz] - full_ref[nz]
    p_full = len(d_full)
    f2_full = 100 - 25 * np.log10(1 + np.sum(d_full**2) / p_full)

    # 4) Strata (0–30, 30–60, 60–90)
    strata = [(0,30), (30,60), (60,90)]
    preds  = [window_min]  # always include start

    for low, high in strata:
        # times where ref in [low, high)
        mask = (full_ref >= low) & (full_ref < high)
        td   = times_fine[mask]
        if len(td) < 2:
            raise ValueError(f"Not enough points in {low}–{high}% stratum.")
        # pick earliest & latest
        preds += [float(td.min()), float(td.max())]

    # 5) 85% rule
    if regulation in ("FDA", "ANVISA"):
        t85 = float(np.interp(85, full_ref, times_fine))
    else:  # EMA, China, ASEAN
        t85r = float(np.interp(85, full_ref,  times_fine))
        t85t = float(np.interp(85, full_test, times_fine))
        t85  = min(t85r, t85t)
    preds.append(t85)

    preds = sorted(set(preds))

    # 6) Predicted f2 (exclude t=0)
    ref_pred  = ref_intp(preds)
    test_pred = test_intp(preds)
    if preds[0] == window_min:
        ref_pred[0]  = 0.0
        test_pred[0] = 0.0

    dp = test_pred[1:] - ref_pred[1:]
    pp = len(dp)
    f2_pred = 100 - 25 * np.log10(1 + np.sum(dp**2) / pp)

    # 7) Plot
    plt.figure(figsize=(8,5))
    plt.plot(times_fine, full_ref,  'b-',  label='Ref Full')
    plt.plot(times_fine, full_test, 'r--', label='Test Full')
    plt.plot(preds,       ref_pred,  'ko-', label='Ref Selected')
    plt.plot(preds,       test_pred, 'ms--',label='Test Selected')
    plt.axvline(preds[-1], color='gray', linestyle=':')
    plt.title(f"f2_full={f2_full:.1f}, f2_pred={f2_pred:.1f}")
    plt.xlabel("Time")
    plt.ylabel("Dissolution %")
    plt.legend()
    plt.grid(True)
    plt.show()

    return {
        'predicted_times': preds,
        'f2_full': round(f2_full,2),
        'f2_pred': round(f2_pred,2)
    }
