// src/App.jsx
import React, { useEffect, useState, useRef } from "react";
import { motion } from "framer-motion";

import ChatWindow from "./components/ChatWindow";
import ProductTabs from "./components/ProductTabs";
import ProductDetailModal from "./components/ProductDetailModal";
import ReactionTiles from "./components/ReactionTiles";
import PromptGallery from "./components/PromptGallery";

import {
  fetchReactions,
  fetchPrompts,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  queryWithCitations,
  uploadFile,
} from "./api";

import Navbar from "./Navbar/Navbar";
import Footer from "./Footer/Footer";

import chem_logo from "../assets/Chemhub_Logo_Colored.png";

export default function App() {
  // Global app state
  const [reactions, setReactions] = useState([]);
  const [prompts, setPrompts] = useState([]);

  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);

  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);

  const [detailModalOpen, setDetailModalOpen] = useState(false);

  const [messages, setMessages] = useState([]); // chat messages
  const [history, setHistory] = useState([]); // still kept for product-history entries (not rendered)

  // Loading state flags
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [queryLoading, setQueryLoading] = useState(false);

  // Selected citations (right-click / multi-select)
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);

  // For scheme preview in chat
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  // Prompt Gallery modal state
  const [promptGalleryOpen, setPromptGalleryOpen] = useState(false);

  // Refs
  const chatWindowRef = useRef(null);

  // Carousel state (5 slides)
  const [carouselIndex, setCarouselIndex] = useState(0);
  const carouselRef = useRef({ paused: false, intervalId: null });

  // Initialize reactions and prompts
  useEffect(() => {
    fetchReactions()
      .then((r) => {
        setReactions(r || []);
      })
      .catch((e) => {
        console.error("fetchReactions error:", e);
      });

    fetchPrompts()
      .then((p) => {
        // some backends return {prompts: [...]}, accept both shapes
        setPrompts(p?.prompts || p || []);
      })
      .catch((e) => {
        console.warn("fetchPrompts failed:", e);
      });

    // minimal onboarding message
    setMessages([
      {
        role: "assistant",
        content:
          "Welcome — type a reaction or product name to find documents, or ask a question directly.",
      },
    ]);
  }, []);

  // Carousel autoplay
  useEffect(() => {
    startCarousel();
    return stopCarousel;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const startCarousel = () => {
    stopCarousel();
    carouselRef.current.intervalId = setInterval(() => {
      if (!carouselRef.current.paused) {
        setCarouselIndex((i) => (i + 1) % 5);
      }
    }, 3600);
  };
  const stopCarousel = () => {
    if (carouselRef.current.intervalId) {
      clearInterval(carouselRef.current.intervalId);
      carouselRef.current.intervalId = null;
    }
  };

  const pauseCarousel = () => {
    carouselRef.current.paused = true;
  };
  const resumeCarousel = () => {
    carouselRef.current.paused = false;
  };

  // Utility to push a message
  const pushMessage = (m) => setMessages((prev) => [...prev, m]);

  // Normalize helper
  const normalize = (s) => (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");

  // Product selection flow (opens modal, preloads scheme, fetches details)
  const handleSelectProduct = async (productId) => {
    try {
      setLoadingDetails(true);
      const meta = await fetchProductMeta(productId);
      setSelectedProduct(meta);
      setProductDetails(null);
      setSelectedSchemeUrl(null);
      setDetailModalOpen(true);

      // preload scheme image url for quicker preview
      try {
        const schemeUrl = await fetchSchemeImageUrl(productId);
        setSelectedSchemeUrl(schemeUrl);
      } catch (e) {
        // ignore
      }

      // fetch full extraction (canonical extraction)
      const res = await fetchProductDetails(productId); // default extraction
      const payload = (res && res.data) ? res.data : res;
      setProductDetails(payload);

      // add to history (kept internal)
      setHistory((h) => [
        { title: meta.name, content: payload.procedure ? payload.procedure.slice(0, 120) : "", productId: meta.id },
        ...h,
      ]);
    } catch (err) {
      console.error("handleSelectProduct error:", err);
      pushMessage({ role: "assistant", content: "Failed to load product details." });
    } finally {
      setLoadingDetails(false);
    }
  };

  // When user right-clicks or context-adds a product to citations
  const handleToggleCite = (product) => {
    const exists = selectedCitedDocs.find((p) => p.id === product.id);
    if (exists) {
      setSelectedCitedDocs((prev) => prev.filter((p) => p.id !== product.id));
      pushMessage({ role: "assistant", content: `Removed citation: ${product.name}` });
    } else {
      setSelectedCitedDocs((prev) => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: "assistant", content: `Added citation: ${product.name}` });
    }
  };

  // Remove citation helper (used by UI)
  const removeCitation = (id) => {
    const found = selectedCitedDocs.find((d) => d.id === id);
    setSelectedCitedDocs((prev) => prev.filter((d) => d.id !== id));
    if (found) pushMessage({ role: "assistant", content: `Removed citation: ${found.name}` });
  };

  // Upload callback (called from ChatWindow "+" button)
  const handleUploadFile = async (file) => {
    if (!file) return;
    try {
      pushMessage({ role: "assistant", content: `Uploading ${file.name}...` });
      const form = new FormData();
      form.append("file", file);
      form.append("reaction_type", "Miscellaneous");
      const resp = await uploadFile(form);
      pushMessage({ role: "assistant", content: `Upload complete: ${file.name}` });
      // optionally refresh product lists or download response if needed
    } catch (err) {
      console.error("uploadFile error:", err);
      pushMessage({ role: "assistant", content: "File upload failed." });
    }
  };

  // When user picks a sample prompt from the gallery: send it immediately to the chat
  const handlePromptPick = async (promptText) => {
    setPromptGalleryOpen(false);
    await handleUserSend(promptText);
  };

  // Main user-send handler
  const handleUserSend = async (text) => {
    // push user message
    pushMessage({ role: "user", content: text });

    // Reaction detection: if text is a reaction name, list products
    const norm = normalize(text);
    const match = reactions.find((r) => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g, "_")));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        pushMessage({ role: "assistant", content: `Found ${prods.length} product${prods.length === 1 ? "" : "s"} — pick one below.` });
      } catch (e) {
        console.error(e);
        pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
      }
      return;
    }

    // If user has selected citations, query across them
    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      setQueryLoading(true);
      pushMessage({ role: "assistant", content: "Searching selected documents...", loading: true });
      try {
        const ids = selectedCitedDocs.map((d) => d.id);
        const res = await queryWithCitations(ids, text);
        const payload = (res && res.data) ? res.data : res;
        // remove loading placeholder
        setMessages((prev) => {
          const idx = prev.map((m) => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = [...prev];
            copy.splice(idx, 1);
            return copy;
          }
          return prev;
        });
        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        const sources = (payload?.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: "assistant", content: "Error querying selected documents." });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    // If no selected product, let backend attempt to detect product name inside question or route to LLM
    setQueryLoading(true);
    pushMessage({ role: "assistant", content: "Searching documents...", loading: true });
    try {
      const res = await fetchProductDetails(undefined, text);
      const payload = (res && res.data) ? res.data : res;

      // remove loading placeholder
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });

      if (payload && payload.api_name) {
        // structured data returned
        let summary = "";
        if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
        if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
        if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
        if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
        pushMessage({ role: "assistant", content: summary, tables: (payload.tables || []) });
      } else if (payload && (payload.answer || payload.response)) {
        const answer = payload.answer || payload.response || "No answer.";
        const sources = (payload.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } else {
        pushMessage({ role: "assistant", content: "No structured data found. Try selecting a product or ask for specific extraction." });
      }
    } catch (err) {
      console.error("fetchProductDetails error (no product):", err);
      pushMessage({ role: "assistant", content: "Error querying documents." });
    } finally {
      setQueryLoading(false);
    }
    return;
  };

  // When user selects a reaction tile, fetch products for that reaction
  const handleReactionClick = async (reactionName) => {
    setSelectedReaction(reactionName);
    try {
      const prods = await fetchProducts(reactionName);
      setProducts(prods || []);
      setProductListVisible(true);
      pushMessage({ role: "assistant", content: `Found ${prods.length} products for ${reactionName}` });
    } catch (e) {
      console.error(e);
      pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
    }
  };

  // Render helper: carousel slides
  const Carousel = () => {
    // five slides: 0 = welcome + logo; 1-4 = placeholders
    const slides = [
      { id: 0, content: "welcome" },
      { id: 1, content: "placeholder-1" },
      { id: 2, content: "placeholder-2" },
      { id: 3, content: "placeholder-3" },
      { id: 4, content: "placeholder-4" },
    ];

    return (
      <div
        className="w-full overflow-hidden rounded-2xl mb-6"
        onMouseEnter={pauseCarousel}
        onMouseLeave={resumeCarousel}
      >
        <div
          className="flex w-[500%] transition-transform duration-700"
          style={{ transform: `translateX(-${carouselIndex * 100}%)` }}
        >
          {/* Slide 0: Welcome + logo */}
          <div className="w-full flex-shrink-0 flex items-center justify-center p-8 bg-gradient-to-r from-white to-white">
            <div className="w-full max-w-3xl bg-white/5 rounded-2xl p-6 shadow-lg flex flex-col items-center justify-center">
              <div className="text-xl font-bold text-gray-700 mb-4">Welcome to</div>
              <img src={chem_logo} alt="logo" className="h-24 w-auto" />
            </div>
          </div>

          {/* Slide 1 */}
          <div className="w-full flex-shrink-0 flex items-center justify-center p-8">
            <div className="w-full max-w-3xl h-36 rounded-2xl shadow-lg flex items-center justify-center"
                 style={{ background: "linear-gradient(135deg,#FFB199,#FF8A8A)" }}>
              {/* empty placeholder - add images later */}
            </div>
          </div>

          {/* Slide 2 */}
          <div className="w-full flex-shrink-0 flex items-center justify-center p-8">
            <div className="w-full max-w-3xl h-36 rounded-2xl shadow-lg flex items-center justify-center"
                 style={{ background: "linear-gradient(135deg,#A0FFAF,#78D9FF)" }}>
            </div>
          </div>

          {/* Slide 3 */}
          <div className="w-full flex-shrink-0 flex items-center justify-center p-8">
            <div className="w-full max-w-3xl h-36 rounded-2xl shadow-lg flex items-center justify-center"
                 style={{ background: "linear-gradient(135deg,#C7B2FF,#FFD6A5)" }}>
            </div>
          </div>

          {/* Slide 4 */}
          <div className="w-full flex-shrink-0 flex items-center justify-center p-8">
            <div className="w-full max-w-3xl h-36 rounded-2xl shadow-lg flex items-center justify-center"
                 style={{ background: "linear-gradient(135deg,#FFD1DC,#C3F6FF)" }}>
            </div>
          </div>
        </div>

        {/* pager dots */}
        <div className="flex items-center justify-center gap-2 mt-3">
          {slides.map((s) => (
            <button
              key={s.id}
              className={`w-2 h-2 rounded-full ${carouselIndex === s.id ? "bg-gray-800" : "bg-gray-300"}`}
              onClick={() => setCarouselIndex(s.id)}
              aria-label={`Go to slide ${s.id + 1}`}
            />
          ))}
        </div>
      </div>
    );
  };

  return (
    <>
      <Navbar />

      <div className="min-h-screen bg-gradient-to-b from-bg to-white flex justify-center">
        <div className="w-full max-w-7xl py-8 px-4">

          {/* Carousel slides (5 sliding rectangles) */}
          <Carousel />

          {/* Reaction tiles */}
          <div className="mb-4">
            <ReactionTiles reactions={reactions} onSelect={handleReactionClick} />
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Left column: chat + prompt gallery */}
            <div className="lg:col-span-2">
              {/* Chat window */}
              <ChatWindow
                ref={chatWindowRef}
                messages={messages}
                onSend={handleUserSend}
                centeredWidth="w-full"
                loading={queryLoading || loadingDetails}
                selectedSchemeUrl={selectedSchemeUrl}
                selectedProduct={selectedProduct}
                onUploadFile={handleUploadFile}       /* upload plus button inside chat */
                openPromptGallery={() => setPromptGalleryOpen(true)} /* opens gallery modal */
                selectedCitedDocs={selectedCitedDocs}
                removeCitation={removeCitation}
              />

              {/* Prompt gallery modal */}
              <PromptGallery
                open={promptGalleryOpen}
                onClose={() => setPromptGalleryOpen(false)}
                prompts={prompts}
                onPick={(p) => handlePromptPick(p.prompt || p)}
              />
            </div>

            {/* Right column: products list */}
            <div className="lg:col-span-1">
              {productListVisible && (
                <div className="mb-4">
                  <h3 className="text-lg font-semibold mb-2">Matched Products</h3>
                  <ProductTabs
                    products={products}
                    onSelect={(id) => handleSelectProduct(id)}
                    onContext={(product) => handleToggleCite(product)}
                    citedIds={new Set(selectedCitedDocs.map((d) => d.id))}
                  />
                </div>
              )}
            </div>
          </div>

          {/* Product detail modal */}
          <ProductDetailModal
            open={detailModalOpen}
            onClose={() => setDetailModalOpen(false)}
            meta={selectedProduct}
            details={productDetails}
            loading={loadingDetails}
          />
        </div>
      </div>

      <Footer />
    </>
  );
}
