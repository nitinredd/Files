# ====================== START OF NEW ROBUST ADDITION ======================
# Add this RIGHT BEFORE the R_Regulation() calls in each regulation block

import itertools
import sys
import traceback

def generate_time_combinations(times):
    """Generate all combinations of 3+ time points"""
    try:
        times = sorted(list(set(times)))
        combos = []
        for r in range(3, len(times)+1):
            combos.extend(itertools.combinations(times, r))
        return [list(map(int, combo)) for combo in combos]
    except Exception as e:
        print(f"Combination generation error: {str(e)}")
        return []

def calculate_combo_f2(ref_sub, test_sub):
    """Robust f2 calculation for a time combination"""
    try:
        p = len(ref_sub)
        if p < 3: return None
        
        ref_mean = ref_sub.iloc[:,1:].mean(axis=1)
        test_mean = test_sub.iloc[:,1:].mean(axis=1)
        diff = test_mean - ref_mean
        sum_sq = (diff**2).sum()
        
        return 100 - 25 * np.log10(1 + (sum_sq/p))
    except:
        return None

def is_compliant(combo, regulation, ref_means, test_means):
    """Check regulatory compliance for a combination"""
    try:
        # FDA: Truncate when either product reaches 85%
        if regulation == "FDA":
            ref_85 = next((t for t in combo if ref_means[t] >= 85), None)
            test_85 = next((t for t in combo if test_means[t] >= 85), None)
            trunc = min(filter(None, [ref_85, test_85])) if any([ref_85, test_85]) else max(combo)
            return all(t <= trunc for t in combo)
        
        # EMA: All points <85%
        elif regulation == "EMA":
            return all(ref_means.get(t, 0) < 85 and test_means.get(t, 0) < 85 for t in combo)
        
        # Other regulations...
        return True
    except:
        return False

def analyze_combinations(ref_df, test_df, regulation):
    """Main combination analysis function"""
    try:
        # Get common time points
        common_times = sorted(list(set(ref_df.iloc[:,0]).intersection(set(test_df.iloc[:,0]))))
        if not common_times:
            print("No common time points between products")
            return []
        
        # Prepare means
        ref_means = ref_df.set_index(ref_df.columns[0]).iloc[:,1:].mean(axis=1)
        test_means = test_df.set_index(test_df.columns[0]).iloc[:,1:].mean(axis=1)
        
        results = []
        for combo in generate_time_combinations(common_times):
            try:
                ref_sub = ref_df[ref_df.iloc[:,0].isin(combo)].sort_values(ref_df.columns[0])
                test_sub = test_df[test_df.iloc[:,0].isin(combo)].sort_values(test_df.columns[0])
                
                f2 = calculate_combo_f2(ref_sub, test_sub)
                if f2 is None: continue
                
                compliant = is_compliant(combo, regulation, ref_means, test_means)
                
                results.append({
                    'times': combo,
                    'f2': round(f2, 2),
                    'points': len(combo),
                    'compliant': compliant
                })
            except:
                continue
        
        return sorted(results, key=lambda x: (-x['f2'], x['points']))
    
    except Exception as e:
        print(f"Combination analysis failed: {str(e)}")
        traceback.print_exc()
        return []

def display_combination_results(results, regulation):
    """Display results with pagination"""
    if not results:
        print("\nNo valid combinations found")
        return
    
    print(f"\n{'='*80}")
    print(f" Time Point Combinations Analysis ({regulation})")
    print(f"{'='*80}")
    
    page_size = 20
    for page in range(0, len(results), page_size):
        print(f"\nCombinations {page+1}-{min(page+page_size, len(results))}:")
        for res in results[page:page+page_size]:
            status = "✅" if res['compliant'] else "❌"
            print(f"{res['times']} → f2: {res['f2']} {status}")
        
        if page + page_size < len(results):
            input("\nPress Enter for more combinations...")
    
    compliant = [r for r in results if r['compliant']]
    if compliant:
        best = max(compliant, key=lambda x: x['f2'])
        print(f"\nOptimal Compliant Combination: {best['times']} → f2: {best['f2']}")
# ====================== END OF NEW ADDITION ======================

# ====================== INTEGRATION IN FDA BLOCK ======================
# Add this RIGHT BEFORE R_Regulation(file_path) in the FDA block (input1 == 1)

if input1 == 1:
    # ... existing FDA analysis code ...

    # ====== NEW ANALYSIS ======
    try:
        if check_same_time_points(reference_df, test_df):
            print("\nRunning comprehensive combination analysis...")
            regulation_map = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
            
            analysis_results = analyze_combinations(
                reference_df.copy(),
                test_df.copy(),
                regulation_map[input1]
            )
            
            display_combination_results(analysis_results, regulation_map[input1])
        else:
            print("\nSkipping combination analysis: Time points mismatch")
    except Exception as e:
        print(f"\nCombination analysis error: {str(e)}")
    
    # Keep existing R call
    R_Regulation(file_path)
