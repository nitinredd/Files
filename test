def solve_fick_pde(D, R, time_points, num_nodes=100):
    """Numerical solution of Fick's second law in spherical coordinates"""
    dr = R / num_nodes
    r = np.linspace(dr/2, R - dr/2, num_nodes)
    t = np.linspace(0, np.max(time_points), 100)
    
    # Initial condition
    C = np.ones(num_nodes)
    solution = [C.copy()]  # Include initial condition
    
    # PDE parameters
    dt = t[1] - t[0]
    alpha = D * dt / dr**2
    
    # Set up sparse matrix
    main_diag = 1 + 2*alpha*(1 + dr/(2*r))
    lower_diag = -alpha*(1 - dr/(2*r))
    upper_diag = -alpha*(1 + dr/(2*r))
    
    A = diags([lower_diag[1:], main_diag, upper_diag[:-1]],
              [-1, 0, 1], format='csr')
    
    for _ in t[1:]:
        C = spsolve(A, solution[-1])  # Use last solution step
        solution.append(C.copy())
        
    # Calculate fractional release
    r = r.reshape(-1, 1)  # Reshape for broadcasting
    solution_array = np.array(solution).T
    integrand = r**2 * solution_array
    
    # Numerical integration across spatial dimension
    integral = np.trapz(integrand, dx=dr, axis=0)
    Mt = 1 - (3/R**3) * integral
    
    return np.interp(time_points, t, Mt)
