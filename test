import streamlit as st
import cv2
import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import json
import os
import tempfile
import io
from google.auth import default
from langchain_google_vertexai import VertexAI

# Configuration for VertexAI
class Config:
    """
    Contains the configuration of the LLM.
    """
    os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "C:/Users/Downloads/filename-254609-genai.json"  # Path to your API file
    credentials, project_id = default()
    llm = VertexAI(model_name="gemini-pro", temperature=0.3)

config = Config()

# Preprocess image
def preprocess_image(image):
    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    thresh = cv2.adaptiveThreshold(blurred, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                   cv2.THRESH_BINARY, 11, 2)
    return thresh

# Detect tablets in the image
def detect_tablets(image):
    edges = cv2.Canny(image, 50, 150)
    edge_profile = np.sum(edges, axis=0)
    peaks, _ = find_peaks(edge_profile, distance=50)
    return peaks

# Analyze porosity of tablets
def analyze_tablet_porosity(image, n_clusters=3):
    processed_img = preprocess_image(image)
    tablet_boundaries = detect_tablets(processed_img)
    
    results = []
    
    for i in range(len(tablet_boundaries) - 1):
        start, end = tablet_boundaries[i], tablet_boundaries[i+1]
        tablet = processed_img[:, start:end]
        
        tablet_normalized = tablet.astype(float) / 255.0
        pixel_values = tablet_normalized.reshape((-1, 1))
        
        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        kmeans.fit(pixel_values)
        
        centers = kmeans.cluster_centers_.flatten()
        sorted_centers = np.sort(centers)
        
        labels = ['Porous', 'Intermediate', 'Dense']
        cluster_map = {i: label for i, label in enumerate(labels)}
        
        unique, counts = np.unique(kmeans.labels_, return_counts=True)
        percentages = dict(zip([cluster_map[i] for i in unique], counts / len(kmeans.labels_) * 100))
        
        segmented_tablet = kmeans.labels_.reshape(tablet.shape)
        
        results.append({
            'tablet_index': i,
            'percentages': percentages,
            'segmented_image': segmented_tablet.tolist()
        })
    
    return results

# Analyze data with Gemini LLM (this is just a placeholder, you can customize it)
def analyze_tablet_data_with_gemini(json_data):
    prompt = f"""
    Analyze the following quantitative data for tablet porosity:
    {json.dumps(json_data, indent=2)}

    Provide a scientific analysis of porosity, density, variation between tablets, and recommendations for further analysis.
    """
    response = config.llm.predict(prompt)
    return response

# Main function
def main():
    st.title("Tablet Porosity Analysis App")

    # Step 1: Upload image and perform CV analysis
    uploaded_file = st.file_uploader("Choose an image file", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        # Read the image
        file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
        image = cv2.imdecode(file_bytes, cv2.IMREAD_GRAYSCALE)

        st.image(image, caption="Uploaded Image", use_column_width=True)

        if st.button("Analyze Image"):
            # Perform CV analysis
            with st.spinner("Performing computer vision analysis..."):
                cv_results = analyze_tablet_porosity(image)
            
            st.success("Computer vision analysis complete!")

            # Visualize results
            fig, axes = plt.subplots(1, len(cv_results) + 1, figsize=(5 * (len(cv_results) + 1), 5))
            axes[0].imshow(image, cmap='gray')
            axes[0].set_title('Original Image')
            axes[0].axis('off')

            for i, result in enumerate(cv_results):
                segmented_image = np.array(result['segmented_image'])
                axes[i+1].imshow(segmented_image, cmap='viridis')
                axes[i+1].set_title(f'Tablet {i+1}')
                axes[i+1].axis('off')
                
                text = '\n'.join([f"{k}: {v:.2f}%" for k, v in result['percentages'].items()])
                axes[i+1].text(0.05, 0.95, text, transform=axes[i+1].transAxes, fontsize=8, 
                               verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

            st.pyplot(fig)

            # Download the CV results as JSON
            results_json = json.dumps({
                "cv_results": cv_results
            })
            st.download_button(
                label="Download CV Analysis Results",
                data=results_json,
                file_name="tablet_analysis_results.json",
                mime="application/json"
            )

    # Step 2: Upload the JSON file for Gemini analysis
    st.header("Upload JSON for Gemini Processing")
    uploaded_json = st.file_uploader("Upload the JSON file processed from CV", type=["json"])

    if uploaded_json is not None:
        # Load the JSON file
        json_data = json.load(uploaded_json)
        
        st.write("Uploaded JSON data:", json_data)

        if st.button("Process with Gemini"):
            with st.spinner("Processing with Gemini..."):
                gemini_analysis = analyze_tablet_data_with_gemini(json_data)
            st.subheader("Gemini Analysis")
            st.write(gemini_analysis)

if __name__ == "__main__":
    main()
