import streamlit as st
import PyPDF2
import io
from transformers import GPT2TokenizerFast
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chat_models import ChatOpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
import pdfplumber
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.platypus import Table, TableStyle
from reportlab.lib import colors

# Initialize OpenAI API
import os
from langchain.llms import AzureOpenAI

os.environ["OPENAI_API_KEY"] = "your-api-key-here"
os.environ["OPENAI_API_TYPE"] = "azure"
os.environ["OPENAI_API_BASE"] = "your-api-base-url-here"
os.environ["OPENAI_API_VERSION"] = "2023-05-15"  # Update this to the latest API version

MODEL_NAME = "gpt-4"  # or your specific Azure OpenAI model deployment name

def extract_content_from_pdf(pdf_file):
    content = []
    with pdfplumber.open(pdf_file) as pdf:
        for page in pdf.pages:
            tables = page.extract_tables()
            if tables:
                for table in tables:
                    content.append(("table", table))
            text = page.extract_text()
            if text:
                content.append(("text", text))
    return content

def chunk_text(text, chunk_size=1000, chunk_overlap=200):
    tokenizer = GPT2TokenizerFast.from_pretrained("gpt2")
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=chunk_size,
        chunk_overlap=chunk_overlap,
        length_function=lambda x: len(tokenizer.encode(x))
    )
    chunks = text_splitter.split_text(text)
    return chunks

def translate_text(text, source_lang):
    llm = AzureOpenAI(
        deployment_name=MODEL_NAME,
        temperature=0,
        max_tokens=1024,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0
    )
    prompt = PromptTemplate(
        input_variables=["text", "source_lang"],
        template="Translate the following {source_lang} text to English, preserving the original meaning and style:\n\n{text}"
    )
    chain = LLMChain(llm=llm, prompt=prompt)
    result = chain.run(text=text, source_lang=source_lang)
    return result

def translate_table(table, source_lang):
    translated_table = []
    for row in table:
        translated_row = []
        for cell in row:
            if cell:
                translated_cell = translate_text(cell, source_lang)
                translated_row.append(translated_cell)
            else:
                translated_row.append("")
        translated_table.append(translated_row)
    return translated_table

def create_pdf(translated_content):
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    y = height - 50

    for content_type, content in translated_content:
        if content_type == "text":
            for line in content.split('\n'):
                if y < 50:
                    c.showPage()
                    y = height - 50
                c.drawString(50, y, line)
                y -= 15
        elif content_type == "table":
            table = Table(content)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 12),
                ('TOPPADDING', (0, 1), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            if y - table.wrap(width-100, height)[1] < 50:
                c.showPage()
                y = height - 50
            table.wrapOn(c, width-100, height)
            table.drawOn(c, 50, y - table.wrap(width-100, height)[1])
            y -= table.wrap(width-100, height)[1] + 20

    c.save()
    buffer.seek(0)
    return buffer

st.title("PDF Translation App")

uploaded_file = st.file_uploader("Choose a PDF file", type="pdf")
source_lang = st.selectbox("Select source language", ["Chinese", "Japanese"])

if uploaded_file is not None:
    content = extract_content_from_pdf(uploaded_file)
    
    if st.button("Translate"):
        translated_content = []
        progress_bar = st.progress(0)
        total_items = len(content)
        
        for i, (content_type, item) in enumerate(content):
            if content_type == "text":
                chunks = chunk_text(item)
                translated_chunks = []
                for chunk in chunks:
                    translated_chunk = translate_text(chunk, source_lang)
                    translated_chunks.append(translated_chunk)
                translated_content.append(("text", " ".join(translated_chunks)))
            elif content_type == "table":
                translated_table = translate_table(item, source_lang)
                translated_content.append(("table", translated_table))
            
            progress_bar.progress((i + 1) / total_items)
        
        st.subheader("Translated Content")
        for content_type, item in translated_content:
            if content_type == "text":
                st.write(item)
            elif content_type == "table":
                st.table(item)
        
        pdf_buffer = create_pdf(translated_content)
        st.download_button(
            label="Download translated PDF",
            data=pdf_buffer,
            file_name="translated_document.pdf",
            mime="application/pdf"
        )
