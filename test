# ====================== COMPLETE ANALYSIS FUNCTIONS ======================
import itertools
import numpy as np
import pandas as pd

def generate_all_combinations_with_zero(times):
    """Generate all 3+ point combinations including zero"""
    try:
        # Convert to integers and maintain original order
        times = sorted([int(t) for t in times], key=lambda x: x if x != 0 else -1)
        
        # Generate all combinations of 3 or more points
        all_combos = []
        for r in range(3, len(times)+1):
            all_combos.extend(itertools.combinations(times, r))
            
        # Convert to lists and sort individual combinations
        return [sorted(list(combo)) for combo in all_combos]
    except Exception as e:
        print(f"Combination generation error: {str(e)}")
        return []

def enhanced_compliance_check(combo, regulation, ref_means, test_means):
    """Check compliance with detailed zero-handling and regulation-specific rules"""
    reasons = []
    compliant = True
    combo = sorted(combo)  # Ensure sorted time points
    
    # FDA: Truncate at first 85% point (including zero)
    if regulation == "FDA":
        trunc_points = []
        for t in combo:
            if ref_means.get(t, 0) >= 85 or test_means.get(t, 0) >= 85:
                trunc_points.append(t)
        
        if trunc_points:
            trunc_at = min(trunc_points)
            post_trunc = [t for t in combo if t > trunc_at]
            if post_trunc:
                reasons.append(f"Contains post-85% points after {trunc_at}: {post_trunc}")
                compliant = False
        # Special case: Allow zero even if 0% dissolution
        if 0 in combo:
            reasons.append("Zero time point allowed regardless of dissolution")
                
    # EMA: All points <85% (including zero)
    elif regulation == "EMA":
        over_ref = [t for t in combo if ref_means.get(t, 0) >= 85]
        over_test = [t for t in combo if test_means.get(t, 0) >= 85]
        
        if over_ref:
            reasons.append(f"Reference exceeds 85% at: {over_ref}")
            compliant = False
        if over_test:
            reasons.append(f"Test exceeds 85% at: {over_test}")
            compliant = False
    
    # China: Reference product only <85%
    elif regulation == "China":
        over_ref = [t for t in combo if ref_means.get(t, 0) >= 85]
        if over_ref:
            reasons.append(f"Reference exceeds 85% at: {over_ref}")
            compliant = False
    
    # ASEAN: First 3 points <85%
    elif regulation == "ASEAN":
        check_points = combo[:3] if len(combo) >=3 else combo
        over_ref = [t for t in check_points if ref_means.get(t, 0) >= 85]
        over_test = [t for t in check_points if test_means.get(t, 0) >= 85]
        
        if over_ref:
            reasons.append(f"Reference exceeds 85% in first 3 points: {over_ref}")
            compliant = False
        if over_test:
            reasons.append(f"Test exceeds 85% in first 3 points: {over_test}")
            compliant = False
    
    # ANVISA: Requires zero + 2+ other points
    elif regulation == "ANVISA":
        if 0 not in combo:
            reasons.append("Missing required zero time point")
            compliant = False
        if len(combo) < 3:
            reasons.append("Needs at least 3 points including zero")
            compliant = False
    
    reason = " | ".join(reasons) if reasons else "Compliant with regulation"
    return (compliant, reason)

def full_combination_analysis(ref_df, test_df, regulation):
    """Complete combination analysis with zero handling"""
    try:
        # Get time points including zero
        times = ref_df.iloc[:,0].tolist()
        
        # Prepare dissolution means
        ref_means = ref_df.set_index(ref_df.columns[0]).iloc[:,1:].mean(axis=1)
        test_means = test_df.set_index(test_df.columns[0]).iloc[:,1:].mean(axis=1)
        
        # Generate combinations
        combos = generate_all_combinations_with_zero(times)
        print(f"\nAnalyzing {len(combos)} combinations for {regulation}...")
        
        results = []
        for combo in combos:
            try:
                # Subset data
                ref_sub = ref_df[ref_df.iloc[:,0].isin(combo)].sort_values(ref_df.columns[0])
                test_sub = test_df[test_df.iloc[:,0].isin(combo)].sort_values(test_df.columns[0])
                
                # Calculate f2
                p = len(combo)
                diff = test_sub.iloc[:,1:].mean(axis=1) - ref_sub.iloc[:,1:].mean(axis=1)
                sum_sq = (diff**2).sum()
                f2 = 100 - 25 * np.log10(1 + (sum_sq/p)) if p > 0 else 0
                
                # Check compliance
                compliant, reason = enhanced_compliance_check(combo, regulation, ref_means, test_means)
                
                results.append({
                    'times': combo,
                    'f2': round(f2, 2),
                    'points': len(combo),
                    'compliant': compliant,
                    'reason': reason
                })
            except Exception as e:
                print(f"Error processing {combo}: {str(e)}")
                continue
        
        return sorted(results, key=lambda x: (-x['f2'], x['points']))
    
    except Exception as e:
        print(f"Analysis failed: {str(e)}")
        return []

def display_full_results(results, regulation):
    """Display results with pagination and compliance reasons"""
    if not results:
        print("\nNo valid combinations found")
        return
    
    print(f"\n{'='*100}")
    print(f" Complete Combination Analysis ({regulation})")
    print(f"{'='*100}")
    print(f"{'Time Points':<25} | {'Points':<6} | {'f2':<8} | {'Status':<8} | Compliance Details")
    print("-"*100)
    
    page_size = 20
    for page in range(0, len(results), page_size):
        for res in results[page:page+page_size]:
            status = "✅" if res['compliant'] else "❌"
            print(f"{str(res['times']):<25} | {res['points']:^6} | {res['f2']:^8.2f} | {status:^8} | {res['reason']}")
        
        if page + page_size < len(results):
            input("\nPress Enter for more combinations...")
    
    compliant_results = [r for r in results if r['compliant']]
    if compliant_results:
        best = max(compliant_results, key=lambda x: x['f2'])
        print(f"\nOptimal Compliant Combination:")
        print(f"Time Points: {best['times']}")
        print(f"f2 Score: {best['f2']:.2f}")
        print(f"Compliance Reason: {best['reason']}")
    print("="*100 + "\n")
# ====================== END ANALYSIS FUNCTIONS ======================
