# Fixed RT parameter mapping in main.py WebSocketNotifier.on_created method

class WebSocketNotifier(FileSystemEventHandler):
    def __init__(self, websocket_clients, loop, id):
        self.websocket_clients = websocket_clients
        self.loop = loop
        self.id = id

    def on_created(self, event):
        if not event.is_directory:
            full_path_uploaded_csv = event.src_path
            object_id = ObjectId(self.id)
            experiment = collection.find_one({"_id": object_id})
            
            # Get Objectives and RT parameters from the database
            optimization = experiment.get("optimization_target", {})
            raw_objectives = optimization.get("objectives", {})
            
            # FIXED: Extract RT parameters properly from UI input
            # UI provides RTMin and RTMax as arrays where each pair defines a specific RT range:
            # - RTMin[0], RTMax[0] = Yield RT range 
            # - RTMin[1], RTMax[1] = First impurity RT range
            # - RTMin[2], RTMax[2] = Second impurity RT range, etc.
            objectives_rtmin = raw_objectives.get('RTMin', [])
            objectives_rtmax = raw_objectives.get('RTMax', [])
            
            print(f"Raw RT Min from UI: {objectives_rtmin}")
            print(f"Raw RT Max from UI: {objectives_rtmax}")
            
            # Parse RT ranges correctly
            if len(objectives_rtmin) == 0 or len(objectives_rtmax) == 0:
                raise ValueError("RT ranges not properly configured")
                
            # CORRECTED: RT pairs should be interpreted as compound-specific ranges
            # Each RTMin[i] pairs with RTMax[i] to define a specific compound's RT range
            
            if len(objectives_rtmin) != len(objectives_rtmax):
                raise ValueError(f"RTMin and RTMax arrays must have same length: {len(objectives_rtmin)} vs {len(objectives_rtmax)}")
            
            # Method 1: Assume first RT pair is yield, rest are impurities
            YminRT = float(objectives_rtmin[0])  
            YmaxRT = float(objectives_rtmax[0])  
            
            # Impurity RT ranges from remaining pairs
            IminRT_list = []
            ImaxRT_list = []
            
            for i in range(1, len(objectives_rtmin)):
                if str(objectives_rtmin[i]).strip() != '' and str(objectives_rtmax[i]).strip() != '':
                    IminRT_list.append(float(objectives_rtmin[i]))
                    ImaxRT_list.append(float(objectives_rtmax[i]))
            
            # ALTERNATIVE: If your UI means consecutive RT values define ranges
            # Uncomment this section if RT values are meant to be consecutive boundaries:
            # YminRT = float(objectives_rtmin[0])
            # YmaxRT = float(objectives_rtmin[1]) if len(objectives_rtmin) > 1 else float(objectives_rtmax[0])
            # IminRT_list = [float(objectives_rtmax[0])] if len(objectives_rtmax) > 1 else []
            # ImaxRT_list = [float(objectives_rtmax[1])] if len(objectives_rtmax) > 1 else []
            
            # Internal Standard RT range from separate UI fields
            minRTISO = float(optimization.get("rtMinIso", 0))
            maxRTISO = float(optimization.get("rtMaxIso", 0))
            
            print(f"CORRECTED RT parameters:")
            print(f"  Yield RT: [{YminRT}-{YmaxRT}]")
            print(f"  Impurity RT ranges: {list(zip(IminRT_list, ImaxRT_list))}")
            print(f"  Internal Standard RT: [{minRTISO}-{maxRTISO}]")
            
            # Validate RT parameters
            if YminRT >= YmaxRT:
                raise ValueError(f"Invalid yield RT range: {YminRT} >= {YmaxRT}")
            if minRTISO >= maxRTISO:
                raise ValueError(f"Invalid internal standard RT range: {minRTISO} >= {maxRTISO}")
            if len(IminRT_list) != len(ImaxRT_list):
                raise ValueError(f"Impurity RT min/max lists length mismatch: {len(IminRT_list)} vs {len(ImaxRT_list)}")
            
            # Check for range overlaps (warning only)
            all_ranges = [("Yield", YminRT, YmaxRT), ("ISO", minRTISO, maxRTISO)]
            for i, (imin, imax) in enumerate(zip(IminRT_list, ImaxRT_list)):
                all_ranges.append((f"Impurity{i+1}", imin, imax))
            
            print("Checking for range overlaps:")
            for i, (name1, min1, max1) in enumerate(all_ranges):
                for j, (name2, min2, max2) in enumerate(all_ranges[i+1:], i+1):
                    if not (max1 <= min2 or max2 <= min1):  # Ranges overlap
                        print(f"WARNING: {name1} [{min1}-{max1}] overlaps with {name2} [{min2}-{max2}]")
            
            # Rest of the processing remains the same...
            # [Continue with existing experiment processing logic]

# Fixed HPLC data processing function in utils.py

def process_uploaded_csv_file(full_path_uploaded_csv,
                              df,
                              minRTISO,
                              maxRTISO,
                              YminRT,
                              YmaxRT,
                              IminRT_list,
                              ImaxRT_list,
                              transformed_objectives,
                              lhs):
    """
    Process uploaded HPLC CSV file with proper column selection and RT parameter handling.
    """
    print(f"\n=== Processing HPLC File: {full_path_uploaded_csv} ===")
    print(f"Available columns: {list(df.columns)}")
    
    # FIXED: Proper column selection for Area data
    # Priority: Peak Area > Area > case-insensitive matching
    area_col = None
    rt_col = None
    
    # Find Area column
    if 'Peak Area' in df.columns:
        area_col = 'Peak Area'
    elif 'Area' in df.columns:
        area_col = 'Area'
    else:
        # Case-insensitive search
        cols_lower = {c.lower(): c for c in df.columns}
        if 'peak area' in cols_lower:
            area_col = cols_lower['peak area']
        elif 'area' in cols_lower:
            area_col = cols_lower['area']
        else:
            raise ValueError(f"No Area column found. Available: {list(df.columns)}")
    
    # Find RT column
    if 'RT' in df.columns:
        rt_col = 'RT'
    else:
        cols_lower = {c.lower(): c for c in df.columns}
        if 'rt' in cols_lower:
            rt_col = cols_lower['rt']
        else:
            raise ValueError(f"No RT column found. Available: {list(df.columns)}")
    
    print(f"Using columns: Area='{area_col}', RT='{rt_col}'")
    
    # Extract data
    data_np = df[[area_col, rt_col]].to_numpy()
    print(f"Extracted {data_np.shape[0]} peaks from HPLC data")
    
    # Show data summary
    if len(data_np) > 0:
        rt_values = data_np[:, 1]
        area_values = data_np[:, 0]
        print(f"RT range in data: {rt_values.min():.3f} - {rt_values.max():.3f}")
        print(f"Area range in data: {area_values.min():.3f} - {area_values.max():.3f}")
        
        # Show which peaks fall in each range
        yield_peaks = sum(1 for rt in rt_values if YminRT <= rt <= YmaxRT)
        iso_peaks = sum(1 for rt in rt_values if minRTISO <= rt <= maxRTISO)
        print(f"Peaks in yield range [{YminRT}-{YmaxRT}]: {yield_peaks}")
        print(f"Peaks in ISO range [{minRTISO}-{maxRTISO}]: {iso_peaks}")
        
        for i, (imin, imax) in enumerate(zip(IminRT_list, ImaxRT_list)):
            imp_peaks = sum(1 for rt in rt_values if imin <= rt <= imax)
            print(f"Peaks in impurity {i+1} range [{imin}-{imax}]: {imp_peaks}")
    
    # Build HPLC parameters dictionary
    hplc_params = {
        'YminRT': float(YminRT),
        'YmaxRT': float(YmaxRT),
        'minRTISO': float(minRTISO),
        'maxRTISO': float(maxRTISO),
        'IminRT_list': [float(x) for x in IminRT_list],
        'ImaxRT_list': [float(x) for x in ImaxRT_list],
    }
    
    print(f"Final HPLC Parameters: {hplc_params}")
    
    # Calculate response using the corrected function
    resp = response_HPLC_csv(
        data_np,
        hplc_params['YminRT'],
        hplc_params['YmaxRT'], 
        hplc_params['IminRT_list'],
        hplc_params['ImaxRT_list'],
        hplc_params['minRTISO'],
        hplc_params['maxRTISO'],
        len(transformed_objectives)
    )
    
    print(f"Calculated response: {resp}")
    return resp
