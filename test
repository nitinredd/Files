def interpolate_dissolution_curve(df, new_times, method='gpr'):
    """
    Predict dissolution values at new time points, clamping to observed time range.
    """
    df_sorted = df.sort_values(by=df.columns[0])
    known_times = df_sorted.iloc[:, 0].values.astype(float)
    known_values = df_sorted.iloc[:, 1].values
    
    # Clamp new_times to the observed range [min(known_times), max(known_times)]
    new_times_clamped = np.clip(new_times, known_times.min(), known_times.max())
    
    if method == 'gpr':
        # Define kernel: constant * RBF + white noise.
        kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=10.0, length_scale_bounds=(1e-2, 1e2)) + \
                 WhiteKernel(noise_level=1, noise_level_bounds=(1e-5, 1e1))
        gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=5)
        # CORRECTED: Use known_times and known_values instead of undefined X/y
        gp.fit(known_times.reshape(-1, 1), known_values)
        y_pred = gp.predict(new_times_clamped.reshape(-1, 1))
        return y_pred
    else:
        if len(known_times) < 2:
            return np.full(len(new_times_clamped), known_values[0]) if len(known_values) > 0 else np.zeros(len(new_times_clamped))
        if method == 'cubic' and len(known_times) >= 4:
            f = interp1d(known_times, known_values, kind='cubic', fill_value='extrapolate')
        else:
            f = interp1d(known_times, known_values, kind='linear', fill_value=(known_values[0], known_values[-1]))
        return f(new_times_clamped)
