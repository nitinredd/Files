import numpy as np

def calculate_f2_fda(reference_df, test_df):
    """
    FDA ≥ 85% rule:
      - Keep time = 0
      - Find the first timepoint (after t=0) where both reference AND test mean > 85%
      - Trim both DataFrames to include rows [0 .. that timepoint]
      - Compute conventional f2 and expected f2 on the trimmed means
    Returns:
      f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
    """
    # 1) times & means
    times      = reference_df.iloc[:, 0].astype(float).values
    ref_mean   = reference_df.iloc[:, 1:].mean(axis=1).values
    test_mean  = test_df.iloc[:, 1:].mean(axis=1).values

    # 2) find first simultaneous >85% (after t=0)
    cutoff = next(
        (i for i in range(1, len(times))
         if ref_mean[i] > 85 and test_mean[i] > 85),
        None
    )
    if cutoff is None:
        raise ValueError("No timepoint found where both profiles exceed 85% simultaneously.")

    # 3) trim to [0..cutoff]
    trimmed_ref_df  = reference_df.iloc[:cutoff+1].copy()
    trimmed_test_df = test_df.iloc[:cutoff+1].copy()

    # force 0% at t=0
    if float(trimmed_ref_df.iloc[0, 0]) == 0.0:
        trimmed_ref_df.iloc[0, 1:]  = 0.0
        trimmed_test_df.iloc[0, 1:] = 0.0

    # 4a) conventional f2
    diff    = (trimmed_test_df.iloc[:,1:].mean(axis=1).values
             - trimmed_ref_df.iloc[:,1:].mean(axis=1).values)
    p       = len(diff)
    sum_sq  = np.sum(diff**2)
    f2_conv = 100 - 25 * np.log10(1 + sum_sq / p)

    # 4b) expected f2 (variance adjustment)
    var_ref   = trimmed_ref_df.iloc[:,1:].var(axis=1, ddof=1).values
    var_test  = trimmed_test_df.iloc[:,1:].var(axis=1, ddof=1).values
    avg_var   = np.mean(var_ref + var_test)
    exp_f2    = 100 - 25 * np.log10(1 + (sum_sq + p * avg_var) / p)

    return f2_conv, exp_f2, trimmed_ref_df, trimmed_test_df
############################################
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

elif input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Check criteria & CV
    both_85   = check_both_85(reference_df, test_df)
    either_85 = check_either_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:  ", both_85)
    print("Either ≥ 85% criterion met:", either_85)

    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # 2) Verify time alignment
    if not check_same_time_points(reference_df, test_df):
        print("Error: Time points between test and reference do not match.")
        print("Calculations cannot be performed.")
    else:
        try:
            # 3) Compute f2s & trimmed data
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)

            # 4) Show trimmed times & means
            times      = ref_trim.iloc[:, 0].astype(float).tolist()
            ref_means  = ref_trim.iloc[:, 1:].mean(axis=1).round(2).tolist()
            test_means = test_trim.iloc[:, 1:].mean(axis=1).round(2).tolist()

            print("Trimmed times:       ", times)
            print("Reference means (%): ", ref_means)
            print("Test means      (%): ", test_means, "\n")

            # 5) Print f2 results
            print(f"Conventional f2: {f2_conv:.2f}")
            print(f"Expected    f2: {f2_exp:.2f}")
            if not cv_check:
                print("\nWarning: CV requirements not met; interpret with caution.")

            # --- Graph 1: Simple dissolution curves ---
            plt.figure(figsize=(12, 6))
            plt.plot(times, ref_means,  marker='o', linestyle='-',  label='Reference')
            plt.plot(times, test_means, marker='o', linestyle='--', label='Test')
            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0, 101, 5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('fda_dissolution_curves.png', dpi=300)
            plt.show()
            plt.close()

            # --- Graph 2: Curves with min/max intervals ---
            ref_min = ref_trim.iloc[:,1:].min(axis=1)
            ref_max = ref_trim.iloc[:,1:].max(axis=1)
            tst_min = test_trim.iloc[:,1:].min(axis=1)
            tst_max = test_trim.iloc[:,1:].max(axis=1)

            plt.figure(figsize=(12, 6))
            plt.errorbar(
                times, ref_means,
                yerr=[ [rm - mi for rm, mi in zip(ref_means, ref_min)],
                      [ma - rm for ma, rm in zip(ref_max, ref_means)] ],
                fmt='o-', label='Reference Mean'
            )
            plt.errorbar(
                times, test_means,
                yerr=[ [tm - mi for tm, mi in zip(test_means, tst_min)],
                      [ma - tm for ma, tm in zip(tst_max, test_means)] ],
                fmt='s--', label='Test Mean'
            )
            # caps
            for t, mn, mx in zip(times, ref_min, ref_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)
            for t, mn, mx in zip(times, tst_min, tst_max):
                plt.hlines([mn, mx], t-0.2, t+0.2, linestyles='--', alpha=0.5)

            plt.xlabel('Time')
            plt.ylabel('Dissolution (%)')
            plt.title('Dissolution Curves with Intervals')
            plt.grid(True)
            ax = plt.gca()
            ax.yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
            ax.set_yticks(range(0, 101, 5))
            plt.legend(loc='lower right')
            plt.tight_layout()
            plt.savefig('fda_dissolution_curves_with_intervals.png', dpi=300)
            plt.show()
            plt.close()

        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA‑rule f2 calculation.")
