import numpy as np
import math
import pandas as pd

def calculate_mean_profile(df):
    """Calculate mean dissolution profile with precision control"""
    times = df.iloc[:, 0].astype(float).values.round(2)
    values = df.iloc[:, 1:].astype(float)
    means = values.mean(axis=1).round(2)
    return pd.DataFrame({'Time': times, 'Mean': means})

def create_monotonic_profile(times, means, step=0.25, window_max=12):
    """Create validated monotonic profile with edge handling"""
    grid = np.round(np.arange(0, window_max + step, step), 2)
    interp = np.interp(grid, times, means, left=0.0, right=means[-1])
    return np.maximum.accumulate(interp), grid

def select_optimized_points(ref, test, grid):
    """Select points meeting criteria while maximizing F2 potential"""
    brackets = [(0, 30), (30, 60), (60, 80)]
    selected = [0]  # Always include 0h
    last_ref = 0.0
    
    for low, high in brackets:
        candidates = []
        
        # Find all points in current bracket
        for i in range(len(grid)):
            current_ref = ref[i]
            if low <= current_ref < high:
                if current_ref - last_ref >= 7:
                    candidates.append(i)
        
        # Select up to 2 best F2 candidates
        if candidates:
            # Sort by test-ref similarity (ascending differences)
            candidates.sort(key=lambda x: abs(test[x] - ref[x]))
            
            # Take best 1-2 candidates maintaining progression
            for cand in candidates[:2]:
                if ref[cand] > last_ref:
                    selected.append(cand)
                    last_ref = ref[cand]
        
        # Ensure at least one point per bracket
        if not any(ref[i] >= low for i in selected):
            for i in range(len(grid)):
                if low <= ref[i] < high:
                    selected.append(i)
                    last_ref = ref[i]
                    break
    
    return sorted(list(set(selected)))

def find_85_point(ref, test, grid, regulation):
    """Find regulation-specific 85% dissolution point"""
    for i in range(len(grid)):
        ref_ok = ref[i] >= 85
        test_ok = test[i] >= 85
        
        if regulation in ("FDA", "ANVISA") and ref_ok and test_ok:
            return i
        elif regulation not in ("FDA", "ANVISA") and (ref_ok or test_ok):
            return i
    return None

def predictive_optimal_combinations_monotonic(reference_df, test_df,
                                            regulation, window_max=12,
                                            step_hours=0.25):
    # Calculate mean profiles
    ref_mean = calculate_mean_profile(reference_df)
    test_mean = calculate_mean_profile(test_df)

    # Create monotonic profiles
    ref_prof, grid = create_monotonic_profile(
        ref_mean['Time'].values, 
        ref_mean['Mean'].values,
        step_hours,
        window_max
    )
    test_prof, _ = create_monotonic_profile(
        test_mean['Time'].values,
        test_mean['Mean'].values,
        step_hours,
        window_max
    )

    # Select optimized points
    selected = select_optimized_points(ref_prof, test_prof, grid)
    
    # Add 85% point
    eighty_five = find_85_point(ref_prof, test_prof, grid, regulation)
    if eighty_five is not None and eighty_five not in selected:
        selected.append(eighty_five)
    
    # Finalize selection
    selected = sorted(np.unique(selected))
    
    # Convert to native Python types
    times = [float(grid[i]) for i in selected]
    ref_vals = [float(ref_prof[i]) for i in selected]
    test_vals = [float(test_prof[i]) for i in selected]

    # Clean time formatting
    clean_times = []
    for t in times:
        if t.is_integer():
            clean_times.append(int(t))
        else:
            clean_times.append(round(t, 2))
    
    # Calculate F2 score
    if len(ref_vals) > 1:
        diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
        rsd = np.sqrt(np.mean(diffs**2))
        f2 = 50 * math.log10(100/(1 + rsd)) if rsd > 0 else 100.0
    else:
        f2 = 100.0
    
    return [{
        'sequence': clean_times,
        'f2': round(f2, 2),
        'compliant': f2 >= 50,
        'reasons': [],
        'ref_vals': [round(v, 2) for v in ref_vals],
        'test_vals': [round(v, 2) for v in test_vals]
    }], None
