// helper in Message.jsx (or a shared util)
async function downloadFileViaFetch(url, filename) {
  // Give user feedback / disable button externally if needed
  const resp = await fetch(url, { method: 'GET', credentials: 'same-origin' })
  if (!resp.ok) {
    throw new Error(`Download failed: ${resp.status} ${resp.statusText}`)
  }

  const contentType = resp.headers.get('content-type') || ''
  // Optionally validate content type:
  if (!contentType.includes('spreadsheet') && !contentType.includes('excel') && !contentType.includes('application/octet-stream')) {
    // But don't block: sometimes servers use octet-stream
    console.warn('Unexpected content-type:', contentType)
  }

  const blob = await resp.blob()

  // Create object URL and download
  const a = document.createElement('a')
  const objectUrl = URL.createObjectURL(blob)
  a.href = objectUrl
  if (filename) a.download = filename
  a.target = '_blank'
  document.body.appendChild(a)
  a.click()
  a.remove()
  // revoke objectURL after a short time
  setTimeout(() => URL.revokeObjectURL(objectUrl), 1000 * 10)
}
#####################
async function onConfirmDownload() {
  if (!pendingDownload) return
  const { url, name, size } = pendingDownload

  // send analytics (non-blocking)
  sendAnalytics('download_formula', { filename: name || null, size_bytes: size ?? null, timestamp: new Date().toISOString() }).catch(()=>{})

  try {
    await downloadFileViaFetch(url, name)
  } catch (e) {
    // fallback to opening in new tab
    window.open(url, '_blank', 'noopener')
  } finally {
    setConfirmOpen(false)
    setPendingDownload(null)
  }
}
