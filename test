// src/api.js
import axios from "axios";

/**
 * API helper using relative URLs (no REACT_APP_API_BASE).
 * If your frontend is served on a different host/port than the backend in dev,
 * configure a proxy (recommended) or replace the relative URLs with the full backend URL.
 */

// axios instance (no baseURL so it hits same origin by default)
const api = axios.create({
  // You can set a timeout or headers here if you want
  timeout: 30_000,
});

// Fetch reactions
export const fetchReactions = async () => {
  const res = await api.get("/reactions");
  return res.data;
};

// Fetch products for a reaction type
export const fetchProducts = async (reactionType) => {
  const res = await api.get("/products", { params: { reaction_type: reactionType }});
  return res.data;
};

// Fetch product meta by id
export const fetchProductMeta = async (productId) => {
  const res = await api.get(`/product/${encodeURIComponent(productId)}/meta`);
  return res.data;
};

// Fetch product details (if productId undefined, backend will attempt detection)
export const fetchProductDetails = async (productId, question = "Extract API Name, Reaction Chemistry, Yield, Procedure, and Tabular Data", session_id = null) => {
  const payload = { question };
  if (productId) payload.product_id = productId;
  if (session_id) payload.session_id = session_id;
  const res = await api.post("/product/details", payload);
  return res.data;
};

// Get scheme image URL (we return a direct path — frontend can use it as src)
export const fetchSchemeImageUrl = async (productId) => {
  try {
    // We simply return the endpoint; the <img> src can be set to this path.
    // If you want to proactively check existence, you can call the endpoint.
    return `/product/${encodeURIComponent(productId)}/scheme-image`;
  } catch (e) {
    return null;
  }
};

// Query with citations (POST /query or backend endpoint you have)
export const queryWithCitations = async (productIds = [], question = "", session_id = null) => {
  const payload = { product_ids: productIds, question };
  if (session_id) payload.session_id = session_id;
  const res = await api.post("/query", payload);
  return res.data;
};

// Search products (autocomplete)
export const searchProducts = async (q, limit = 10) => {
  const res = await api.get("/products/search", { params: { q, limit }});
  return res.data;
};

// Prompt gallery fetch
export const fetchPrompts = async () => {
  const res = await api.get("/prompt-gallery");
  const data = res.data || {};
  // backend returns { prompts: [...] } or an array; normalize to array of {id,title,text}
  const raw = data.prompts || (Array.isArray(data) ? data : []);
  return raw.map((p, idx) => {
    // backend uses keys "title" and "prompt" by convention; be flexible
    return {
      id: p.id || `prompt-${idx}`,
      title: p.title || p.name || `Prompt ${idx + 1}`,
      text: p.prompt || p.text || p.query || ""
    };
  });
};

// Upload file helper: posts file + reaction_type (no spaces) and optional filename
export const uploadFile = async (file, reaction_type = "Miscellaneous", filename = null) => {
  if (!file) throw new Error("file required");
  const fd = new FormData();
  fd.append("file", file);
  // backend expects `reaction_type` (not `reaction type`)
  fd.append("reaction_type", reaction_type || "Miscellaneous");
  if (filename) fd.append("filename", filename);

  // let axios/browser set the Content-Type (boundary) automatically
  const res = await api.post("/upload", fd, {
    headers: {
      Accept: "application/json"
    },
    maxBodyLength: Infinity,
    maxContentLength: Infinity,
  });
  return res.data;
};

export default api;
#############################
// src/App.jsx
import React, { useEffect, useState, useRef } from "react";
import { motion } from "framer-motion";

import ChatWindow from "./components/ChatWindow";
import ProductTabs from "./components/ProductTabs";
import ProductDetailModal from "./components/ProductDetailModal";
import SidebarHistory from "./components/SidebarHistory";
import ReactionTiles from "./components/ReactionTiles";
import PromptGallery from "./components/PromptGallery";

import {
  fetchReactions,
  fetchProducts,
  fetchProductMeta,
  fetchProductDetails,
  fetchSchemeImageUrl,
  fetchPrompts,
  queryWithCitations,
  uploadFile,
} from "./api";

import Navbar from "./Navbar/Navbar";
import Footer from "./Footer/Footer";

import chem_logo from "../assets/Chemhub_Logo_Colored.png";

export default function App() {
  const [reactions, setReactions] = useState([]);
  const [prompts, setPrompts] = useState([]);

  const [products, setProducts] = useState([]);
  const [selectedReaction, setSelectedReaction] = useState(null);

  const [selectedProduct, setSelectedProduct] = useState(null); // meta
  const [productDetails, setProductDetails] = useState(null);
  const [productListVisible, setProductListVisible] = useState(false);

  const [detailModalOpen, setDetailModalOpen] = useState(false);

  const [messages, setMessages] = useState([]); // chat messages
  const [history, setHistory] = useState([]); // conversation history list

  // Loading state flags
  const [loadingDetails, setLoadingDetails] = useState(false);
  const [queryLoading, setQueryLoading] = useState(false);

  // Selected citations (right-click / multi-select)
  const [selectedCitedDocs, setSelectedCitedDocs] = useState([]);

  // For scheme preview in chat
  const [selectedSchemeUrl, setSelectedSchemeUrl] = useState(null);

  // Prompt gallery UI
  const [promptGalleryOpen, setPromptGalleryOpen] = useState(false);

  // Expanded full-page view (when user clicks a reaction type)
  const [expandedViewOpen, setExpandedViewOpen] = useState(false);

  // Slider
  const [slideIndex, setSlideIndex] = useState(0);
  const sliderIntervalRef = useRef(null);
  const SLIDE_COUNT = 5;

  const chatWindowRef = useRef(null);
  const uploadInputRef = useRef(null);

  useEffect(() => {
    fetchReactions()
      .then((r) => setReactions(r || []))
      .catch((e) => console.error("fetchReactions error:", e));

    fetchPrompts()
      .then((p) => setPrompts(p || []))
      .catch((e) => console.warn("fetchPrompts failed:", e));

    setMessages([
      {
        role: "assistant",
        content:
          "Welcome — type a reaction or product name to find documents, click a reaction tile to explore, or ask a question directly.",
      },
    ]);
  }, []);

  // slider autoplay
  useEffect(() => {
    sliderIntervalRef.current = setInterval(() => {
      setSlideIndex((s) => (s + 1) % SLIDE_COUNT);
    }, 4200);
    return () => clearInterval(sliderIntervalRef.current);
  }, []);

  const pushMessage = (m) => setMessages((prev) => [...prev, m]);
  const normalize = (s) => (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");

  // handle upload using api.uploadFile (relative endpoint)
  const handleUploadFile = async (file, reaction_type = "Miscellaneous") => {
    if (!file) return;
    pushMessage({ role: "assistant", content: "Uploading file...", loading: true });
    try {
      const res = await uploadFile(file, reaction_type);
      // remove loading placeholder
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      pushMessage({ role: "assistant", content: "Upload complete and indexed (if supported)." });
      // refresh product list for the reaction_type
      try {
        const prods = await fetchProducts(reaction_type);
        setProducts(prods || []);
        setProductListVisible(true);
      } catch {}
      return res;
    } catch (err) {
      console.error("handleUploadFile error:", err);
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      pushMessage({ role: "assistant", content: `Upload failed: ${err?.message || err}` });
      return null;
    }
  };

  const handleReactionClick = async (reactionName) => {
    setSelectedReaction(reactionName);
    try {
      const prods = await fetchProducts(reactionName);
      setProducts(prods || []);
      setProductListVisible(true);
      setExpandedViewOpen(true);
      pushMessage({ role: "assistant", content: `Found ${prods.length} products for ${reactionName}` });
    } catch (e) {
      console.error(e);
      pushMessage({ role: "assistant", content: "Error loading products for that reaction." });
    }
  };

  const handlePromptPick = async (promptText) => {
    setPromptGalleryOpen(false);
    await handleUserSend(promptText);
  };

  const handleSelectProduct = async (productId) => {
    try {
      setLoadingDetails(true);
      const meta = await fetchProductMeta(productId);
      setSelectedProduct(meta);
      setProductDetails(null);
      setSelectedSchemeUrl(null);
      setDetailModalOpen(true);

      try {
        const schemeUrl = await fetchSchemeImageUrl(productId);
        setSelectedSchemeUrl(schemeUrl);
      } catch {}

      try {
        const res = await fetchProductDetails(productId);
        const payload = (res && res.data) ? res.data : res;
        setProductDetails(payload);
        setHistory((h) => [
          { title: meta.name, content: payload.procedure ? payload.procedure.slice(0, 120) : "", productId: meta.id },
          ...h,
        ]);
      } catch (e) {
        console.error("fetchProductDetails error (select product):", e);
        pushMessage({ role: "assistant", content: "Failed to load product details." });
      }
    } catch (err) {
      console.error("handleSelectProduct error:", err);
      pushMessage({ role: "assistant", content: "Failed to load product metadata." });
    } finally {
      setLoadingDetails(false);
    }
  };

  const handleToggleCite = (product) => {
    const exists = selectedCitedDocs.find((p) => p.id === product.id);
    if (exists) {
      setSelectedCitedDocs((prev) => prev.filter((p) => p.id !== product.id));
      pushMessage({ role: "assistant", content: `Removed citation: ${product.name}` });
    } else {
      setSelectedCitedDocs((prev) => [{ id: product.id, name: product.name, reaction_type: product.reaction_type }, ...prev]);
      pushMessage({ role: "assistant", content: `Added citation: ${product.name}` });
    }
  };

  const removeCitation = (id) => {
    const found = selectedCitedDocs.find((d) => d.id === id);
    setSelectedCitedDocs((prev) => prev.filter((d) => d.id !== id));
    if (found) pushMessage({ role: "assistant", content: `Removed citation: ${found.name}` });
  };

  // main send handler (same logic as earlier working version)
  const handleUserSend = async (text) => {
    pushMessage({ role: "user", content: text });

    const norm = normalize(text);
    const match = reactions.find((r) => normalize(r) === norm || normalize(r) === normalize(text.replace(/\s+/g, "_")));
    if (match) {
      setSelectedReaction(match);
      try {
        const prods = await fetchProducts(match);
        setProducts(prods || []);
        setProductListVisible(true);
        setExpandedViewOpen(true);
        pushMessage({ role: "assistant", content: `Found ${prods.length} product${prods.length === 1 ? "" : "s"} — opened expanded view.` });
      } catch (e) {
        console.error(e);
        pushMessage({ role: "assistant", content: "Error loading products for that reaction."});
      }
      return;
    }

    if (selectedCitedDocs && selectedCitedDocs.length > 0) {
      setQueryLoading(true);
      pushMessage({ role: "assistant", content: "Searching selected documents...", loading: true });
      try {
        const ids = selectedCitedDocs.map((d) => d.id);
        const res = await queryWithCitations(ids, text);
        const payload = (res && res.data) ? res.data : res;
        setMessages((prev) => {
          const idx = prev.map((m) => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = [...prev];
            copy.splice(idx, 1);
            return copy;
          }
          return prev;
        });
        const answer = payload?.answer || payload?.response || "No relevant answer found.";
        const sources = (payload?.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } catch (err) {
        console.error("queryWithCitations error:", err);
        pushMessage({ role: "assistant", content: "Error querying selected documents."});
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    if (!selectedProduct) {
      setQueryLoading(true);
      pushMessage({ role: "assistant", content: "Searching documents...", loading: true });
      try {
        const res = await fetchProductDetails(undefined, text);
        const payload = (res && res.data) ? res.data : res;
        setMessages((prev) => {
          const idx = prev.map((m) => m.loading).lastIndexOf(true);
          if (idx >= 0) {
            const copy = [...prev];
            copy.splice(idx, 1);
            return copy;
          }
          return prev;
        });
        if (payload && payload.api_name) {
          let summary = "";
          if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
          if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
          if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
          if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
          pushMessage({ role: "assistant", content: summary, tables: (payload.tables || []) });
        } else if (payload && (payload.answer || payload.response)) {
          const answer = payload.answer || payload.response || "No answer.";
          const sources = (payload.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
          pushMessage({ role: "assistant", content: answer, sources });
        } else {
          pushMessage({ role: "assistant", content: "No structured data found. Try selecting a product or ask for specific extraction." });
        }
      } catch (err) {
        console.error("fetchProductDetails error (no product):", err);
        pushMessage({ role: "assistant", content: "Error querying documents." });
      } finally {
        setQueryLoading(false);
      }
      return;
    }

    setQueryLoading(true);
    pushMessage({ role: "assistant", content: "Fetching answer from selected document...", loading: true });
    try {
      const res = await fetchProductDetails(selectedProduct.id, text);
      const payload = (res && res.data) ? res.data : res;
      setMessages((prev) => {
        const idx = prev.map((m) => m.loading).lastIndexOf(true);
        if (idx >= 0) {
          const copy = [...prev];
          copy.splice(idx, 1);
          return copy;
        }
        return prev;
      });
      if (payload && payload.api_name) {
        let summary = "";
        if (payload.api_name) summary += `API: ${payload.api_name}\n\n`;
        if (payload.reaction_chemistry) summary += `Reaction: ${payload.reaction_chemistry}\n\n`;
        if (payload.yield) summary += `Yield: ${payload.yield}\n\n`;
        if (payload.procedure) summary += `Procedure (excerpt):\n${(payload.procedure || "").slice(0, 400)}\n\n`;
        pushMessage({ role: "assistant", content: summary, tables: (payload.tables || []) });
        setProductDetails(payload);
        setDetailModalOpen(true);
        setHistory((h) => [{ title: selectedProduct.name, content: payload.procedure ? payload.procedure.slice(0,120) : '', productId: selectedProduct.id }, ...h]);
      } else if (payload && (payload.answer || payload.response)) {
        const answer = payload.answer || payload.response || "No answer.";
        const sources = (payload.sources || []).map((s) => ({ product_id: s.product_id, product_name: s.product_name }));
        pushMessage({ role: "assistant", content: answer, sources });
      } else {
        pushMessage({ role: "assistant", content: "No answer found from document." });
      }
    } catch (err) {
      console.error("fetchProductDetails (selected) error:", err);
      pushMessage({ role: "assistant", content: "Error querying backend." });
    } finally {
      setQueryLoading(false);
    }
  };

  // slides
  const slides = [
    {
      id: 0,
      content: (
        <div className="flex flex-col items-center justify-center">
          <div className="text-lg font-semibold text-gray-700">Welcome to</div>
          <img src={chem_logo} alt="logo" className="h-20 w-auto mt-2" />
        </div>
      ),
    },
    { id: 1, content: <div className="h-full w-full flex items-center justify-center text-gray-600" /> },
    { id: 2, content: <div className="h-full w-full flex items-center justify-center text-gray-600" /> },
    { id: 3, content: <div className="h-full w-full flex items-center justify-center text-gray-600" /> },
    { id: 4, content: <div className="h-full w-full flex items-center justify-center text-gray-600" /> },
  ];

  const closeExpandedView = () => setExpandedViewOpen(false);

  // file input trigger
  const onPlusClick = () => {
    if (uploadInputRef.current) uploadInputRef.current.click();
  };

  const onFileInputChange = async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    // default reaction_type 'Miscellaneous' — you could surface a small select later
    await handleUploadFile(f, "Miscellaneous");
    e.target.value = "";
  };

  return (
    <>
      <Navbar />

      <div className="min-h-screen bg-white flex justify-center items-start overflow-x-hidden">
        <div className="w-full max-w-7xl py-8 px-4">
          {/* Carousel */}
          <div className="mb-6">
            <div className="relative overflow-hidden rounded-2xl shadow-sm border border-gray-100">
              <div
                className="flex transition-transform duration-700 ease-in-out"
                style={{ width: `${SLIDE_COUNT * 100}%`, transform: `translateX(-${slideIndex * (100 / SLIDE_COUNT)}%)` }}
              >
                {slides.map((s) => (
                  <div key={s.id} className="w-full flex-shrink-0 p-6 bg-gray-50" style={{ width: `${100 / SLIDE_COUNT}%` }}>
                    <div className="h-36 flex items-center justify-center">{s.content}</div>
                  </div>
                ))}
              </div>
              <div className="absolute bottom-3 left-1/2 transform -translate-x-1/2 flex gap-2">
                {slides.map((_, i) => (
                  <button key={i} onClick={() => setSlideIndex(i)} className={`w-2 h-2 rounded-full ${i === slideIndex ? "bg-gray-700" : "bg-gray-300"}`} />
                ))}
              </div>
            </div>
          </div>

          {/* Reaction tiles */}
          <div className="mb-6">
            <ReactionTiles reactions={reactions} onSelect={handleReactionClick} />
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Center: chat */}
            <div className="lg:col-span-2 flex justify-center">
              <div className="w-full max-w-2xl relative">
                <input ref={uploadInputRef} type="file" accept=".pdf,.docx,.pptx,.xlsx,.png,.jpg,.jpeg" className="hidden" onChange={onFileInputChange} />

                <ChatWindow
                  ref={chatWindowRef}
                  messages={messages}
                  onSend={handleUserSend}
                  centeredWidth="w-full"
                  loading={queryLoading || loadingDetails}
                  selectedCitedDocs={selectedCitedDocs}
                  removeCitation={removeCitation}
                />

                {/* plus button near chat (single button) */}
                <div className="absolute left-4 bottom-6">
                  <button
                    onClick={onPlusClick}
                    title="Upload file"
                    className="flex items-center justify-center w-10 h-10 rounded-full border border-gray-200 bg-white shadow hover:scale-95"
                    aria-label="Upload"
                  >
                    <span className="text-xl font-extrabold">+</span>
                  </button>
                </div>

                <div className="flex justify-center mt-4">
                  <button
                    onClick={() => setPromptGalleryOpen(true)}
                    className="px-4 py-2 rounded-full bg-white border shadow-sm hover:shadow-md text-sm font-medium"
                  >
                    Prompt Gallery
                  </button>
                </div>
              </div>
            </div>

            <div className="lg:col-span-1">
              <SidebarHistory history={history} onSelect={(h) => { if (h && h.productId) handleSelectProduct(h.productId); }} />
            </div>
          </div>

          {promptGalleryOpen && (
            <div className="fixed inset-0 z-50 flex items-center justify-center">
              <div className="absolute inset-0 bg-black/40" onClick={() => setPromptGalleryOpen(false)} />
              <div className="relative w-full max-w-3xl bg-white rounded-2xl p-6 shadow-2xl">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold">Prompt Gallery</h3>
                  <button className="px-3 py-1 rounded-md" onClick={() => setPromptGalleryOpen(false)}>Close</button>
                </div>
                <PromptGallery prompts={prompts} onPick={handlePromptPick} />
              </div>
            </div>
          )}

          {expandedViewOpen && (
            <div className="fixed inset-0 z-50 bg-white/95 backdrop-blur-sm overflow-auto">
              <div className="max-w-7xl mx-auto py-8 px-6 overflow-x-hidden">
                <div className="flex items-center justify-between mb-4">
                  <div className="flex items-center gap-3">
                    <button className="px-3 py-2 rounded-md bg-gray-100" onClick={closeExpandedView}>Close</button>
                    <h2 className="text-xl font-semibold">{selectedReaction || "Explore Products"}</h2>
                  </div>
                  <div>
                    <button className="px-3 py-2 rounded-md bg-indigo-600 text-white" onClick={closeExpandedView}>Done</button>
                  </div>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                  <div className="lg:col-span-2">
                    <div className="bg-white rounded-2xl shadow p-4 h-[72vh] flex flex-col">
                      <div className="flex-1 overflow-auto">
                        <ChatWindow
                          messages={messages}
                          onSend={handleUserSend}
                          centeredWidth="w-full"
                          loading={queryLoading || loadingDetails}
                          selectedCitedDocs={selectedCitedDocs}
                          removeCitation={removeCitation}
                        />
                      </div>
                    </div>
                  </div>

                  <div className="lg:col-span-1">
                    <div className="bg-white rounded-2xl shadow p-4 h-[72vh] overflow-auto">
                      <h3 className="text-lg font-semibold mb-3">Matched Products</h3>
                      {productListVisible && products && products.length > 0 ? (
                        <ProductTabs
                          products={products}
                          onSelect={(pid) => { handleSelectProduct(pid); }}
                          onContext={(p) => handleToggleCite(p)}
                          citedIds={new Set(selectedCitedDocs.map((d) => d.id))}
                        />
                      ) : (
                        <div className="text-gray-500">No products loaded — pick a reaction tile or type a product name.</div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          <ProductDetailModal
            open={detailModalOpen}
            onClose={() => setDetailModalOpen(false)}
            meta={selectedProduct}
            details={productDetails}
            loading={loadingDetails}
          />
        </div>
      </div>

      <Footer />
    </>
  );
}
