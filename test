import numpy as np
import math

def predictive_optimal_combinations_by_percent(reference_mean_df, test_mean_df,
                                               regulation, window_max,
                                               step_hours=0.25):
    """
    Picks based on dissolution-percentage targets:
    - Always includes t=0 (0%).
    - Brackets: 0–30, 30–60, 60–90 %.
    - Two targets per bracket at 1/3 and 2/3 of bracket.
    - Finds grid points whose reference predictions are closest (ensures two distinct picks per bracket).
    - Appends one extra: FDA/ANVISA needs both ≥85%, others need either ≥85%.
    - Computes f2 excluding the 0-h point.
    """
    # 1) Extract time & dissolution arrays
    t_ref  = reference_mean_df.iloc[:,0].astype(float).values
    d_ref  = reference_mean_df.iloc[:,1].astype(float).values
    t_test = test_mean_df.iloc[:,0].astype(float).values
    d_test = test_mean_df.iloc[:,1].astype(float).values

    # 2) Ensure (0,0) is included
    if t_ref[0] != 0.0:
        t_ref  = np.insert(t_ref,  0, 0.0); d_ref  = np.insert(d_ref,  0, 0.0)
        t_test = np.insert(t_test, 0, 0.0); d_test = np.insert(d_test, 0, 0.0)

    # 3) Build fine grid
    grid      = np.arange(0.0, window_max + 1e-8, step_hours)
    ref_pred   = np.interp(grid, t_ref,  d_ref)
    test_pred  = np.interp(grid, t_test, d_test)

    # 4) Initialize sequence with t=0 index
    seq_idxs = [0]

    # 5) Two distinct picks per percent bracket
    for low, high in [(0,30), (30,60), (60,90)]:
        # target percentages at 1/3 and 2/3
        target1 = low + (high - low) / 3
        target2 = low + 2*(high - low) / 3
        # find closest grid index for target1
        dists1 = sorted([(abs(ref_pred[i] - target1), i) for i in range(len(grid))])
        i1 = dists1[0][1]
        # for target2, skip i1 to ensure distinct
        dists2 = sorted([(abs(ref_pred[i] - target2), i)
                         for i in range(len(grid)) if i != i1])
        i2 = dists2[0][1]
        seq_idxs.extend([i1, i2])

    # 6) Deduplicate & sort
    seq_idxs = sorted(dict.fromkeys(seq_idxs))

    # 7) Append one regulatory extra ≥85%
    last = seq_idxs[-1]
    post = list(range(last+1, len(grid)))
    extra_i = None
    if regulation in ("FDA","ANVISA"):
        for i in post:
            if ref_pred[i] >= 85 and test_pred[i] >= 85:
                extra_i = i; break
    else:
        for i in post:
            if ref_pred[i] >= 85 or test_pred[i] >= 85:
                extra_i = i; break
    # fallback to maximize min( )
    if extra_i is None:
        best_i, best_v = None, -1
        for i in post:
            v = min(ref_pred[i], test_pred[i])
            if v > best_v:
                best_v, best_i = v, i
        extra_i = best_i

    if extra_i is not None and extra_i not in seq_idxs:
        seq_idxs.append(extra_i)
        seq_idxs = sorted(seq_idxs)

    # 8) Build sequences & compute f2
    seq       = [float(grid[i]) for i in seq_idxs]
    ref_vals  = [float(ref_pred[i]) for i in seq_idxs]
    test_vals = [float(test_pred[i]) for i in seq_idxs]
    ref_vals[0]  = 0.0
    test_vals[0] = 0.0
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    f2    = 50 * math.log10(100 / (1 + math.sqrt(np.mean(diffs**2))))

    return [{
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals,
        'test_vals': test_vals
    }], None

# === Updated wrapper in your if input1==1 block ===
# After window_min, window_max determination:
try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced
")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent‐targeted predictive function...
")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

# Normalize int/float
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]

# Then proceed to plot and print `results` as before
 ===

# ... inside `if input1 == 1:` after computing window_min/window_max ...
try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced\n")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent-targeted predictive function...\n")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

# Normalize int/float
for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]

# Then proceed to plot and print `results` as before
