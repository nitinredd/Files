import os
import google.auth
import pandas as pd
import streamlit as st
from vertexai.preview.generative_models import (
    GenerativeModel,
    SafetySetting,
    HarmCategory,
    HarmBlockThreshold,
)

# ---------- Configuration ----------
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()

# Initialize Gemini 2.5 Pro (using flash-thinking as placeholder)
model = GenerativeModel("gemini-2.0-flash-thinking-exp-01-21")

# Safety settings
safety_config = [
    SafetySetting(category=HarmCategory.HARM_CATEGORY_UNSPECIFIED, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_HARASSMENT, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold=HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(category=HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold=HarmBlockThreshold.BLOCK_NONE),
]

# ---------- Multi-Agent Framework ----------
class Agent:
    """Base class for agents"""
    def __init__(self, name: str):
        self.name = name

    def handle(self, query, context):
        raise NotImplementedError

class ExcelReaderAgent(Agent):
    """Reads structured data from Excel workbooks"""
    def __init__(self, files: list[str]):
        super().__init__("ExcelReader")
        self.sheets: dict[str, pd.DataFrame] = {}
        for f in files:
            xl = pd.ExcelFile(f)
            for sheet in xl.sheet_names:
                self.sheets[sheet] = xl.parse(sheet)

    def handle(self, query, context):
        # Simply return available sheet names
        return list(self.sheets.keys())

class QueryAgent(Agent):
    """Extracts relevant rows matching user intent"""
    def __init__(self, reader: ExcelReaderAgent):
        super().__init__("QueryAgent")
        self.reader = reader

    def handle(self, query: str, context):
        results: dict[str, pd.DataFrame] = {}
        for sheet_name, df in self.reader.sheets.items():
            # Use regex=False to avoid regex interpretation warnings
            mask = df.apply(
                lambda col: col.astype(str)
                                .str
                                .contains(query, case=False, na=False, regex=False)
            ).any(axis=1)
            matched = df.loc[mask]
            if not matched.empty:
                results[sheet_name] = matched
        return results

class GeminiAgent(Agent):
    """Calls Gemini to refine/answer based on extracted rows"""
    def __init__(self, model: GenerativeModel, safety_settings: list[SafetySetting]):
        super().__init__("GeminiAgent")
        self.model = model
        self.safety = safety_settings

    def handle(self, query: str, context: dict[str, pd.DataFrame]):
        # Build prompt from context rows
        prompt = (
            "You are a domain assistant.\n"
            f"User query: {query}\n"
            "Relevant data:\n"
        )
        for sheet, df in context.items():
            prompt += f"\nSheet: {sheet}\nRows:\n{df.to_csv(index=False)}\n"
        # Generate response
        resp = self.model.generate_content(
            [prompt],
            safety_settings=self.safety
        )
        return resp[0].text.strip() if resp else "No answer generated."

class CoordinatorAgent(Agent):
    """Orchestrates workflow among agents"""
    def __init__(
        self,
        reader: ExcelReaderAgent,
        query_agent: QueryAgent,
        gemini_agent: GeminiAgent
    ):
        super().__init__("Coordinator")
        self.reader = reader
        self.query_agent = query_agent
        self.gemini_agent = gemini_agent

    def handle(self, query: str):
        # Step 1: list sheets
        available_sheets = self.reader.handle(query, None)
        # Step 2: detailed row matching
        matched = self.query_agent.handle(query, None)
        if not matched:
            return None, None
        # Step 3: call Gemini to interpret
        answer = self.gemini_agent.handle(query, matched)
        return answer, matched

# ---------- Streamlit App ----------
st.set_page_config(page_title="Excel Chatbot", layout="wide")

# Initialize or load agents in session state
if 'agents' not in st.session_state:
    files = ['formula master_osd.xlsx', 'masterlist osd equipments.xlsx']
    reader      = ExcelReaderAgent(files)
    query_agent = QueryAgent(reader)
    gemini_agent= GeminiAgent(model, safety_config)
    coordinator = CoordinatorAgent(reader, query_agent, gemini_agent)

    st.session_state['agents'] = {
        'reader': reader,
        'query_agent': query_agent,
        'gemini_agent': gemini_agent,
        'coordinator': coordinator
    }

reader      = st.session_state['agents']['reader']
query_agent = st.session_state['agents']['query_agent']
gemini_agent= st.session_state['agents']['gemini_agent']
coordinator = st.session_state['agents']['coordinator']

# Greeting and dynamic samples
if 'greeted' not in st.session_state:
    st.write("**Hi! I'm your Excel Chatbot powered by Gemini 2.5 Pro.**")
    st.markdown("**Try these prompts:**")
    samples = []
    for sheet, df in list(reader.sheets.items())[:3]:
        first_row = df.iloc[0].to_dict()
        key, val = next(iter(first_row.items()))
        samples.append(f"Do we have {key} with value {val} in {sheet}?")
    for s in samples:
        st.write(f"- {s}")
    st.session_state['greeted'] = True

# User query input
query = st.text_input("Enter your query:")
if st.button("Ask") and query:
    with st.spinner("Processing..."):
        answer, matched = coordinator.handle(query)
        if matched is None:
            st.error("Relevant information not found in the Excel workbooks.")
        else:
            # Display matched tables
            st.subheader("Matched Data")
            for sheet, df in matched.items():
                st.write(f"**Sheet: {sheet}**")
                st.dataframe(df)
            # Display Geminiâ€™s answer
            st.subheader("Answer")
            st.write(answer)
