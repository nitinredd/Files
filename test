import os
import re
import glob
import base64
import fitz  # PyMuPDF
import pandas as pd
import streamlit as st
from langchain_openai import AzureChatOpenAI
from langchain.embeddings.cache import CacheBackedEmbeddings
from langchain.storage.file_system import LocalFileStore
from langchain_openai import AzureOpenAIEmbeddings
from langchain_community.vectorstores import FAISS
from langchain.docstore.document import Document
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate
from PIL import Image
import io

# Configuration - Replace with your Azure credentials
st.set_page_config(page_title="PharmaReaction AI", page_icon="🧪", layout="wide")
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"

# Azure Configuration
base_url = "https://your-azure-openai-service.openai.azure.com/"
api_version = "2024-02-15-preview"
api_key = "your-azure-api-key"
deployment_name = "GPT4o"
model_name = "GPT4o"

# Initialize Azure services
file_store = LocalFileStore('langchain-embeddings')
base_embeddings = AzureOpenAIEmbeddings(
    model="text-embedding-ada-002",
    api_version="2023-07-01-preview",
    azure_endpoint=base_url,
    api_key=api_key,
    azure_deployment="Def_data_qa"
)
cached_embeddings = CacheBackedEmbeddings.from_bytes_store(base_embeddings, file_store, namespace=base_embeddings.model)

chat_model = AzureChatOpenAI(
    azure_deployment=deployment_name,
    model=model_name,
    api_version=api_version,
    api_key=api_key,
    azure_endpoint=base_url
)

# Reaction Chemistry Categories (folder names)
REACTION_TYPES = [
    "C-C Bond Formation", "C-N Bond Formation", "Salt Formation", "Hydrolysis",
    "Amidation", "Reduction", "Oxidation", "Cyclization", "Purification",
    "Metal mediated-catalyzed", "C-halogen Bond Formation", "Miscellaneous"
]

# Base directories
BASE_DIR = r"C:\Reaction_Database"
PRODUCTS_DIR = os.path.join(BASE_DIR, "Products")
SCHEMES_DIR = os.path.join(BASE_DIR, "Synthetic_Schemes")

# Create directories if they don't exist
os.makedirs(PRODUCTS_DIR, exist_ok=True)
os.makedirs(SCHEMES_DIR, exist_ok=True)

# Custom CSS for professional UI
st.markdown("""
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: #333;
        }
        
        .stApp {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 65vh;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 1rem;
            background: white;
            margin-bottom: 1rem;
            overflow-y: auto;
        }
        
        .message {
            max-width: 80%;
            padding: 0.8rem 1.2rem;
            margin-bottom: 1rem;
            border-radius: 18px;
            line-height: 1.4;
        }
        
        .user-message {
            background: var(--secondary);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }
        
        .bot-message {
            background: var(--light);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }
        
        .product-card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1rem;
            margin: 0.5rem 0;
            cursor: pointer;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }
        
        .product-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-color: var(--secondary);
        }
        
        .product-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.3rem;
        }
        
        .reaction-type {
            font-size: 0.85rem;
            color: var(--accent);
            background: #fdecea;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
        }
        
        .input-container {
            display: flex;
            gap: 0.5rem;
        }
        
        .chat-input {
            flex: 1;
            padding: 0.8rem 1.2rem;
            border-radius: 25px;
            border: 2px solid var(--secondary);
            font-size: 1rem;
        }
        
        .send-button {
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 0 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .send-button:hover {
            background: var(--primary);
        }
        
        .detail-view {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            padding: 1.5rem;
            margin-top: 1rem;
        }
        
        .back-button {
            background: #f0f0f0;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .section-title {
            color: var(--primary);
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
            margin-top: 1.5rem;
        }
        
        .scheme-container {
            text-align: center;
            margin: 1.5rem 0;
        }
        
        .download-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
            text-decoration: none;
        }
        
        .tab-content {
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 5px;
            margin-top: 1rem;
            border: 1px solid #eee;
            white-space: pre-wrap;
        }
        
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
    </style>
""", unsafe_allow_html=True)

# Product Database
@st.cache_resource(show_spinner=False)
def load_product_database():
    products = []
    
    # Load products organized by reaction type folders
    for reaction_type in REACTION_TYPES:
        reaction_dir = os.path.join(PRODUCTS_DIR, reaction_type)
        if not os.path.exists(reaction_dir):
            continue
            
        pdf_files = glob.glob(os.path.join(reaction_dir, "*.pdf"))
        
        for pdf_path in pdf_files:
            try:
                filename = os.path.basename(pdf_path)
                product_name = os.path.splitext(filename)[0]
                
                # Find associated scheme files
                scheme_jpeg = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}.jpeg")
                scheme_cdx = os.path.join(SCHEMES_DIR, reaction_type, f"{product_name}.cdx")
                
                # Create unique ID based on reaction type and product name
                product_id = f"{reaction_type}_{product_name}"
                
                products.append({
                    "id": product_id,
                    "name": product_name,
                    "reaction_type": reaction_type,
                    "pdf_path": pdf_path,
                    "scheme_jpeg": scheme_jpeg if os.path.exists(scheme_jpeg) else None,
                    "scheme_cdx": scheme_cdx if os.path.exists(scheme_cdx) else None
                })
            except Exception as e:
                st.error(f"Error processing file {pdf_path}: {str(e)}")
    
    return products

# Robust PDF text extraction using PyMuPDF
def extract_pdf_text(pdf_path):
    text = ""
    try:
        doc = fitz.open(pdf_path)
        for page in doc:
            text += page.get_text() + "\n"
        return text
    except Exception as e:
        st.error(f"Error reading PDF {pdf_path}: {str(e)}")
        return ""

# Build vector database for a single product
def build_product_vector_store(product):
    # Extract text from PDF
    text = extract_pdf_text(product["pdf_path"])
    
    if not text or len(text.strip()) < 100:
        return None
    
    # Create document with metadata
    doc = Document(
        page_content=text,
        metadata={
            "product_id": product["id"],
            "product_name": product["name"],
            "reaction_type": product["reaction_type"],
            "source": product["pdf_path"]
        }
    )
    
    # Create FAISS vector store
    return FAISS.from_documents([doc], cached_embeddings)

# Custom prompt template for precise answers
PROMPT_TEMPLATE = """
You are a pharmaceutical chemistry expert specializing in reaction chemistry. 
Extract the following information from the document:

1. **API Name**: The active pharmaceutical ingredient
2. **Reaction Chemistry**: Type and description
3. **Yield**: Exact yield percentage or value
4. **Procedure**: Complete procedure EXACTLY as written in the source. 
   Preserve all formatting, punctuation, and structure. Do NOT modify or summarize.
5. **Tabular Data**: Provide COMPLETE tabular data verbatim. 
   Do NOT omit, summarize, or transform any content.

Document Content:
{context}

Question: {question}
Answer:
"""

PROMPT = PromptTemplate(
    template=PROMPT_TEMPLATE,
    input_variables=["context", "question"]
)

# Session state initialization
def init_session_state():
    if "all_products" not in st.session_state:
        st.session_state.all_products = load_product_database()
    
    if "messages" not in st.session_state:
        st.session_state.messages = [
            {"role": "assistant", "content": "Hello! I'm your Pharma Reaction Expert. Ask me about any reaction chemistry."}
        ]
    
    if "current_product" not in st.session_state:
        st.session_state.current_product = None
    
    if "current_reaction" not in st.session_state:
        st.session_state.current_reaction = None
    
    if "reaction_products" not in st.session_state:
        st.session_state.reaction_products = []
    
    if "product_details" not in st.session_state:
        st.session_state.product_details = {}
    
    if "user_query" not in st.session_state:
        st.session_state.user_query = ""

# Get product by ID
def get_product_by_id(product_id):
    for product in st.session_state.all_products:
        if product["id"] == product_id:
            return product
    return None

# Get products by reaction type
def get_products_by_reaction(reaction_type):
    return [p for p in st.session_state.all_products if p["reaction_type"] == reaction_type]

# File download helper
def get_binary_file_downloader_html(file_path, label="Download"):
    if not os.path.exists(file_path):
        return f'<span class="error">File not found: {os.path.basename(file_path)}</span>'
    
    with open(file_path, "rb") as f:
        data = f.read()
    b64 = base64.b64encode(data).decode()
    return f'<a href="data:application/octet-stream;base64,{b64}" download="{os.path.basename(file_path)}" class="download-btn">{label}</a>'

# Process reaction type query
def process_reaction_query(reaction_type):
    # Get all products for this reaction type
    products = get_products_by_reaction(reaction_type)
    
    if not products:
        return f"No products found for {reaction_type}", []
    
    return f"Found {len(products)} products for {reaction_type}:", products

# Process product query
def process_product_query(product):
    # Check if we already have details for this product
    if product["id"] in st.session_state.product_details:
        return st.session_state.product_details[product["id"]]
    
    # Build vector store for this product
    vector_store = build_product_vector_store(product)
    
    if not vector_store:
        return "Failed to process product document", None
    
    # Create retriever
    retriever = vector_store.as_retriever(search_kwargs={"k": 1})
    
    # Create QA chain
    qa_chain = RetrievalQA.from_chain_type(
        llm=chat_model,
        chain_type="stuff",
        retriever=retriever,
        chain_type_kwargs={"prompt": PROMPT},
        return_source_documents=False
    )
    
    # Query for product details
    query = "Extract API Name, Reaction Chemistry, Yield, Procedure, and Tabular Data"
    response = qa_chain.invoke({"query": query})["result"]
    
    # Cache the response
    st.session_state.product_details[product["id"]] = response
    
    return response, None

# Render chat message
def render_message(message):
    if message["role"] == "user":
        return f'<div class="message user-message">{message["content"]}</div>'
    else:
        # Convert newlines to HTML breaks
        content = message["content"].replace('\n', '<br>')
        return f'<div class="message bot-message">{content}</div>'

# Render product card
def render_product_card(product):
    return f"""
    <div class="product-card" onclick="selectProduct('{product['id']}')">
        <div class="product-title">{product['name']}</div>
        <div class="reaction-type">{product['reaction_type']}</div>
    </div>
    """

# Render product detail view
def render_product_detail(product):
    # Get product details
    details = st.session_state.product_details.get(product["id"], "")
    
    # Display details
    st.markdown(f'<div class="detail-view">', unsafe_allow_html=True)
    
    # Back button
    st.markdown("""
        <button class="back-button" onclick="goBack()">
            &larr; Back to Products
        </button>
    """, unsafe_allow_html=True)
    
    # Product header
    st.markdown(f'<h2>{product["name"]}</h2>', unsafe_allow_html=True)
    st.markdown(f'<div class="reaction-type">{product["reaction_type"]}</div>', unsafe_allow_html=True)
    
    # API Name
    api_match = re.search(r"\*\*API Name\*\*:(.*?)(?=\n\*\*|\Z)", details, re.DOTALL)
    if api_match:
        st.markdown(f'<div class="section-title">API Name</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{api_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Reaction Chemistry
    rxn_match = re.search(r"\*\*Reaction Chemistry\*\*:(.*?)(?=\n\*\*|\Z)", details, re.DOTALL)
    if rxn_match:
        st.markdown(f'<div class="section-title">Reaction Chemistry</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{rxn_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Yield
    yield_match = re.search(r"\*\*Yield\*\*:(.*?)(?=\n\*\*|\Z)", details, re.DOTALL)
    if yield_match:
        st.markdown(f'<div class="section-title">Yield</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{yield_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Procedure
    proc_match = re.search(r"\*\*Procedure\*\*:(.*?)(?=\n\*\*|\Z)", details, re.DOTALL)
    if proc_match:
        st.markdown(f'<div class="section-title">Procedure</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{proc_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Tabular Data
    table_match = re.search(r"\*\*Tabular Data\*\*:(.*?)(?=\n\*\*|\Z)", details, re.DOTALL)
    if table_match:
        st.markdown(f'<div class="section-title">Tabular Data</div>', unsafe_allow_html=True)
        st.markdown(f'<div class="tab-content">{table_match.group(1).strip()}</div>', unsafe_allow_html=True)
    
    # Synthetic scheme
    st.markdown(f'<div class="section-title">Synthetic Scheme</div>', unsafe_allow_html=True)
    if product["scheme_jpeg"] and os.path.exists(product["scheme_jpeg"]):
        try:
            # Open and resize image for better display
            img = Image.open(product["scheme_jpeg"])
            st.image(img, use_column_width=True, caption="Synthetic Scheme")
            
            if product["scheme_cdx"] and os.path.exists(product["scheme_cdx"]):
                st.markdown(get_binary_file_downloader_html(
                    product["scheme_cdx"], 
                    f"Download {product['name']} for ChemDraw"
                ), unsafe_allow_html=True)
            else:
                st.warning("CDX format not available for this product")
        except Exception as e:
            st.error(f"Error loading synthetic scheme: {str(e)}")
    else:
        st.warning("Synthetic scheme not available for this product")
    
    # Source document
    st.markdown(f'<div class="section-title">Source Document</div>', unsafe_allow_html=True)
    if os.path.exists(product["pdf_path"]):
        with open(product["pdf_path"], "rb") as f:
            pdf_bytes = f.read()
        
        st.download_button(
            label="Download Full PDF",
            data=pdf_bytes,
            file_name=os.path.basename(product["pdf_path"]),
            mime="application/pdf",
            use_container_width=True
        )
        
        # Display first page preview
        try:
            doc = fitz.open(stream=pdf_bytes, filetype="pdf")
            page = doc.load_page(0)
            pix = page.get_pixmap(dpi=150)
            img_bytes = pix.tobytes("png")
            st.image(img_bytes, caption="First Page Preview", use_column_width=True)
        except:
            st.warning("Could not generate PDF preview")
    else:
        st.error("PDF file not found")
    
    st.markdown(f'</div>', unsafe_allow_html=True)

# Main App
def main():
    # Initialize session state
    init_session_state()
    
    # Navigation Header
    st.markdown("""
        <div class="header">
            <h1>PharmaReaction AI</h1>
            <p>Reaction Chemistry Knowledge Base</p>
        </div>
    """, unsafe_allow_html=True)
    
    # Handle product selection from query params
    query_params = st.experimental_get_query_params()
    if "product" in query_params:
        product_id = query_params["product"][0]
        product = get_product_by_id(product_id)
        if product:
            st.session_state.current_product = product
            st.session_state.current_reaction = product["reaction_type"]
    
    # If we're viewing a product detail, show that
    if st.session_state.current_product:
        render_product_detail(st.session_state.current_product)
        return
    
    # If we're viewing a reaction type, show products
    if st.session_state.current_reaction:
        st.markdown(f'<h2>{st.session_state.current_reaction} Products</h2>', unsafe_allow_html=True)
        
        # Back button
        if st.button("← Back to Chat", key="back_button"):
            st.session_state.current_reaction = None
            st.rerun()
        
        # Display products in a grid
        if st.session_state.reaction_products:
            st.markdown('<div class="product-grid">', unsafe_allow_html=True)
            for product in st.session_state.reaction_products:
                st.markdown(render_product_card(product), unsafe_allow_html=True)
            st.markdown('</div>', unsafe_allow_html=True)
        else:
            st.warning(f"No products found for {st.session_state.current_reaction}")
        return
    
    # Chat interface
    st.markdown('<div class="chat-container" id="chat-container">', unsafe_allow_html=True)
    
    # Display chat messages
    for message in st.session_state.messages:
        st.markdown(render_message(message), unsafe_allow_html=True)
    
    st.markdown('</div>', unsafe_allow_html=True)  # Close chat container
    
    # Input area
    st.markdown('<div class="input-container">', unsafe_allow_html=True)
    user_input = st.text_input("Type your message...", st.session_state.user_query, 
                              key="user_input", 
                              placeholder="Ask about reaction chemistry...",
                              label_visibility="collapsed")
    st.markdown('</div>', unsafe_allow_html=True)
    
    # JavaScript for navigation
    st.markdown("""
        <script>
            // Scroll to bottom of chat
            function scrollToBottom() {
                const container = document.getElementById("chat-container");
                container.scrollTop = container.scrollHeight;
            }
            
            // Select product
            function selectProduct(productId) {
                window.location.href = window.location.href + "?product=" + productId;
            }
            
            // Go back to chat
            function goBack() {
                window.history.back();
            }
            
            // Scroll to bottom on load
            window.addEventListener('load', scrollToBottom);
        </script>
    """, unsafe_allow_html=True)
    
    # Send button
    col1, col2 = st.columns([1, 3])
    with col1:
        if st.button("Send", key="send_button", use_container_width=True):
            if st.session_state.user_input.strip():
                # Add user message to chat
                st.session_state.messages.append({"role": "user", "content": st.session_state.user_input})
                
                # Check if it's a reaction type query
                reaction_match = None
                for rtype in REACTION_TYPES:
                    if re.search(r"\b" + re.escape(rtype) + r"\b", st.session_state.user_input, re.IGNORECASE):
                        reaction_match = rtype
                        break
                
                if reaction_match:
                    # Process reaction type
                    response, products = process_reaction_query(reaction_match)
                    
                    # Add bot response to chat
                    st.session_state.messages.append({"role": "assistant", "content": response})
                    
                    # Set reaction products
                    st.session_state.current_reaction = reaction_match
                    st.session_state.reaction_products = products
                else:
                    # Process general query
                    response = "Please ask about a specific reaction chemistry type."
                    st.session_state.messages.append({"role": "assistant", "content": response})
                
                # Clear input
                st.session_state.user_query = ""
                st.rerun()
    
    with col2:
        if st.button("Clear Chat", key="clear_button", use_container_width=True):
            st.session_state.messages = [
                {"role": "assistant", "content": "Hello! I'm your Pharma Reaction Expert. Ask me about any reaction chemistry."}
            ]
            st.session_state.user_query = ""
            st.rerun()

# Run the app
if __name__ == "__main__":
    main()
