import fitz
import pytesseract
from PIL import Image
import numpy as np
import cv2
from docx import Document
from docx.shared import Inches, Pt, Cm, Twips
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx2pdf import convert
import pandas as pd
from tqdm import tqdm
import os
import logging
from pathlib import Path

class RobustDocumentConverter:
    def __init__(self, input_path, output_path, output_format='docx', dpi=300):
        self.input_path = input_path
        self.output_path = output_path
        self.output_format = output_format.lower()
        self.dpi = dpi
        self.doc = Document()
        self.setup_logging()
        self.setup_document()
        
    def setup_logging(self):
        """Setup logging configuration"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('conversion.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

    def setup_document(self):
        """Initialize document settings"""
        style = self.doc.styles['Normal']
        style.font.name = 'Yu Gothic'
        style._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')
        
        sections = self.doc.sections
        for section in sections:
            section.left_margin = Cm(2.54)
            section.right_margin = Cm(2.54)
            section.top_margin = Cm(2.54)
            section.bottom_margin = Cm(2.54)

    def validate_table(self, h_lines, v_lines, min_rows=1, min_cols=1):
        """Validate table structure before creation"""
        if not h_lines or not v_lines:
            return False
            
        row_positions = sorted(set(y for _, y, _, _ in h_lines))
        col_positions = sorted(set(x for x, _, _, _ in v_lines))
        
        if len(row_positions) <= min_rows or len(col_positions) <= min_cols:
            return False
            
        # Check for reasonable table dimensions
        row_heights = np.diff(row_positions)
        col_widths = np.diff(col_positions)
        
        if any(h <= 0 for h in row_heights) or any(w <= 0 for w in col_widths):
            return False
            
        return True

    def clean_cell_text(self, text):
        """Clean and validate cell text"""
        if not text or not isinstance(text, str):
            return ""
            
        # Remove problematic characters and excessive whitespace
        text = text.replace('\x00', '').strip()
        text = ' '.join(text.split())
        return text[:32767]  # Word cell text limit

    def detect_tables(self, image):
        """Detect tables with validation"""
        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        binary = cv2.adaptiveThreshold(
            gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY_INV, 11, 2
        )

        # Enhance line detection
        kernel = np.ones((2, 2), np.uint8)
        binary = cv2.dilate(binary, kernel, iterations=1)
        
        # Detect lines
        h_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (50, 1))
        v_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 50))
        
        horizontal = cv2.erode(binary, h_kernel)
        horizontal = cv2.dilate(horizontal, h_kernel)
        
        vertical = cv2.erode(binary, v_kernel)
        vertical = cv2.dilate(vertical, v_kernel)
        
        # Combine lines
        table_mask = cv2.addWeighted(horizontal, 1, vertical, 1, 0)
        
        # Find contours
        contours, _ = cv2.findContours(
            table_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        
        # Validate and filter tables
        valid_tables = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            if w > 100 and h > 100 and w/h < 10 and h/w < 10:
                table_region = image[y:y+h, x:x+w]
                if self.is_valid_table_region(table_region):
                    valid_tables.append((y, y+h, x, x+w))
        
        return sorted(valid_tables)

    def is_valid_table_region(self, region):
        """Additional validation for table regions"""
        try:
            gray = cv2.cvtColor(region, cv2.COLOR_RGB2GRAY)
            edges = cv2.Canny(gray, 50, 150)
            lines = cv2.HoughLinesP(edges, 1, np.pi/180, 50, 
                                  minLineLength=20, maxLineGap=5)
            
            if lines is None or len(lines) < 4:  # Minimum lines for a table
                return False
                
            # Check for perpendicular lines
            angles = []
            for line in lines:
                x1, y1, x2, y2 = line[0]
                if x2 - x1 != 0:
                    angle = np.abs(np.arctan((y2-y1)/(x2-x1)) * 180/np.pi)
                    angles.append(angle)
            
            angles = np.array(angles)
            horizontal_lines = np.sum((angles < 10) | (angles > 170))
            vertical_lines = np.sum((angles > 80) & (angles < 100))
            
            return horizontal_lines >= 2 and vertical_lines >= 2
            
        except Exception as e:
            self.logger.warning(f"Table validation error: {str(e)}")
            return False

    def process_table(self, image, table_coords):
        """Process table with error handling"""
        try:
            y1, y2, x1, x2 = table_coords
            table_image = image[y1:y2, x1:x2]
            
            # Get table structure
            gray = cv2.cvtColor(table_image, cv2.COLOR_RGB2GRAY)
            edges = cv2.Canny(gray, 50, 150)
            lines = cv2.HoughLinesP(edges, 1, np.pi/180, 50, 
                                  minLineLength=20, maxLineGap=5)
            
            if lines is None:
                return y2
                
            h_lines = []
            v_lines = []
            
            for line in lines:
                x1, y1, x2, y2 = line[0]
                if abs(y2 - y1) < 10:  # Horizontal
                    h_lines.append((min(x1, x2), y1, max(x1, x2), y2))
                elif abs(x2 - x1) < 10:  # Vertical
                    v_lines.append((x1, min(y1, y2), x2, max(y1, y2)))
            
            if not self.validate_table(h_lines, v_lines):
                return y2
                
            # Create table
            row_positions = sorted(set(y for _, y, _, _ in h_lines))
            col_positions = sorted(set(x for x, _, _, _ in v_lines))
            
            num_rows = len(row_positions) - 1
            num_cols = len(col_positions) - 1
            
            if num_rows > 0 and num_cols > 0:
                table = self.doc.add_table(rows=num_rows, cols=num_cols)
                table.style = 'Table Grid'
                
                # Process cells
                for i in range(num_rows):
                    for j in range(num_cols):
                        # Extract cell content
                        cell_y1 = row_positions[i]
                        cell_y2 = row_positions[i+1]
                        cell_x1 = col_positions[j]
                        cell_x2 = col_positions[j+1]
                        
                        cell_image = table_image[cell_y1:cell_y2, cell_x1:cell_x2]
                        
                        # OCR cell content
                        cell_text = pytesseract.image_to_string(
                            cell_image, lang='jpn+eng', 
                            config='--psm 6'
                        )
                        
                        # Clean and validate cell text
                        cell_text = self.clean_cell_text(cell_text)
                        
                        # Apply cell content
                        cell = table.cell(i, j)
                        cell.text = cell_text
                        
                        # Apply formatting
                        paragraph = cell.paragraphs[0]
                        run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
                        run.font.name = 'Yu Gothic'
                        run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')
                
                # Add spacing after table
                self.doc.add_paragraph()
            
            return y2
            
        except Exception as e:
            self.logger.error(f"Table processing error: {str(e)}")
            return table_coords[1]

    def convert(self):
        """Main conversion process with progress bar"""
        try:
            pdf_document = fitz.open(self.input_path)
            total_pages = pdf_document.page_count
            
            with tqdm(total=total_pages, desc="Converting PDF") as pbar:
                for page_num in range(total_pages):
                    try:
                        # Get page and convert to image
                        page = pdf_document[page_num]
                        pix = page.get_pixmap(matrix=fitz.Matrix(self.dpi/72, self.dpi/72))
                        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
                        img_np = np.array(img)
                        
                        # Detect and process tables
                        tables = self.detect_tables(img_np)
                        last_y = 0
                        
                        for table_coords in tables:
                            # Process text before table
                            if table_coords[0] > last_y:
                                text_region = img_np[last_y:table_coords[0], :]
                                text = pytesseract.image_to_string(
                                    text_region, lang='jpn+eng'
                                )
                                if text.strip():
                                    p = self.doc.add_paragraph(text.strip())
                                    for run in p.runs:
                                        run.font.name = 'Yu Gothic'
                                        run._element.rPr.rFonts.set(
                                            qn('w:eastAsia'), 'Yu Gothic'
                                        )
                            
                            # Process table
                            last_y = self.process_table(img_np, table_coords)
                        
                        # Process remaining text
                        if last_y < img_np.shape[0]:
                            text_region = img_np[last_y:, :]
                            text = pytesseract.image_to_string(
                                text_region, lang='jpn+eng'
                            )
                            if text.strip():
                                p = self.doc.add_paragraph(text.strip())
                                for run in p.runs:
                                    run.font.name = 'Yu Gothic'
                                    run._element.rPr.rFonts.set(
                                        qn('w:eastAsia'), 'Yu Gothic'
                                    )
                        
                        # Add page break if not last page
                        if page_num < total_pages - 1:
                            self.doc.add_page_break()
                        
                        img.close()
                        pbar.update(1)
                        
                    except Exception as e:
                        self.logger.error(f"Error processing page {page_num + 1}: {str(e)}")
                        continue
            
            # Save document
            output_dir = os.path.dirname(self.output_path)
            if output_dir:
                os.makedirs(output_dir, exist_ok=True)
            
            temp_docx = self.output_path
            if self.output_format == 'pdf':
                temp_docx = str(Path(self.output_path).with_suffix('_temp.docx'))
            
            self.doc.save(temp_docx)
            
            if self.output_format == 'pdf':
                convert(temp_docx, self.output_path)
                os.remove(temp_docx)
            
            self.logger.info(f"Document successfully saved as {self.output_path}")
            
        except Exception as e:
            self.logger.error(f"Conversion error: {str(e)}")
        finally:
            if 'pdf_document' in locals():
                pdf_document.close()

def main():
    print("Robust Document Converter")
    print("-" * 30)
    
    input_path = input("Enter input PDF path: ")
    output_format = input("Enter desired output format (docx/pdf): ").lower()
    while output_format not in ['docx', 'pdf']:
        output_format = input("Please enter either 'docx' or 'pdf': ").lower()
    
    try:
        dpi = int(input("Enter DPI (300-600, press Enter for default 300): ") or 300)
        dpi = max(300, min(600, dpi))
    except ValueError:
        dpi = 300
    
    output_path = str(Path(input_path).with_suffix(f'.{output_format}'))
    
    converter = RobustDocumentConverter(input_path, output_path, output_format, dpi)
    converter.convert()

if __name__ == "__main__":
    main()
