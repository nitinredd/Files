src/utils/parseResponseToTable.js
// src/utils/parseResponseToTable.js
export function parseResponseToTable(raw) {
  if (!raw) return null
  let s = String(raw).trim()

  // Remove surrounding code fences (``` or ```lang)
  s = s.replace(/^\s*```[\s\S]*?```/gm, (m) => {
    // if the whole response is a code block, keep inner content
    const inner = m.replace(/^\s*```[^\n]*\n?/, '').replace(/```$/, '')
    return inner.trim()
  })

  // 1) Try JSON first
  try {
    const parsed = JSON.parse(s)
    if (Array.isArray(parsed) && parsed.length && parsed.every(it => typeof it === 'object' && !Array.isArray(it))) {
      return { type: 'json', data: parsed }
    }
    if (typeof parsed === 'object' && parsed !== null) {
      return { type: 'json', data: [parsed] }
    }
  } catch (e) {
    // not JSON
  }

  // 2) Extract markdown-like pipe-table blocks (support with/without outer pipes)
  const lines = s.split('\n').map(l => l.replace(/\r/g, '').trimRight())

  // Find a contiguous block that looks like a markdown table
  let tableBlock = null
  for (let i = 0; i < lines.length - 1; i++) {
    const headerLine = lines[i].trim()
    const sepLine = (lines[i + 1] || '').trim()
    if (!headerLine) continue
    // header must contain pipes OR tabs (prefer pipes)
    const headerHasPipe = /\|/.test(headerLine)
    const sepLooksLike = /^[:\-\s|]+$/.test(sepLine) && (/[-:]\s*[-:]/.test(sepLine) || /-{3,}/.test(sepLine))
    if (headerHasPipe && sepLooksLike) {
      // collect from header down while lines contain pipes (or at least consistent col counts)
      const block = []
      let j = i
      while (j < lines.length && /\|/.test(lines[j])) {
        block.push(lines[j])
        j++
      }
      tableBlock = block
      break
    }
  }

  // 3) If tableBlock found, parse it (skip the separator row)
  if (tableBlock && tableBlock.length >= 2) {
    // normalize: optionally strip leading/trailing pipe
    const normalizeRow = (r) => {
      let row = r.trim()
      if (row.startsWith('|')) row = row.slice(1)
      if (row.endsWith('|')) row = row.slice(0, -1)
      return row.split('|').map(c => c.trim())
    }
    const headers = normalizeRow(tableBlock[0])
    // skip second row (separator)
    const rows = tableBlock.slice(2).map(r => normalizeRow(r))
    return { type: 'matrix', headers, rows }
  }

  // 4) Tab-separated or pipe-separated "simple" matrix detection
  const cleanedLines = lines.filter(l => l.length > 0)
  if (cleanedLines.length >= 2) {
    const first = cleanedLines[0]
    if (first.includes('\t')) {
      const headers = first.split('\t').map(s => s.trim())
      const rows = cleanedLines.slice(1).map(r => r.split('\t').map(c => c.trim()))
      return { type: 'matrix', headers, rows }
    }
    if (first.includes('|')) {
      // if no separator row but pipes are present, parse similarly
      const headers = first.split('|').map(s => s.trim()).filter(Boolean)
      const rows = cleanedLines.slice(1).map(r => r.split('|').map(c => c.trim()).filter(Boolean))
      if (rows.length && rows.every(r => r.length === headers.length)) {
        return { type: 'matrix', headers, rows }
      }
    }
  }

  // Nothing matched
  return null
}
##################################################
src/components/Loader.jsx
// src/components/Loader.jsx
import React from 'react'
import { motion } from 'framer-motion'

export default function Loader({ label = 'Thinking...' }) {
  return (
    <div className="absolute inset-0 z-50 flex items-center justify-center pointer-events-none">
      <div className="bg-white/90 backdrop-blur-sm rounded-xl p-6 flex flex-col items-center gap-3 shadow-glow">
        <motion.div
          initial={{ rotate: 0 }}
          animate={{ rotate: 360 }}
          transition={{ repeat: Infinity, duration: 1.6, ease: 'linear' }}
          className="w-16 h-16 rounded-full bg-gradient-to-br from-primary to-indigo-500 flex items-center justify-center"
        >
          <motion.div
            initial={{ y: -2 }}
            animate={{ y: 2 }}
            transition={{ repeat: Infinity, duration: 0.6, yoyo: Infinity }}
            className="w-3 h-3 rounded-full bg-white"
          />
        </motion.div>

        <div className="text-sm font-medium">{label}</div>

        <div className="flex items-center gap-1">
          <motion.div animate={{ y: [0, -6, 0] }} transition={{ repeat: Infinity, duration: 0.9 }} className="w-2 h-2 rounded-full bg-gray-400" />
          <motion.div animate={{ y: [0, -8, 0] }} transition={{ repeat: Infinity, duration: 0.9, delay: 0.12 }} className="w-2 h-2 rounded-full bg-gray-400" />
          <motion.div animate={{ y: [0, -6, 0] }} transition={{ repeat: Infinity, duration: 0.9, delay: 0.24 }} className="w-2 h-2 rounded-full bg-gray-400" />
        </div>
      </div>
    </div>
  )
}
####################################################
src/components/PromptModal.jsx
// src/components/PromptModal.jsx
import React from 'react'
import { motion } from 'framer-motion'
import { FiX } from 'react-icons/fi'

export default function PromptModal({ open, onClose, tiles, onPick }) {
  if (!open) return null

  return (
    <div className="fixed inset-0 z-60 flex items-center justify-center">
      <div onClick={onClose} className="absolute inset-0 bg-black/40 backdrop-blur-sm"></div>

      <motion.div initial={{ scale: 0.95, opacity: 0 }} animate={{ scale: 1, opacity: 1 }}
        className="relative w-[min(980px,92vw)] bg-white rounded-2xl shadow-2xl p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold">Prompt Gallery</h3>
          <button onClick={onClose} aria-label="Close prompts" className="p-2 rounded hover:bg-gray-100">
            <FiX />
          </button>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
          {Object.entries(tiles).flatMap(([group, prompts]) =>
            prompts.map((p, idx) => (
              <motion.button key={group + idx}
                whileHover={{ y: -8, scale: 1.02 }} whileTap={{ scale: 0.98 }}
                onClick={() => { onPick(p); onClose() }}
                className="tile-card p-4 rounded-xl bg-gradient-to-br from-white to-gray-50 text-left">
                <div className="text-sm font-medium">{p}</div>
                <div className="text-xs text-gray-500 mt-2">{group}</div>
              </motion.button>
            ))
          )}
        </div>
      </motion.div>
    </div>
  )
}
############################################################
src/components/ChatWidget.jsx
// src/components/ChatWidget.jsx
import React, { useEffect, useRef, useState } from 'react'
import { motion } from 'framer-motion'
import { FiMessageCircle, FiX, FiMic, FiSend, FiChevronDown } from 'react-icons/fi'
import Message from './Message'
import PromptModal from './PromptModal'
import FileUploader from './FileUploader'
import Loader from './Loader'
import { chatRequest, speechToTextUpload, textToSpeechUrl } from '../api'

// Sample prompts
const TILE_QUESTIONS = {
  "Product A": ["What is the API used?", "What is the batch size?", "Who is the manufacturer?"],
  "Line B": ["What is the speed range?", "What equipment is used?", "What is the pressure limit?"],
  "Formulation Z": ["List excipients used", "Describe dissolution method"],
  "Process Y": ["Steps in granulation?", "Drying temperature?"],
}

export default function ChatWidget() {
  const [open, setOpen] = useState(false)
  const [promptOpen, setPromptOpen] = useState(false)
  const [messages, setMessages] = useState([])
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const [recording, setRecording] = useState(false)
  const [suggests, setSuggests] = useState([])
  const recorderRef = useRef(null)
  const audioChunksRef = useRef([])
  const scrollRef = useRef(null)
  const typingTimeout = useRef(null)

  // Ensure when modal opens the chat composer is visible (modal uses fixed height)
  useEffect(() => { if (open) scrollToBottom() }, [open, messages])

  function appendMsg(from, text) {
    setMessages(m => [...m, { id: crypto?.randomUUID?.() ?? Date.now(), from, text }])
  }

  async function send(promptToSend = null) {
    const q = (promptToSend !== null) ? String(promptToSend).trim() : input.trim()
    if (!q) return
    appendMsg('user', q)
    setInput('')
    setLoading(true)
    try {
      const resp = await chatRequest(q)
      const ans = resp?.response ?? 'Oops! No relevant information found.'
      appendMsg('agent', ans)
    } catch (e) {
      appendMsg('agent', 'Error calling backend — ' + String(e.message ?? e))
    } finally {
      setLoading(false)
      setTimeout(scrollToBottom, 120)
    }
  }

  function scrollToBottom() {
    try { scrollRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' }) } catch (e) {}
  }

  // Prompt pick: set input then auto-send after 250ms
  function onPromptPick(p) {
    setInput(p)
    setTimeout(() => send(p), 260)
  }

  // Typing suggestions: simple rule-based suggestions that preview as mini-table
  useEffect(() => {
    clearTimeout(typingTimeout.current)
    const val = input.toLowerCase()
    typingTimeout.current = setTimeout(() => {
      const list = []
      if (val.includes('capacity') || val.includes('capacities')) {
        list.push({
          title: 'Capacities table',
          prompt: 'Provide a table with columns: Line, Max Capacity (kg/h), Typical Batch Size (kg).'
        })
      }
      if (val.includes('dissolution')) {
        list.push({
          title: 'Dissolution conditions',
          prompt: 'Provide a table with columns: Method, Medium, RPM, Temperature.'
        })
      }
      setSuggests(list)
    }, 220)
    return () => clearTimeout(typingTimeout.current)
  }, [input])

  // Recording -> convert to PCM WAV then upload
  async function startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      const mr = new MediaRecorder(stream)
      recorderRef.current = mr
      audioChunksRef.current = []
      mr.ondataavailable = (e) => audioChunksRef.current.push(e.data)
      mr.onstop = async () => {
        const blob = new Blob(audioChunksRef.current, { type: audioChunksRef.current[0]?.type || 'audio/webm' })
        try {
          const wavBlob = await convertBlobToWav(blob)
          const r = await speechToTextUpload(wavBlob)
          const text = r?.text ?? ''
          if (text) setInput(text)
        } catch (err) {
          appendMsg('agent', 'STT Error: ' + String(err.message ?? err))
        }
      }
      mr.start()
      setRecording(true)
    } catch (e) {
      appendMsg('agent', 'Mic access denied: ' + (e.message || e))
    }
  }

  function stopRecording() {
    const mr = recorderRef.current
    if (mr && mr.state !== 'inactive') mr.stop()
    setRecording(false)
  }

  // Convert arbitrary audio blob (webm/ogg) to WAV (PCM16) using AudioContext decode
  async function convertBlobToWav(blob) {
    // decode audio data
    const arrayBuffer = await blob.arrayBuffer()
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer)

    // interleave and convert to 16-bit PCM
    const numChannels = audioBuffer.numberOfChannels
    const sampleRate = audioBuffer.sampleRate
    let interleaved
    if (numChannels === 1) {
      interleaved = audioBuffer.getChannelData(0)
    } else {
      const chs = []
      for (let i = 0; i < numChannels; i++) chs.push(audioBuffer.getChannelData(i))
      const length = chs[0].length
      interleaved = new Float32Array(length * numChannels)
      let idx = 0
      for (let i = 0; i < length; i++) {
        for (let c = 0; c < numChannels; c++) {
          interleaved[idx++] = chs[c][i]
        }
      }
    }

    // convert float32 to 16-bit PCM
    const wavBuffer = encodeWAV(interleaved, numChannels, sampleRate)
    return new Blob([wavBuffer], { type: 'audio/wav' })
  }

  // WAV encoder for PCM16
  function encodeWAV(samples, numChannels, sampleRate) {
    const bytesPerSample = 2
    const blockAlign = numChannels * bytesPerSample
    const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)
    const view = new DataView(buffer)

    /* RIFF identifier */
    writeString(view, 0, 'RIFF')
    /* file length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true)
    /* RIFF type */
    writeString(view, 8, 'WAVE')
    /* format chunk identifier */
    writeString(view, 12, 'fmt ')
    /* format chunk length */
    view.setUint32(16, 16, true)
    /* sample format (raw) */
    view.setUint16(20, 1, true)
    /* channel count */
    view.setUint16(22, numChannels, true)
    /* sample rate */
    view.setUint32(24, sampleRate, true)
    /* byte rate (sampleRate * blockAlign) */
    view.setUint32(28, sampleRate * blockAlign, true)
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true)
    /* bits per sample */
    view.setUint16(34, 16, true)
    /* data chunk identifier */
    writeString(view, 36, 'data')
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true)

    // write PCM samples
    floatTo16BitPCM(view, 44, samples)

    return view
  }

  function floatTo16BitPCM(output, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, input[i]))
      s = s < 0 ? s * 0x8000 : s * 0x7FFF
      output.setInt16(offset, s, true)
    }
  }

  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i))
    }
  }

  // Read aloud helper
  function readAloud(text) {
    const url = textToSpeechUrl(text)
    const audio = new Audio(url)
    audio.play()
  }

  // File upload callback: user gets a friendly system message after upload
  function onFileUploaded(data) {
    if (data?.filename) appendMsg('agent', `Uploaded: ${data.filename} — indexed and available for querying.`)
    else appendMsg('agent', `Upload result: ${JSON.stringify(data)}`)
  }

  // Suggestion click: insert prompt and send immediately (these are table-producing prompts)
  function onSuggestionClick(item) {
    setInput(item.prompt)
    setTimeout(() => send(item.prompt), 200)
  }

  return (
    <>
      {/* Floating icon */}
      <div className="fixed bottom-6 right-6 z-50">
        <motion.button whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.96 }} onClick={() => setOpen(true)}
          className="w-16 h-16 rounded-full shadow-glow bg-gradient-to-br from-primary to-indigo-500 flex items-center justify-center text-white text-2xl">
          <FiMessageCircle />
        </motion.button>
      </div>

      {/* Centered modal (non-resizable) */}
      {open && (
        <div className="fixed inset-0 z-60 flex items-center justify-center p-4">
          <div onClick={() => setOpen(false)} className="absolute inset-0 bg-black/40 backdrop-blur-sm"></div>

          <motion.div initial={{ opacity: 0, scale: 0.98 }} animate={{ opacity: 1, scale: 1 }}
            className="relative chat-modal bg-white rounded-2xl shadow-2xl overflow-hidden"
            style={{ height: 'min(760px, 86vh)', width: 'min(1100px, 94vw)' }}>

            {/* Header */}
            <div className="flex items-center justify-between px-6 py-4 border-b">
              <div className="flex items-center gap-3">
                <div className="w-11 h-11 rounded-lg bg-gradient-to-br from-primary to-indigo-400 flex items-center justify-center text-white font-bold">SP</div>
                <div>
                  <div className="font-semibold text-lg">Scaleup Predictor</div>
                  <div className="text-xs text-gray-500">Ask your documents & dataset</div>
                </div>
              </div>

              <div className="flex items-center gap-3">
                <button onClick={() => setPromptOpen(true)} className="px-3 py-2 rounded bg-white border flex items-center gap-2">
                  <FiChevronDown /> Prompts
                </button>

                <FileUploader onUploaded={onFileUploaded} />

                <button onClick={() => setOpen(false)} className="p-2 rounded hover:bg-gray-100"><FiX /></button>
              </div>
            </div>

            {/* Main content */}
            <div className="flex flex-col h-full">
              <div className="flex-1 p-6 overflow-auto scrollbar-thin relative">
                {/* loader overlay */}
                {loading && <Loader label="Generating response..." />}

                <div className="flex flex-col gap-4">
                  {messages.length === 0 && !loading && (
                    <div className="text-center text-gray-400">Welcome — ask anything related to your dataset or uploaded documents.</div>
                  )}

                  {messages.map(m => (
                    <Message key={m.id} from={m.from} text={m.text} onReadAloud={readAloud} />
                  ))}

                  <div ref={scrollRef} />
                </div>
              </div>

              {/* Composer: pinned at bottom — ensure visible */}
              <div className="px-6 py-4 border-t bg-white">
                <div className="flex items-start gap-3">
                  <textarea value={input} onChange={(e) => setInput(e.target.value)} placeholder="Type your question (Enter to send)" className="flex-1 resize-none p-3 rounded-xl border focus:outline-none" rows={2}
                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send() } }} />

                  <div className="flex flex-col gap-2">
                    <button title={recording ? 'Stop recording' : 'Record'} onClick={() => { recording ? stopRecording() : startRecording() }} className={`p-3 rounded-lg border ${recording ? 'bg-red-50' : 'bg-white'}`}>
                      <FiMic />
                    </button>

                    <button onClick={() => send()} className="px-4 py-2 rounded-lg bg-primary text-white flex items-center gap-2">
                      <FiSend /> Send
                    </button>
                  </div>
                </div>

                {/* Typing suggestions rendered as small table-style cards */}
                <div className="mt-3">
                  {suggests.length > 0 && (
                    <div className="flex gap-3">
                      {suggests.map((s, i) => (
                        <motion.div key={i} whileHover={{ y: -6 }} className="p-3 rounded-lg bg-gray-50 border">
                          <div className="text-xs font-medium">{s.title}</div>
                          <div className="text-xs text-gray-500 mt-1">{s.prompt}</div>
                          <div className="mt-2">
                            <button onClick={() => onSuggestionClick(s)} className="px-2 py-1 text-xs rounded bg-primary text-white">Use</button>
                          </div>
                        </motion.div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      )}

      <PromptModal open={promptOpen} onClose={() => setPromptOpen(false)} tiles={TILE_QUESTIONS} onPick={onPromptPick} />
    </>
  )
}
