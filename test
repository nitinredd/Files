def predictive_optimal_combinations_advanced(ref_df, test_df, regulation, window_min, window_max, diff_threshold, interp_method='gpr'):
    best_result = None
    best_f2 = -np.inf
    results = []
    
    # Generate time points with step=5 to reduce combinations
    times_list = list(range(window_min, window_max + 1, 5))
    MAX_SEQUENCE_LENGTH = 6  # Cap sequence length
    
    def search_sequence(seq, next_index):
        nonlocal best_result, best_f2
        if len(seq) >= MAX_SEQUENCE_LENGTH:
            return
        
        # Early check for difference threshold
        if diff_threshold is not None and len(seq) >= 2:
            ref_interp = interpolate_dissolution_curve(ref_df, seq, method=interp_method)
            test_interp = interpolate_dissolution_curve(test_df, seq, method=interp_method)
            if any(np.abs(ref_interp - test_interp) > diff_threshold):
                return
        
        # Rest of the code...
    
    search_sequence([0], 1)
    return best_result, results
