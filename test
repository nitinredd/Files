# excel_adk_chatbot.py

import os
import json
import logging
import pandas as pd
import streamlit as st

from google.adk.agents import LlmAgent, BaseAgent, AgentOrchestrator
from google.adk.tools import Tool
from vertexai.preview.generative_models import GenerativeModel, SafetySetting, HarmCategory, HarmBlockThreshold

# ---------- Logging ----------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ---------- Configuration ----------
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
MODEL_NAME = "gemini-2.0-flash-thinking-exp-01-21"
llm = GenerativeModel(MODEL_NAME)

safety = [
    SafetySetting(HarmCategory.HARM_CATEGORY_UNSPECIFIED,    HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(HarmCategory.HARM_CATEGORY_HARASSMENT,     HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(HarmCategory.HARM_CATEGORY_HATE_SPEECH,    HarmBlockThreshold.BLOCK_NONE),
    SafetySetting(HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, HarmBlockThreshold.BLOCK_NONE),
]

# ---------- Tools ----------
class ExcelLoader(Tool):
    """Loads all sheets and their columns from given Excel files."""
    def __init__(self, paths: list[str]):
        super().__init__(name="excel_loader")
        self.sheets = {}
        for p in paths:
            xl = pd.ExcelFile(p)
            for s in xl.sheet_names:
                self.sheets[s] = xl.parse(s)

    def run(self) -> dict[str, list[str]]:
        return {sheet: df.columns.tolist() for sheet, df in self.sheets.items()}


class DataQuery(Tool):
    """Filters a sheet by provided row-filters and returns specified columns."""
    def __init__(self, loader: ExcelLoader):
        super().__init__(name="data_query")
        self.loader = loader

    def run(self, sheet: str, filters: dict[str,str], columns: list[str]) -> pd.DataFrame:
        df = self.loader.sheets[sheet]
        for col, val in filters.items():
            df = df[df[col].astype(str).str.contains(val, case=False, regex=False)]
        return df[columns]


# ---------- Agents ----------

# 1) Intent-parsing — LLM-driven
intent_agent = LlmAgent(
    name="intent_agent",
    model=MODEL_NAME,
    instruction=(
        "Parse the user question into JSON with keys: equipment, plant, parameter.\n"
        "Example output:\n"
        "{\"equipment\": \"Glatt\", \"plant\": \"F20\", \"parameter\": \"impeller speed\"}"
    ),
    safety_settings=safety,
    tools=[]
)

# 2) Schema validation — deterministic
schema_agent = BaseAgent(
    name="schema_agent",
    tools=[ExcelLoader(['formula master_osd.xlsx', 'masterlist osd equipments.xlsx'])],
    instruction=(
        "Given the intent JSON and the loaded sheets with their columns, "
        "return JSON: {sheet_name: {\"filters\": {\"equipment\": ..., \"plant\": ...}, "
        "\"columns\": [<best matching columns>]}}."
    )
)

# 3) Data retrieval — deterministic
data_agent = BaseAgent(
    name="data_agent",
    tools=[DataQuery(schema_agent.tools[0])],
    instruction="Take the schema map JSON and fetch the filtered rows for each sheet."
)

# 4) Response generation — LLM-assisted formatting
response_agent = LlmAgent(
    name="response_agent",
    model=MODEL_NAME,
    instruction=(
        "Format the retrieved DataFrame(s) into a clean Markdown table or brief English summary. "
        "Only include the data; do not hallucinate extra content."
    ),
    safety_settings=safety,
    tools=[]
)

# Orchestrator ties them together
orchestrator = AgentOrchestrator(
    agents=[intent_agent, schema_agent, data_agent, response_agent]
)

# ---------- Streamlit UI ----------
st.set_page_config(page_title="Excel ADK Chatbot", layout="wide")
st.title("Excel Chatbot (ADK + Gemini)")

question = st.text_input("Ask your question about the Excel workbooks:")
if st.button("Ask") and question.strip():
    with st.spinner("Thinking…"):
        try:
            # Run the full agent chain in one call:
            result = orchestrator.run(input=question)
            # orchestrator.run returns the final agent's output
            st.markdown(result)
        except Exception as e:
            logger.exception("Chatbot error")
            st.error(f"Error: {e}")
