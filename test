def process_table(self, image, table_coords):
    """Enhanced table processing with robust cell handling"""
    try:
        y1, y2, x1, x2 = table_coords
        if y1 >= y2 or x1 >= x2:  # Invalid coordinates
            return table_coords[1]

        # Crop the table region from the image
        table_image = image[y1:y2, x1:x2]
        if table_image.size == 0:  # Check for empty image
            return table_coords[1]

        # Convert to grayscale and binarize
        gray = cv2.cvtColor(table_image, cv2.COLOR_RGB2GRAY)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)

        # Detect horizontal and vertical lines
        horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (40, 1))
        vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 40))

        horizontal = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel)
        vertical = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel)

        # Combine lines to form the grid
        grid = cv2.addWeighted(horizontal, 0.5, vertical, 0.5, 0.0)

        # Find contours for grid lines
        contours, _ = cv2.findContours(grid, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not contours:
            return table_coords[1]

        # Extract row and column positions
        horizontal_lines = np.unique(np.where(horizontal > 0)[0])
        vertical_lines = np.unique(np.where(vertical > 0)[1])

        row_positions = sorted(horizontal_lines.tolist())
        col_positions = sorted(vertical_lines.tolist())

        if len(row_positions) < 2 or len(col_positions) < 2:
            return table_coords[1]

        # Create table in the document
        num_rows = len(row_positions) - 1
        num_cols = len(col_positions) - 1
        table = self.doc.add_table(rows=num_rows, cols=num_cols)
        table.style = 'Table Grid'

        for i in range(num_rows):
            for j in range(num_cols):
                # Define cell boundaries
                cell_y1, cell_y2 = row_positions[i], row_positions[i + 1]
                cell_x1, cell_x2 = col_positions[j], col_positions[j + 1]

                # Skip invalid or empty cells
                if cell_y1 >= cell_y2 or cell_x1 >= cell_x2:
                    continue

                # Crop the cell image
                cell_image = table_image[cell_y1:cell_y2, cell_x1:cell_x2]
                if cell_image.size == 0:
                    continue

                # Perform OCR on the cell
                cell_text = pytesseract.image_to_string(
                    cell_image,
                    lang='jpn+eng',
                    config='--psm 6'
                ).strip()

                # Clean and set cell text
                cell_text = self.clean_cell_text(cell_text)
                cell = table.cell(i, j)
                cell.text = cell_text

                # Format text in cell
                paragraph = cell.paragraphs[0]
                run = paragraph.runs[0] if paragraph.runs else paragraph.add_run()
                run.font.name = 'Yu Gothic'
                run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Yu Gothic')

        # Add spacing after the table
        self.doc.add_paragraph()
        return y2

    except Exception as e:
        self.logger.error(f"Table processing error: {str(e)}")
        return table_coords[1]
