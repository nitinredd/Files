import os
import streamlit as st
import tempfile
import logging
from io import BytesIO
import json
import time
import google.auth
from vertexai.preview.generative_models import GenerativeModel, Image as GeminiImage
import fitz  # PyMuPDF
from xhtml2pdf import pisa

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Set up Vertex AI
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "D:/datascience-254609-genai.json"
credentials, project_id = google.auth.default()
multimodal_model = GenerativeModel("gemini-pro-vision")

def get_safe_extraction_prompt():
    return """Extract and analyze the document content with precise attention to layout and structure.
    Tasks:
    1. Identify document sections, tables, and hierarchy
    2. For tables:
       - Preserve exact column and row structure
       - Maintain cell alignments and spacing
       - Keep header rows distinct
    3. Extract text content preserving all formatting
    4. Note any special formatting or structure
    
    Format as JSON:
    {
        "elements": [
            {
                "type": "section|table|list",
                "content": "text content",
                "level": "heading level number",
                "indent": "number of spaces",
                "table_data": {
                    "headers": ["col1", "col2", ...],
                    "rows": [
                        ["cell1", "cell2", ...],
                        ["cell1", "cell2", ...]
                    ],
                    "column_alignments": ["left|center|right", ...]
                }
            }
        ]
    }
    
    Focus on accurately representing tables and maintaining exact document structure."""

def safe_gemini_call(image, max_retries=3, delay=2):
    """Make API calls with retry logic and safety filter handling"""
    prompt = get_safe_extraction_prompt()
    
    for attempt in range(max_retries):
        try:
            response = multimodal_model.generate_content(
                [
                    prompt,
                    image
                ],
                safety_settings={
                    "harassment": "block_none",
                    "hate": "block_none",
                    "sexual": "block_none",
                    "dangerous": "block_none"
                }
            )
            
            if hasattr(response, 'text') and response.text:
                return response
            
        except Exception as e:
            logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
            if attempt < max_retries - 1:
                time.sleep(delay)
                continue
            raise
    
    raise Exception("Failed to get valid response after maximum retries")

def translate_text(text, language):
    if not text:
        return ""
    
    prompt = f"""Provide a professional translation from {language} to English.
    Original text: {text}
    Rules:
    - Maintain all formatting and layout
    - Preserve technical terms
    - Keep document structure
    - For tables, translate cell contents while preserving alignment and format"""
    
    try:
        responses = multimodal_model.generate_content([prompt])
        return responses.text if hasattr(responses, 'text') else ''.join([r.text for r in responses])
    except Exception as e:
        logger.error(f"Translation error: {str(e)}")
        return text

def translate_table_data(table_data, language):
    """Translate table contents while preserving structure"""
    if not table_data:
        return table_data
    
    translated_data = {
        "headers": [translate_text(header, language) for header in table_data.get("headers", [])],
        "rows": [
            [translate_text(cell, language) for cell in row]
            for row in table_data.get("rows", [])
        ],
        "column_alignments": table_data.get("column_alignments", [])
    }
    return translated_data

def extract_images_from_pdf(pdf_file):
    images = []
    temp_pdf_path = None
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_pdf:
            temp_pdf.write(pdf_file.getvalue())
            temp_pdf_path = temp_pdf.name
        
        doc = fitz.open(temp_pdf_path)
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            pix = page.get_pixmap(matrix=fitz.Matrix(3, 3), alpha=False)
            image_bytes = pix.tobytes("png")
            images.append(image_bytes)
            logger.info(f"Extracted image from page {page_num}")
        
        doc.close()
        return images
    finally:
        if temp_pdf_path and os.path.exists(temp_pdf_path):
            try:
                os.unlink(temp_pdf_path)
            except Exception as e:
                logger.error(f"Error deleting temporary PDF file: {str(e)}")

def parse_response(response):
    """Parse API response with enhanced table handling"""
    try:
        if isinstance(response, str):
            return json.loads(response)
            
        if hasattr(response, 'text'):
            text = response.text
        else:
            text = ''.join([r.text for r in response])
        
        start = text.find('{')
        end = text.rfind('}') + 1
        
        if start >= 0 and end > start:
            json_str = text[start:end]
            return json.loads(json_str)
            
    except Exception as e:
        logger.error(f"Error parsing response: {str(e)}")
    
    return {
        "elements": [
            {
                "type": "section",
                "content": str(text),
                "level": 1,
                "indent": 0
            }
        ]
    }

def create_table_html(table_data):
    """Generate HTML for table with proper styling"""
    if not table_data:
        return ""
    
    html = """
    <table style="width:100%; border-collapse: collapse; margin: 10px 0;">
        <thead>
            <tr>
    """
    
    # Add headers with alignment
    alignments = table_data.get("column_alignments", ["left"] * len(table_data.get("headers", [])))
    for header, alignment in zip(table_data.get("headers", []), alignments):
        html += f'<th style="border: 1px solid #ddd; padding: 8px; text-align: {alignment};">{header}</th>'
    
    html += "</tr></thead><tbody>"
    
    # Add rows with alignment
    for row in table_data.get("rows", []):
        html += "<tr>"
        for cell, alignment in zip(row, alignments):
            html += f'<td style="border: 1px solid #ddd; padding: 8px; text-align: {alignment};">{cell}</td>'
        html += "</tr>"
    
    html += "</tbody></table>"
    return html

def convert_to_html(parsed_data):
    html_content = """
    <html>
    <head>
        <style>
            body { 
                font-family: Arial, sans-serif; 
                margin: 20px; 
                line-height: 1.6;
            }
            .section {
                margin: 10px 0;
                white-space: pre-wrap;
            }
            .level-1 { margin-left: 0px; font-weight: bold; font-size: 1.2em; }
            .level-2 { margin-left: 20px; font-weight: bold; }
            .level-3 { margin-left: 40px; }
            .level-4 { margin-left: 60px; }
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 10px 0;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #f5f5f5;
            }
        </style>
    </head>
    <body>
    """
    
    for element in parsed_data.get('elements', []):
        element_type = element.get('type', 'section')
        indent = int(element.get('indent', 0))
        level = int(element.get('level', 1))
        
        if element_type == 'table':
            html_content += create_table_html(element.get('table_data', {}))
        else:
            content = element.get('content', '')
            html_content += f"""
            <div class="section level-{level}" style="margin-left: {indent * 10}px">
                {content}
            </div>
            """
    
    html_content += "</body></html>"
    return html_content

def create_pdf(html_content):
    pdf_buffer = BytesIO()
    pisa.CreatePDF(
        BytesIO(html_content.encode('utf-8')),
        dest=pdf_buffer,
        encoding='utf-8'
    )
    pdf_buffer.seek(0)
    return pdf_buffer

def process_document(image_data, language):
    """Process document with enhanced table handling"""
    try:
        response = safe_gemini_call(image_data)
        parsed_data = parse_response(response)
        
        translated_data = {"elements": []}
        for element in parsed_data.get('elements', []):
            if element.get('type') == 'table':
                # Handle table translation
                translated_table_data = translate_table_data(element.get('table_data', {}), language)
                translated_data['elements'].append({
                    "type": "table",
                    "table_data": translated_table_data,
                    "level": element.get('level', 1),
                    "indent": element.get('indent', 0)
                })
            else:
                # Handle regular content translation
                translated_content = translate_text(element.get('content', ''), language)
                translated_data['elements'].append({
                    "type": element.get('type', 'section'),
                    "content": translated_content,
                    "level": element.get('level', 1),
                    "indent": element.get('indent', 0)
                })
        
        return translated_data
    except Exception as e:
        logger.error(f"Document processing error: {str(e)}")
        raise

def main():
    st.title("Document Translator - Chinese & Japanese to English")
    
    option = st.selectbox("Select document type:", ["PDF", "Image"])
    
    if option == "PDF":
        uploaded_file = st.file_uploader("Upload PDF document", type="pdf")
    else:
        uploaded_file = st.file_uploader("Upload image", type=["png", "jpg", "jpeg"])
    
    language = st.selectbox("Source language:", ["Chinese", "Japanese"])
    
    if st.button("Translate"):
        if uploaded_file:
            try:
                with st.spinner('Processing document...'):
                    if option == "PDF":
                        images = extract_images_from_pdf(uploaded_file)
                        if not images:
                            st.error("Could not extract images from PDF.")
                            return
                        
                        combined_data = {"elements": []}
                        progress = st.progress(0)
                        
                        for idx, img_data in enumerate(images):
                            image = GeminiImage.from_bytes(img_data)
                            page_data = process_document(image, language)
                            combined_data['elements'].extend(page_data['elements'])
                            progress.progress((idx + 1) / len(images))
                        
                        html_content = convert_to_html(combined_data)
                        pdf_buffer = create_pdf(html_content)
                        
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                    
                    else:  # Single image
                        st.image(uploaded_file, caption='Original Document', use_column_width=True)
                        image = GeminiImage.from_bytes(uploaded_file.getvalue())
                        
                        translated_data = process_document(image, language)
                        
                        st.subheader("Translation Preview")
                        html_content = convert_to_html(translated_data)
                        st.markdown(html_content, unsafe_allow_html=True)
                        
                        pdf_buffer = create_pdf(html_content)
                        st.download_button(
                            "Download Translated PDF",
                            data=pdf_buffer,
                            file_name="translated_document.pdf",
                            mime="application/pdf"
                        )
                
            except Exception as e:
                st.error(f"An error occurred: {str(e)}")
                logger.exception("Processing error")
        else:
            st.error("Please upload a document to translate.")

if __name__ == "__main__":
    main()
