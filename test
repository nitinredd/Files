import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

# (Assume predictive_optimal_combinations_fractional is defined as above)

if input1 == 1:
    print("According to FDA ≥ 85% guidelines\n")

    # 1) Criteria & CV
    both_85 = check_both_85(reference_df, test_df)
    print("Both ≥ 85% criterion met:   ", both_85)

    cv_check = check_cv(test_df) and check_cv(reference_df)
    print("\nCV <20 at first non-zero, <10 thereafter:", cv_check, "\n")

    # (0) Drop zero‐time rows
    reference_df = reference_df[reference_df.iloc[:, 0] != 0].reset_index(drop=True)
    test_df      = test_df[test_df.iloc[:, 0] != 0].reset_index(drop=True)

    # 2) Verify time alignment
    if not check_same_time_points(reference_df, test_df):
        print("Error: Time points do not match. Cannot proceed.")
    else:
        try:
            # 3) Conventional FDA f2 & trimming
            f2_conv, f2_exp, ref_trim, test_trim = calculate_f2_fda(reference_df, test_df)
            # [existing printing + plotting code here…]
        except ValueError as e:
            print("❌", e)
            print("Cannot perform FDA-rule f2 calculation.")

    # 4) Predictive optimal‐combo?
    run_predictive = input("\nDo you want to run predictive optimal combination analysis? (yes/no): ")
    if run_predictive.lower() == 'yes':
        window_min, window_max = determine_candidate_window(
            reference_mean_df, test_mean_df, step=5, initial_threshold=10
        )
        regulation_map     = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
        selected_regulation = regulation_map.get(input1, "FDA")
        print(f"\nCandidate window for combination search: {window_min} to {window_max}\n")

        # Try integer‐grid first, then fallback
        try:
            results, _ = predictive_optimal_combinations_advanced(
                reference_mean_df,
                test_mean_df,
                regulation         = selected_regulation,
                window_min         = window_min,
                window_max         = window_max,
                diff_threshold     = None,
                interp_method      = 'linear',
                points_per_stratum = None
            )
            print("✅ Used original integer‐grid function\n")
        except ValueError as e:
            print(f"⚠️ Original function failed: {e}")
            print("   Falling back to fractional‐grid version (0.25 h increments)...\n")
            results, _ = predictive_optimal_combinations_fractional(
                reference_mean_df,
                test_mean_df,
                regulation    = selected_regulation,
                window_min    = window_min,
                window_max    = window_max,
                step_hours    = 0.25,
                interp_method = 'linear'
            )

        # Normalize sequence (ints vs floats)
        for cand in results:
            cand['sequence'] = [
                int(t) if float(t).is_integer() else t
                for t in cand['sequence']
            ]

        best = results[0]
        print("=== Optimal Predictive Combination ===")
        print(f"Time Points: {best['sequence']}")
        print(f"Predicted f2 Score: {best['f2']}")

        # Plot predicted dissolution
        seq = best['sequence']
        ref_diss  = interpolate_dissolution_curve(reference_mean_df, np.array(seq), method='linear')
        test_diss = interpolate_dissolution_curve(test_mean_df,      np.array(seq), method='linear')

        plt.figure(figsize=(12, 6))
        plt.plot(seq, ref_diss,  'bo-', label='Reference')
        plt.plot(seq, test_diss, 'r*--', label='Test')
        plt.title(f"Optimal Profile: Predicted Dissolution (f2 = {best['f2']})")
        plt.xlabel('Time (h)')
        plt.ylabel('Dissolution (%)')
        plt.grid(True)
        plt.legend()
        plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True, prune='lower'))
        plt.show()

        # Show table of predicted values
        print("\nPredicted Reference Dissolution (%):")
        for t, d in zip(seq, ref_diss):
            print(f"  {t} h: {d:.2f}%")
        print("\nPredicted Test Dissolution (%):")
        for t, d in zip(seq, test_diss):
            print(f"  {t} h: {d:.2f}%")

        print("\n=== All Candidate Combinations ===")
        for i, cand in enumerate(results, 1):
            print(f"{i:2d}. Points: {cand['sequence']} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
