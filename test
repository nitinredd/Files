// src/App.jsx (robust: verifies server stored LHS before start_run)
import React, { useEffect, useState } from "react";
import axios from "axios";

const API_BASE = ""; // "" for proxy (recommended). Or "http://localhost:8000" to call backend directly.

export default function App() {
  const [lhsFile, setLhsFile] = useState(null);
  const [lhs, setLhs] = useState(null);
  const [results, setResults] = useState(null);

  const [objectivesText, setObjectivesText] = useState("Yield:Maximize,Purity:Minimize");
  const [sorIter, setSorIter] = useState(3);
  const [watchPath, setWatchPath] = useState("");

  // HPLC params
  const [YminRT, setYminRT] = useState(2.0);
  const [YmaxRT, setYmaxRT] = useState(4.0);
  const [IminRT, setIminRT] = useState("0.7");
  const [ImaxRT, setImaxRT] = useState("1.3");
  const [minRTISO, setMinRTISO] = useState(10.0);
  const [maxRTISO, setMaxRTISO] = useState(12.0);

  const [polling, setPolling] = useState(true);

  useEffect(() => {
    let id;
    if (polling) {
      fetchResults();
      id = setInterval(fetchResults, 2500);
    }
    return () => clearInterval(id);
  }, [polling]);

  async function fetchResults() {
    try {
      const res = await axios.get(`${API_BASE}/results`);
      setResults(res.data);
      setLhs(res.data.lhs_table || null);
    } catch (err) {
      // ignore; might be backend down
    }
  }

  function parseObjectives(text) {
    return text.split(",").map(p => p.trim()).filter(Boolean).map(entry => {
      const [nameRaw, modeRaw] = entry.split(":").map(x => x && x.trim());
      return { name: nameRaw || "obj", maximize: (modeRaw || "Maximize").toLowerCase().startsWith("max") };
    });
  }

  // Upload LHS and verify server stored it
  async function uploadLHS() {
    if (!lhsFile) { alert("Select an LHS Excel (.xlsx/.xls) file"); return; }
    try {
      const form = new FormData();
      form.append("file", lhsFile);
      const url = `${API_BASE}/upload_lhs`;
      const res = await axios.post(url, form, { headers: { "Content-Type": "multipart/form-data" }});
      // show server response immediately
      if (res.data) {
        if (res.data.status === "ok") {
          alert(`Upload success: server stored ${res.data.n} rows. Columns: ${res.data.columns.join(", ")}`);
        } else {
          alert("Upload returned: " + JSON.stringify(res.data));
        }
      }
      // Immediately poll results to check server LHS presence
      await fetchResults();
      if (!results || !results.lhs_table) {
        // fetchResults sets state asynchronously; fetch directly to be sure
        const check = await axios.get(`${API_BASE}/results`);
        if (!check.data || !check.data.lhs_table) {
          alert("Warning: server did not register uploaded LHS. Check backend logs and proxy configuration. Full response: " + JSON.stringify(res.data));
          return;
        } else {
          setResults(check.data);
          setLhs(check.data.lhs_table);
          alert("Confirmed: server has stored LHS (rows = " + check.data.lhs_table.length + ").");
        }
      } else {
        alert("Confirmed: server has stored LHS (rows = " + results.lhs_table.length + ").");
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Upload LHS failed: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // Start run after verifying server has LHS in memory
  async function startRun() {
    try {
      // check server has lhs
      const chk = await axios.get(`${API_BASE}/results`);
      if (!chk.data || !chk.data.lhs_table) {
        alert("Server reports no LHS stored. Please upload LHS first. Full /results response: " + JSON.stringify(chk.data));
        return;
      }
      // prepare payload
      const objectives = parseObjectives(objectivesText);
      if (objectives.length === 0) { alert("Enter at least one objective"); return; }
      const payload = {
        objectives: objectives,
        hplc_params: {
          YminRT: Number(YminRT),
          YmaxRT: Number(YmaxRT),
          IminRT_list: IminRT.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
          ImaxRT_list: ImaxRT.split(",").map(x => Number(x.trim())).filter(x => !Number.isNaN(x)),
          minRTISO: Number(minRTISO),
          maxRTISO: Number(maxRTISO)
        },
        watch_path: (watchPath && watchPath.trim() !== "") ? watchPath.trim() : null,
        sor_iterations: Number(sorIter) || 0
      };
      const url = `${API_BASE}/start_run`;
      const res = await axios.post(url, payload, { headers: { "Content-Type": "application/json" }});
      if (res.data) {
        if (res.data.status === "running" || res.data.status === "watching" || res.data.status === "ok") {
          alert("Run started successfully: " + JSON.stringify(res.data));
          // refresh results
          await fetchResults();
        } else {
          alert("Start run response: " + JSON.stringify(res.data));
        }
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Start run failed: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // Upload single HPLC CSV to fill next row
  const [hplcFile, setHplcFile] = useState(null);
  async function uploadHplc() {
    if (!hplcFile) { alert("Select CSV file"); return; }
    try {
      const form = new FormData();
      form.append("file", hplcFile);
      const params = {
        YminRT: Number(YminRT),
        YmaxRT: Number(YmaxRT),
        IminRT_list: IminRT,
        ImaxRT_list: ImaxRT,
        minRTISO: Number(minRTISO),
        maxRTISO: Number(maxRTISO)
      };
      const res = await axios.post(`${API_BASE}/upload_hplc`, form, { params, headers: { "Content-Type": "multipart/form-data" }});
      if (res.data && res.data.status === "ok") {
        alert(`HPLC processed: ${res.data.filename} response=${JSON.stringify(res.data.response)} next_row=${res.data.next_row}`);
        await fetchResults();
      } else {
        alert("Upload HPLC returned: " + JSON.stringify(res.data));
      }
    } catch (err) {
      const msg = err.response?.data || err.message || String(err);
      alert("Upload HPLC failed: " + JSON.stringify(msg));
      console.error(err);
    }
  }

  // Small UI
  return (
    <div style={{ padding: 20, maxWidth: 1100, margin: "0 auto", fontFamily: "Inter, Arial, sans-serif" }}>
      <h2>SOR UI â€” robust start_run / upload_lhs flow</h2>

      <section style={card}>
        <h3>1) Upload LHS (.xlsx)</h3>
        <input type="file" accept=".xlsx,.xls" onChange={e => setLhsFile(e.target.files?.[0] || null)} />
        <button style={btn} onClick={uploadLHS}>Upload LHS</button>
        <div style={{ marginTop: 8 }}>
          <small>After upload, this component will immediately check /results to confirm the server stored the table.</small>
        </div>
      </section>

      <section style={card}>
        <h3>2) Configure run & start</h3>
        <div style={{ display: "flex", gap: 12, flexWrap: "wrap", alignItems: "center" }}>
          <div style={{ minWidth: 420 }}>
            <label>Objectives (e.g. Yield:Maximize,Purity:Minimize)</label><br/>
            <input style={input} value={objectivesText} onChange={e => setObjectivesText(e.target.value)} />
          </div>
          <div>
            <label>Watch path (server absolute path; optional)</label><br/>
            <input style={{...input, width: 320}} value={watchPath} onChange={e => setWatchPath(e.target.value)} />
          </div>
          <div>
            <label>SOR iterations (after LHS files)</label><br/>
            <input style={{ width: 90, padding: 8 }} type="number" value={sorIter} onChange={e => setSorIter(Number(e.target.value))} />
          </div>
          <div style={{display:"flex", gap:8}}>
            <button style={btn} onClick={startRun}>Start Run</button>
          </div>
        </div>

        <details style={{ marginTop: 8 }}>
          <summary>HPLC parse params</summary>
          <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
            <div><small>YminRT</small><br/><input style={small} value={YminRT} onChange={e=>setYminRT(e.target.value)} /></div>
            <div><small>YmaxRT</small><br/><input style={small} value={YmaxRT} onChange={e=>setYmaxRT(e.target.value)} /></div>
            <div><small>IminRTs</small><br/><input style={small} value={IminRT} onChange={e=>setIminRT(e.target.value)} /></div>
            <div><small>ImaxRTs</small><br/><input style={small} value={ImaxRT} onChange={e=>setImaxRT(e.target.value)} /></div>
            <div><small>ISO min</small><br/><input style={small} value={minRTISO} onChange={e=>setMinRTISO(e.target.value)} /></div>
            <div><small>ISO max</small><br/><input style={small} value={maxRTISO} onChange={e=>setMaxRTISO(e.target.value)} /></div>
          </div>
        </details>
      </section>

      <section style={card}>
        <h3>3) Upload HPLC CSV (fills next row)</h3>
        <input type="file" accept=".csv" onChange={e => setHplcFile(e.target.files?.[0] || null)} />
        <button style={btn} onClick={uploadHplc}>Upload HPLC</button>
      </section>

      <section style={card}>
        <h3>Server /results (live)</h3>
        <pre style={{ maxHeight: 260, overflow: "auto", background: "#0b1220", color: "#cff", padding: 8 }}>
          {results ? JSON.stringify(results, null, 2) : "No data yet"}
        </pre>
      </section>

      <footer style={{ marginTop: 12 }}>
        <label><input type="checkbox" checked={polling} onChange={e => setPolling(e.target.checked)} /> Poll /results</label>
      </footer>
    </div>
  );
}

const card = { background: "#fff", padding: 12, borderRadius: 8, marginBottom: 12, boxShadow: "0 6px 18px rgba(15,20,50,0.06)" };
const btn = { background: "#0b5fff", color: "#fff", padding: "8px 12px", border: "none", borderRadius: 6 };
const input = { width: "100%", padding: 8, borderRadius: 6, border: "1px solid #ddd" };
const small = { width: 84, padding: 6, borderRadius: 6, border: "1px solid #ddd" };
