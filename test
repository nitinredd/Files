import itertools
import numpy as np
import pandas as pd
from scipy.stats import norm
from sklearn.utils import resample

def generate_time_permutations(times):
    """
    Generate all order-sensitive permutations of time points for lengths
    between 3 and len(times) (inclusive). If 0 is not present in the input list,
    it is added automatically.
    """
    try:
        # Convert to integers
        times = [int(t) for t in times]
        # Ensure 0 is included even if its row is all zeros
        if 0 not in times:
            times.insert(0, 0)
        
        all_perms = []
        for r in range(3, len(times)+1):
            perms = list(itertools.permutations(times, r))
            all_perms.extend(perms)
        print(f"Generated {len(all_perms)} permutations")
        return [list(perm) for perm in all_perms]
    except Exception as e:
        print(f"Permutation generation error: {str(e)}")
        return []

def permutation_compliance_check(perm, regulation, ref_means, test_means):
    """
    Check compliance for a given time sequence (order-sensitive) based on the regulatory rules.
    """
    reasons = []
    compliant = True
    
    # FDA: No points after the first 85% dissolution
    if regulation == "FDA":
        found_85 = False
        for i, t in enumerate(perm):
            if ref_means.get(t, 0) >= 85 or test_means.get(t, 0) >= 85:
                if i < len(perm)-1:  # 85% dissolution allowed only at the last time point
                    reasons.append(f"Early 85% at position {i+1} ({t} min)")
                    compliant = False
                found_85 = True
                break
        if not found_85 and 0 not in perm:
            reasons.append("Missing zero time point")
            compliant = False
                
    # EMA: All points must be below 85% and at least 4 time points
    elif regulation == "EMA":
        over_points = [t for t in perm if ref_means.get(t, 0) >= 85 or test_means.get(t, 0) >= 85]
        if over_points:
            reasons.append(f"85%+ dissolution at: {over_points}")
            compliant = False
        if len(perm) < 4:
            reasons.append("Requires ≥4 time points")
            compliant = False
    
    # China: Only the reference product is checked (no point with ≥85% dissolution)
    elif regulation == "China":
        over_ref = [t for t in perm if ref_means.get(t, 0) >= 85]
        if over_ref:
            reasons.append(f"Reference ≥85% at: {over_ref}")
            compliant = False
    
    # ASEAN: First 3 points must be below 85% for both reference and test
    elif regulation == "ASEAN":
        check_points = perm[:3] if len(perm) >= 3 else perm
        over_ref = [t for t in check_points if ref_means.get(t, 0) >= 85]
        over_test = [t for t in check_points if test_means.get(t, 0) >= 85]
        if over_ref:
            reasons.append(f"Reference ≥85% in first 3 points: {over_ref}")
            compliant = False
        if over_test:
            reasons.append(f"Test ≥85% in first 3 points: {over_test}")
            compliant = False
    
    # ANVISA: Zero must be the first time point
    elif regulation == "ANVISA":
        if 0 not in perm:
            reasons.append("Missing zero time point")
            compliant = False
        elif perm[0] != 0:
            reasons.append("Zero not in first position")
            compliant = False
    
    return (compliant, " | ".join(reasons) if reasons else "Compliant")

def full_permutation_analysis(ref_df, test_df, regulation):
    """
    Complete permutation analysis using the generated permutations.
    Each permutation (order-sensitive) is evaluated with an f2 calculation
    and compliance check based on the specified regulation.
    """
    try:
        # Get original time points from the first column
        times = ref_df.iloc[:, 0].tolist()
        # Force inclusion of 0 if missing
        if 0 not in times:
            times.insert(0, 0)
        
        # Prepare dissolution data by calculating the mean for each time point (row)
        # If 0 was artificially added, assign its dissolution mean as 0.
        ref_means = ref_df.set_index(ref_df.columns[0]).iloc[:, 1:].mean(axis=1).to_dict()
        test_means = test_df.set_index(test_df.columns[0]).iloc[:, 1:].mean(axis=1).to_dict()
        if 0 not in ref_means:
            ref_means[0] = 0
        if 0 not in test_means:
            test_means[0] = 0
        
        # Generate all order-sensitive permutations for lengths 3 through len(times)
        perms = generate_time_permutations(times)
        print(f"Analyzing {len(perms)} permutations for {regulation}...")
        
        results = []
        for perm in perms:
            try:
                p = len(perm)
                # Use the permutation as generated (order matters)
                time_order = perm
                
                # Retrieve mean dissolution values in the order of the current sequence
                ref_values = [ref_means.get(t, 0) for t in time_order]
                test_values = [test_means.get(t, 0) for t in time_order]
                
                # Calculate the f2 value (using the provided formula)
                diff = np.array(test_values) - np.array(ref_values)
                sum_sq = (diff ** 2).sum()
                f2 = 100 - 25 * np.log10(1 + (sum_sq / p)) if p > 0 else 0
                
                # Perform the compliance check for the given regulation
                compliant, reason = permutation_compliance_check(time_order, regulation, ref_means, test_means)
                
                results.append({
                    'permutation': time_order,
                    'f2': round(f2, 2),
                    'length': p,
                    'compliant': compliant,
                    'reason': reason
                })
            except Exception as e:
                print(f"Error processing {perm}: {str(e)}")
                continue
                
        # Sort the results (e.g., by descending f2 and then by sequence length)
        return sorted(results, key=lambda x: (-x['f2'], x['length']))
    
    except Exception as e:
        print(f"Analysis failed: {str(e)}")
        return []

def display_permutation_results(results, regulation):
    """
    Display the permutation analysis results with details for each sequence.
    """
    if not results:
        print("\nNo valid permutations found")
        return
    
    # Set page size to the total number of results so all are displayed on one page.
    page_size = len(results)
    
    print(f"\n{'='*120}")
    print(f" Complete Permutation Analysis ({regulation})")
    print(f"{'Time Sequence':<40} | {'Length':<6} | {'f2':<8} | {'Status':<8} | Compliance Details")
    print("-"*120)
    
    for res in results[:page_size]:
        status = "✅" if res['compliant'] else "❌"
        print(f"{str(res['permutation']):<40} | {res['length']:^6} | {res['f2']:^8.2f} | {status:^8} | {res['reason']}")
    
    compliant_results = [r for r in results if r['compliant']]
    if compliant_results:
        best = max(compliant_results, key=lambda x: x['f2'])
        print(f"\nOptimal Compliant Combination:")
        print(f"Sequence: {best['permutation']}")
        print(f"f2 Score: {best['f2']:.2f}")
        print(f"Compliance: {best['reason']}")
    print("="*120 + "\n")

# ====================== INTEGRATION WITH MAIN CODE ======================
# Assumes that reference_df, test_df, input1, and check_same_time_points are defined.
regulation_map = {
    1: "FDA",
    2: "EMA", 
    3: "China",
    4: "ASEAN",
    5: "ANVISA"
}

if check_same_time_points(reference_df, test_df):
    print("\nRunning advanced permutation analysis...")
    perm_results = full_permutation_analysis(
        reference_df.copy(),
        test_df.copy(),
        regulation_map[input1]
    )
    display_permutation_results(perm_results, regulation_map[input1])
else:
    print("\nSkipping permutation analysis - Time points mismatch")
