if run_predictive.lower() == 'yes':
    # Determine candidate window
    window_min, window_max = determine_candidate_window(
        reference_mean_df, 
        test_mean_df,
        step=5,
        initial_threshold=10
    )
    
    # Map regulation for predictive analysis
    regulation_map = {1: "FDA", 2: "EMA", 3: "China", 4: "ASEAN", 5: "ANVISA"}
    selected_regulation = regulation_map.get(input1, "FDA")
    
    # Run predictive analysis under different conditions
    conditions = [("Diff threshold 10", 10), 
                  ("Diff threshold 20", 20), 
                  ("No diff check", None)]
    
    all_candidates = []
    overall_best = None
    overall_best_f2 = -np.inf

    print(f"\nCandidate window for combination search: {window_min} to {window_max} (using union of 3 & 5 minute intervals)")
    
    for cond_label, threshold in conditions:
        print(f"\nProcessing candidates for condition: {cond_label}")
        
        # Get results for this condition
        top_results, all_results = predictive_optimal_combinations_advanced(
            reference_mean_df,
            test_mean_df,
            regulation=selected_regulation,
            window_min=window_min,
            window_max=window_max,
            diff_threshold=threshold,
            num_samples=1000000
        )
        
        # Add condition label and update dissolution range info for each candidate
        for res in top_results:
            res['condition'] = cond_label
            seq = res['sequence']
            ref_vals = interpolate_dissolution_curve(reference_mean_df, seq, method='gpr')
            test_vals = interpolate_dissolution_curve(test_mean_df, seq, method='gpr')
            max_diss = max(np.nanmax(ref_vals), np.nanmax(test_vals))
            res['diss_range'] = (
                "0-30%" if max_diss <= 30 else
                "30-60%" if max_diss <= 60 else
                "60-90%" if max_diss <= 90 else
                "90-120%" if max_diss <= 120 else
                "120%+"
            )
            # Diversity check: candidate is diverse if it has at least one time point (besides endpoints)
            # in each segment: early (window_min, early_bound), mid [early_bound, mid_bound), late [mid_bound, window_max)
            early_bound = window_min + (window_max - window_min) / 3.0
            mid_bound   = window_min + 2*(window_max - window_min) / 3.0
            has_early = any(t > window_min and t < early_bound for t in seq)
            has_mid   = any(t >= early_bound and t < mid_bound for t in seq)
            has_late  = any(t >= mid_bound and t < window_max for t in seq)
            diverse = has_early and has_mid and has_late
            res['diverse'] = diverse
        all_candidates.extend(top_results)
        
        # Track overall best candidate (across conditions)
        for cand in top_results:
            if cand.get('diverse', False) and cand['f2'] > overall_best_f2:
                overall_best = cand
                overall_best_f2 = cand['f2']
        # Fallback: if none of the candidates are diverse, choose highest f2 overall
        if overall_best is None and top_results:
            current_best = max(top_results, key=lambda x: x['f2'])
            overall_best = current_best
            overall_best_f2 = current_best['f2']

    # ===== Duplicate Filtering =====
    unique_candidates_dict = {}
    for cand in all_candidates:
        seq_tuple = tuple(cand['sequence'])
        if seq_tuple in unique_candidates_dict:
            if cand['f2'] > unique_candidates_dict[seq_tuple]['f2']:
                unique_candidates_dict[seq_tuple] = cand
        else:
            unique_candidates_dict[seq_tuple] = cand
    unique_candidates = list(unique_candidates_dict.values())
    
    def print_range_stats(candidates):
        ranges = ["0-30%", "30-60%", "60-90%", "90-120%", "120%+"]
        stats = {r: {"total": 0, "compliant": 0} for r in ranges}
        for cand in candidates:
            rng = cand.get('diss_range', 'Unknown')
            if rng in stats:
                stats[rng]['total'] += 1
                if cand['compliant']:
                    stats[rng]['compliant'] += 1
            else:
                stats[rng] = {"total": 1, "compliant": 1 if cand['compliant'] else 0}
        print("\n=== Dissolution Range Distribution ===")
        for rng, data in stats.items():
            if data['total'] > 0:
                compliance_rate = (data['compliant']/data['total'])*100
                print(f"{rng}:")
                print(f"  Total combinations: {data['total']}")
                print(f"  Compliant combinations: {data['compliant']}")
                print(f"  Compliance rate: {compliance_rate:.1f}%")
    
    # ===== Display Final Results =====
    if overall_best:
        print("\n=== Optimal Predictive Combination ===")
        print(f"Condition: {overall_best.get('condition','N/A')}")
        print(f"Dissolution Range: {overall_best.get('diss_range','N/A')}")
        print(f"Time Points (3/5 min intervals): {overall_best['sequence']}")
        print(f"Length: {len(overall_best['sequence'])}")
        print(f"Predicted f2 Score: {overall_best['f2']}")
        print(f"Diverse Combination: {overall_best.get('diverse', False)}")
        
        if overall_best['reasons']:
            print(f"Compliance Issues: {', '.join(overall_best['reasons'])}")
        else:
            print("Regulatory Compliance: Passed")
        
        print_range_stats(unique_candidates)
        
        # Plot results and show predicted dissolution percentages
        plt.figure(figsize=(12, 6))
        time_points = overall_best['sequence']
        ref_diss = interpolate_dissolution_curve(reference_mean_df, time_points, method='gpr')
        test_diss = interpolate_dissolution_curve(test_mean_df, time_points, method='gpr')
        plt.plot(time_points, ref_diss, 'bo-', label='Reference')
        plt.plot(time_points, test_diss, 'r*--', label='Test')
        plt.title(f"Optimal Profile: {overall_best.get('diss_range','N/A')} Dissolution (f2 = {overall_best['f2']})")
        plt.xlabel('Time (min)')
        plt.ylabel('Dissolution (%)')
        plt.legend()
        plt.grid(True)
        plt.show()
        
        # Print the predicted dissolution percentages for each time point
        print("\nPredicted Reference Dissolution Percentages:")
        for t, d in zip(time_points, ref_diss):
            print(f"Time {t} min: {d:.2f}%")
        print("\nPredicted Test Dissolution Percentages:")
        for t, d in zip(time_points, test_diss):
            print(f"Time {t} min: {d:.2f}%")
    else:
        print("‚ùå No valid combinations found across all dissolution ranges")
    
    print("\n=== All Unique Candidate Combinations ===")
    sorted_candidates = sorted(unique_candidates, key=lambda x: -x['f2'])
    for idx, cand in enumerate(sorted_candidates):
        print(f"{idx+1:3d}. {cand.get('diss_range','N/A')} | Points: {cand['sequence']} | Length: {len(cand['sequence'])} | f2: {cand['f2']} | Compliant: {cand['compliant']}")
