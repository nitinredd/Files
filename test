# ====================== ROBUST COMBINATION ANALYSIS ADDITION ======================
import itertools
import sys

def generate_all_combinations(times):
    """Generate all 3+ length combinations with proper type handling"""
    try:
        # Convert to integers and remove duplicates
        times = sorted(list({int(t) for t in times}))
        n = len(times)
        if n < 3:
            print(f"Warning: Only {n} time points available. Need at least 3.")
            return []
        
        all_combos = []
        for r in range(3, n+1):
            all_combos.extend(itertools.combinations(times, r))
        return [list(combo) for combo in all_combos]
    except Exception as e:
        print(f"Error generating combinations: {str(e)}")
        return []

def safe_f2_calculation(ref_sub, test_sub):
    """Robust f2 calculation with error handling"""
    try:
        if ref_sub.empty or test_sub.empty:
            return None
        if len(ref_sub) != len(test_sub):
            return None
            
        p = len(ref_sub)
        diff = test_sub.iloc[:,1:].mean(axis=1) - ref_sub.iloc[:,1:].mean(axis=1)
        sum_sq = (diff ** 2).sum()
        
        # Handle invalid log values
        if (1 + (1/p)*sum_sq) <= 0:
            return None
            
        return 100 - 25 * np.log10(1 + (1/p)*sum_sq)
    except:
        return None

def get_compliance(combo, regulation, ref_data, test_data):
    """Enhanced compliance check with debug logging"""
    try:
        # Get means with time as index
        ref_means = ref_data.set_index(ref_data.columns[0]).iloc[:,1:].mean(axis=1)
        test_means = test_data.set_index(test_data.columns[0]).iloc[:,1:].mean(axis=1)
        
        # FDA: Truncate when either reaches 85%
        if regulation == "FDA":
            ref_85 = ref_means[ref_means >= 85].index.min()
            test_85 = test_means[test_means >= 85].index.min()
            trunc_point = min(ref_85 if not pd.isnull(ref_85) else sys.maxsize, 
                             test_85 if not pd.isnull(test_85) else sys.maxsize)
            return all(t <= trunc_point for t in combo)
        
        # EMA: All points <85%
        elif regulation == "EMA":
            return all(ref_means.get(t, 100) < 85 and 
                      test_means.get(t, 100) < 85 
                      for t in combo)
        
        # ANVISA: No restrictions
        elif regulation == "ANVISA":
            return True
        
        # China: Reference <85%
        elif regulation == "China":
            return all(ref_means.get(t, 100) < 85 for t in combo)
        
        # ASEAN: First 3 points <85%
        elif regulation == "ASEAN":
            first_three = combo[:3] if len(combo)>=3 else combo
            return all(ref_means.get(t, 100) < 85 and 
                      test_means.get(t, 100) < 85 
                      for t in first_three)
        
        return False
    except Exception as e:
        print(f"Compliance check error: {str(e)}")
        return False

def analyze_combinations(ref_df, test_df, regulation):
    """Main analysis function with full error handling"""
    try:
        # Get common time points
        common_times = sorted(list(set(ref_df.iloc[:,0]).intersection(set(test_df.iloc[:,0]))))
        if not common_times:
            print("Error: No common time points between products")
            return []
        
        # Generate combinations
        combos = generate_all_combinations(common_times)
        if not combos:
            print("No valid combinations generated")
            return []
        
        print(f"\nAnalyzing {len(combos)} combinations...")
        
        results = []
        for i, combo in enumerate(combos):
            try:
                # Get subset data
                ref_sub = ref_df[ref_df.iloc[:,0].isin(combo)].sort_values(ref_df.columns[0])
                test_sub = test_df[test_df.iloc[:,0].isin(combo)].sort_values(test_df.columns[0])
                
                # Calculate f2
                f2 = safe_f2_calculation(ref_sub, test_sub)
                if f2 is None:
                    continue
                
                # Check compliance
                compliant = get_compliance(combo, regulation, ref_df, test_df)
                
                results.append({
                    'times': combo,
                    'f2': round(f2, 2),
                    'points': len(combo),
                    'compliant': compliant
                })
                
            except Exception as e:
                print(f"Error processing combo {combo}: {str(e)}")
                continue
        
        return sorted(results, key=lambda x: (-x['f2'], x['points']))
    
    except Exception as e:
        print(f"Analysis failed: {str(e)}")
        return []

def display_results(results, regulation):
    """Robust display function with pagination"""
    if not results:
        print("\nNo valid combinations found")
        return
    
    print(f"\n{'='*80}")
    print(f" COMPLETE ANALYSIS ({regulation.upper()}) ")
    print(f"{'='*80}")
    print(f"Found {len(results)} valid combinations")
    
    # Pagination control
    page_size = 20
    for page in range(0, len(results), page_size):
        print(f"\nCombinations {page+1}-{min(page+page_size, len(results))}:")
        for res in results[page:page+page_size]:
            status = "✅" if res['compliant'] else "❌"
            print(f"{res['times']} → {res['f2']} {status}")
        
        if page + page_size < len(results):
            input("\nPress Enter for more combinations...")
    
    # Show best compliant
    compliant = [r for r in results if r['compliant']]
    if compliant:
        best = max(compliant, key=lambda x: x['f2'])
        print(f"\n{'='*40}")
        print(f"OPTIMAL COMPLIANT COMBINATION:")
        print(f"Time Points: {best['times']}")
        print(f"f2 Score: {best['f2']}")
        print(f"Points: {best['points']}")
        print(f"{'='*40}")
    else:
        print("\nNo compliant combinations found")
# ====================== END ROBUST ADDITION ======================

# ====================== INTEGRATION ======================
# Add this in EACH regulation block after original analysis

regulation_map = {
    1: "FDA",
    2: "EMA",
    3: "China",
    4: "ASEAN",
    5: "ANVISA"
}

try:
    if check_same_time_points(reference_df, test_df):
        analysis_results = analyze_combinations(
            reference_df.copy(),
            test_df.copy(),
            regulation_map.get(input1, "FDA")
        )
        display_results(analysis_results, regulation_map.get(input1, "FDA"))
    else:
        print("\nSkipping combination analysis: Time points mismatch")
except Exception as e:
    print(f"\nCombination analysis failed: {str(e)}")
