import streamlit as st
from PIL import Image
import pandas as pd
import io
import os
import json
import time
from datetime import datetime
import tempfile
import logging
import google.auth
from vertexai.preview.generative_models import GenerativeModel, Image as GeminiImage
import plotly.graph_objects as go

# Setup logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Service account authentication setup and model initialization
@st.cache_resource
def initialize_models():
    try:
        os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "path/to/your/service-account.json"
        credentials, project_id = google.auth.default()
        
        return {
            'multimodal_model': GenerativeModel("gemini-pro-vision"),
            'chat_model': GenerativeModel("gemini-pro"),
            'safety_config': {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE",
            }
        }
    except Exception as e:
        logger.error(f"Error initializing Google credentials: {str(e)}")
        st.error("Failed to initialize models. Please check your service account configuration.")
        raise

# Custom CSS for better UI
st.markdown("""
<style>
.main { padding: 2rem; }
.stButton>button { width: 100%; }
.uploaded-image { max-width: 100%; height: auto; margin: 1rem 0; }
.success-message {
    padding: 1rem;
    background-color: #d4edda;
    border-color: #c3e6cb;
    color: #155724;
    border-radius: 0.25rem;
    margin: 1rem 0;
}
.error-message {
    padding: 1rem;
    background-color: #f8d7da;
    border-color: #f5c6cb;
    color: #721c24;
    border-radius: 0.25rem;
    margin: 1rem 0;
}
.copy-button {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
}
.result-container {
    position: relative;
    padding: 1rem;
    border: 1px solid #ddd;
    border-radius: 0.25rem;
    margin: 1rem 0;
}
</style>
""", unsafe_allow_html=True)

class TableExtractor:
    def __init__(self, models):
        self.multimodal_model = models['multimodal_model']
        self.chat_model = models['chat_model']
        self.safety_config = models['safety_config']
        self.history = []
        
    def process_image(self, image, prompt, retries=3, delay=2):
        for attempt in range(retries):
            try:
                # Convert PIL Image to Gemini Image format
                gemini_image = GeminiImage.from_bytes(
                    image_bytes=self._convert_pil_to_bytes(image)
                )
                
                # Generate content with safety settings
                response = self.multimodal_model.generate_content(
                    contents=[prompt, gemini_image],
                    safety_settings=self.safety_config,
                    generation_config={
                        "temperature": 0.2,
                        "top_p": 0.8,
                        "top_k": 40
                    }
                )
                
                response.resolve()
                
                return {
                    'status': 'success',
                    'data': response.text,
                    'error': None
                }
                
            except Exception as e:
                logger.error(f"Attempt {attempt + 1} failed: {str(e)}")
                if attempt == retries - 1:
                    return {
                        'status': 'error',
                        'data': None,
                        'error': str(e)
                    }
                time.sleep(delay)
    
    def _convert_pil_to_bytes(self, pil_image):
        img_byte_arr = io.BytesIO()
        pil_image.save(img_byte_arr, format='PNG')
        return img_byte_arr.getvalue()
    
    def process_table_format(self, table_text, output_format):
        try:
            if output_format == "markdown":
                return table_text
            elif output_format == "csv":
                lines = table_text.split('\n')
                csv_data = []
                for line in lines:
                    if '|' in line and '-|-' not in line:
                        cells = [cell.strip() for cell in line.split('|')[1:-1]]
                        csv_data.append(','.join(cells))
                return '\n'.join(csv_data)
            elif output_format == "json":
                lines = [line for line in table_text.split('\n') if '|' in line and '-|-' not in line]
                headers = [h.strip() for h in lines[0].split('|')[1:-1]]
                data = []
                for line in lines[1:]:
                    values = [v.strip() for v in line.split('|')[1:-1]]
                    data.append(dict(zip(headers, values)))
                return json.dumps(data, indent=2, ensure_ascii=False)
        except Exception as e:
            return {
                'status': 'error',
                'data': None,
                'error': f"Error converting table format: {str(e)}"
            }
    
    def chat(self, messages):
        try:
            chat = self.chat_model.start_chat()
            response = chat.send_message(
                messages[-1]["content"],
                safety_settings=self.safety_config
            )
            return response.text
        except Exception as e:
            logger.error(f"Chat error: {str(e)}")
            return f"Error in chat: {str(e)}"

def initialize_session_state():
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    if 'extraction_history' not in st.session_state:
        st.session_state.extraction_history = []
    if 'current_result' not in st.session_state:
        st.session_state.current_result = None
    if 'extractor' not in st.session_state:
        models = initialize_models()
        st.session_state.extractor = TableExtractor(models)

def save_extraction_history(image, result):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    st.session_state.extraction_history.append({
        'timestamp': timestamp,
        'image': image,
        'result': result
    })

def display_result_with_copy(result, title="Result"):
    st.subheader(title)
    with st.container():
        st.markdown(result)
        if st.button("ðŸ“‹ Copy to Clipboard", key=f"copy_{title}"):
            st.code(result)
            st.success("Content copied to clipboard!")

def create_table_visualization(table_text):
    try:
        # Parse markdown table
        lines = [line for line in table_text.split('\n') if '|' in line and '-|-' not in line]
        headers = [h.strip() for h in lines[0].split('|')[1:-1]]
        data = []
        for line in lines[1:]:
            values = [v.strip() for v in line.split('|')[1:-1]]
            data.append(values)
            
        # Create Plotly table
        fig = go.Figure(data=[go.Table(
            header=dict(
                values=headers,
                fill_color='paleturquoise',
                align='center'
            ),
            cells=dict(
                values=list(zip(*data)),
                fill_color='lavender',
                align='center'
            )
        )])
        
        fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))
        return fig
    except Exception as e:
        st.error(f"Error creating visualization: {str(e)}")
        return None

def main():
    # Set page config
    st.set_page_config(
        page_title="Japanese Table Extractor & Translator",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    initialize_session_state()
    
    st.title("ðŸ—¾ Japanese Table Extractor & Translator")
    
    with st.sidebar:
        st.header("Mode Selection")
        mode = st.radio(
            "Choose Mode",
            ["Table Extraction & Translation", "Extraction History"]
        )
        
        st.header("About")
        st.info("""
        This app specializes in extracting and translating tables from images 
        containing Japanese text. Features include:
        - Complex table extraction
        - Multiple output formats
        - Interactive visualizations
        - Extraction history
        - Error handling and retries
        """)
    
    if mode == "Table Extraction & Translation":
        handle_table_extraction()
    else:
        handle_extraction_history()

def handle_table_extraction():
    st.header("Upload Image with Japanese Table")
    
    uploaded_file = st.file_uploader(
        "Choose an image file",
        type=['png', 'jpg', 'jpeg'],
        help="Upload an image containing Japanese tables"
    )
    
    if uploaded_file:
        image = Image.open(uploaded_file)
        st.image(image, caption="Uploaded Image", use_column_width=True)
        
        with st.expander("Advanced Options", expanded=True):
            col1, col2 = st.columns(2)
            
            with col1:
                maintain_structure = st.checkbox("Maintain Original Table Structure", value=True)
                include_formatting = st.checkbox("Include Cell Formatting", value=True)
                handle_nested = st.checkbox("Handle Nested Tables", value=True)
            
            with col2:
                output_format = st.selectbox(
                    "Output Format",
                    ["markdown", "csv", "json"]
                )
                
                visualization_type = st.selectbox(
                    "Visualization Type",
                    ["Interactive Table", "Simple Table", "None"]
                )
        
        prompt = f"""
        Extract and translate the Japanese table from this image to English.
        Rules:
        1. Maintain the exact table structure: {maintain_structure}
        2. Translate all Japanese text to English
        3. Preserve formatting: {include_formatting}
        4. Handle nested tables: {handle_nested}
        5. Return the result in a markdown table format
        """
        
        if st.button("Extract and Translate Table"):
            with st.spinner("Processing image..."):
                try:
                    # Process image
                    result = st.session_state.extractor.process_image(image, prompt)
                    
                    if result['status'] == 'success':
                        # Convert to desired format
                        formatted_result = st.session_state.extractor.process_table_format(
                            result['data'],
                            output_format
                        )
                        
                        # Save to history
                        save_extraction_history(image, formatted_result)
                        
                        # Display results
                        st.success("Table extracted and translated successfully!")
                        
                        # Display the result with copy button
                        display_result_with_copy(formatted_result, "Extracted and Translated Table")
                        
                        # Create visualization if requested
                        if visualization_type != "None":
                            st.subheader("Table Visualization")
                            if visualization_type == "Interactive Table":
                                fig = create_table_visualization(result['data'])
                                if fig:
                                    st.plotly_chart(fig, use_container_width=True)
                            else:
                                st.table(pd.read_csv(io.StringIO(formatted_result)))
                        
                        # Download options
                        st.download_button(
                            "Download Results",
                            formatted_result,
                            f"translated_table.{output_format}",
                            mime=f"text/{output_format}"
                        )
                        
                    else:
                        st.error(f"Error: {result['error']}")
                        
                except Exception as e:
                    st.error(f"An unexpected error occurred: {str(e)}")

def handle_extraction_history():
    st.header("Extraction History")
    
    if not st.session_state.extraction_history:
        st.info("No extraction history available yet.")
        return
    
    for idx, entry in enumerate(reversed(st.session_state.extraction_history)):
        with st.expander(f"Extraction {idx + 1} - {entry['timestamp']}", expanded=False):
            col1, col2 = st.columns([1, 2])
            
            with col1:
                st.image(entry['image'], caption="Original Image", use_column_width=True)
            
            with col2:
                display_result_with_copy(entry['result'], "Extracted Result")

if __name__ == "__main__":
    main()
