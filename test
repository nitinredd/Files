import numpy as np
import math

def predictive_optimal_combinations_by_percent(reference_mean_df, test_mean_df,
                                               regulation, window_max,
                                               step_hours=0.25):
    t_ref  = reference_mean_df.iloc[:,0].astype(float).values
    d_ref  = reference_mean_df.iloc[:,1].astype(float).values
    t_test = test_mean_df.iloc[:,0].astype(float).values
    d_test = test_mean_df.iloc[:,1].astype(float).values
    if t_ref[0] != 0.0:
        t_ref  = np.insert(t_ref,  0, 0.0); d_ref  = np.insert(d_ref,  0, 0.0)
        t_test = np.insert(t_test, 0, 0.0); d_test = np.insert(d_test, 0, 0.0)

    grid       = np.arange(0.0, window_max + 1e-8, step_hours)
    ref_pred   = np.interp(grid, t_ref,  d_ref)
    test_pred  = np.interp(grid, t_test, d_test)

    seq = [0.0]

    seen = set()
    for pct in [10, 20, 40, 50, 70, 80]:
        if pct <= ref_pred[-1]:
            t_pt = float(np.interp(pct, ref_pred, grid))
        else:
            t_pt = float(grid[-1])
        t_pt = round(t_pt, 4)
        if t_pt not in seen:
            seen.add(t_pt)
            seq.append(t_pt)

    t_ref85 = float(np.interp(85, ref_pred, grid)) if ref_pred[-1] >= 85 else window_max
    t_test85 = float(np.interp(85, test_pred, grid)) if test_pred[-1] >= 85 else window_max
    if regulation in ("FDA", "ANVISA"):
        extra = max(t_ref85, t_test85)
    else:
        extra = min(t_ref85, t_test85)
    extra = min(extra, float(window_max))
    extra = round(extra, 4)
    if extra not in seen:
        seq.append(extra)

    seq = sorted(set(seq))

    ref_vals  = [float(np.interp(t, grid, ref_pred))  for t in seq]
    test_vals = [float(np.interp(t, grid, test_pred)) for t in seq]
    ref_vals[0]  = 0.0
    test_vals[0] = 0.0
    diffs = np.array(test_vals[1:]) - np.array(ref_vals[1:])
    mse   = np.mean(diffs**2)
    f2    = 50 * math.log10(100 / (1 + math.sqrt(mse)))

    return [{
        'sequence':  seq,
        'f2':        round(f2, 2),
        'compliant': True,
        'reasons':   [],
        'ref_vals':  ref_vals,
        'test_vals': test_vals
    }], None

try:
    results, all_results = predictive_optimal_combinations_advanced(
        reference_mean_df,
        test_mean_df,
        regulation=selected_regulation,
        window_min=window_min,
        window_max=window_max,
        diff_threshold=None,
        interp_method='linear',
        points_per_stratum=None
    )
    print("✅ Used original predictive_optimal_combinations_advanced\n")
except ValueError as e:
    print(f"⚠️ Original function failed: {e}")
    print("   Falling back to percent-targeted predictive function...\n")
    results, _ = predictive_optimal_combinations_by_percent(
        reference_mean_df,
        test_mean_df,
        selected_regulation,
        window_max,
        step_hours=0.25
    )

for cand in results:
    cand['sequence'] = [
        int(t) if float(t).is_integer() else t
        for t in cand['sequence']
    ]
